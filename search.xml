<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>抽离首页小卡片组件</title>
    <url>/2019/12/21/%E6%8A%BD%E7%A6%BB%E9%A6%96%E9%A1%B5%E5%B0%8F%E5%8D%A1%E7%89%87/</url>
    <content><![CDATA[<h1 id="抽离首页小卡片组件"><a href="#抽离首页小卡片组件" class="headerlink" title="抽离首页小卡片组件"></a>抽离首页小卡片组件</h1><h3 id="dpr不同-获取图片倍数问题"><a href="#dpr不同-获取图片倍数问题" class="headerlink" title="dpr不同 获取图片倍数问题"></a>dpr不同 获取图片倍数问题</h3><p>之前的代码：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">storage-info-bg-mixin</span><span class="params">(dpr)</span></span></span><br><span class="line">      <span class="variable">$dpr</span> = <span class="string">"@"</span> + dpr</span><br><span class="line">      &amp;-lun</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/LUN"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-server</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/server"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-file</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/file"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-cifsshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/diskcifs"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-nfsshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/disknfs"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-ftpshare</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/diskftp"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat center</span><br><span class="line">      &amp;-object</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/object"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-rent</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/rent"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line">      &amp;-bucket</span><br><span class="line">          <span class="attribute">background</span> url(<span class="string">"../img/bucket"</span> + <span class="variable">$dpr</span> + <span class="string">".png"</span>) no-repeat left</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对所有的mixin再做一层mixin</span></span><br><span class="line">  media-mixin(mixin)</span><br><span class="line">      mixin(<span class="string">'1x'</span>)</span><br><span class="line">      @media screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>),  screen and (min--moz-device-pixel-ratio: <span class="number">2</span>)</span><br><span class="line">          mixin(<span class="string">'2x'</span>)</span><br><span class="line">      @media screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>),  screen and (min--moz-device-pixel-ratio: <span class="number">3</span>)</span><br><span class="line">          mixin(<span class="string">'3x'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>非常的繁琐,每个不同图片的都要添加一行，还用到了stylus <code>mixin</code>嵌套难以理解</p><p><strong>我的方式</strong></p><p>首先在父组件获取屏幕dpr，防止有个别屏幕dpr不是整数，1.5，1.25什么的，取整，默认dpr为一</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getFloorDPR() &#123;</span><br><span class="line">    <span class="keyword">let</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">    <span class="keyword">let</span> dprMin = <span class="number">1</span>,</span><br><span class="line">        dprMax = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(dpr &gt;= dprMin &amp;&amp; dpr &lt; dprMax) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dpr = <span class="built_in">Math</span>.floor(dpr) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件props，传入图片名即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    image: &#123;   <span class="comment">//传入[图片名 ，屏幕dpr]</span></span><br><span class="line">        type: <span class="built_in">Array</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> [<span class="string">'server'</span>, <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>style动态绑定背景图片</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"storage-info-bg"</span> <span class="attr">:style</span>=<span class="string">"bgIcon"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在data中 得到传过来的值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        bgIcon: &#123;</span><br><span class="line">            background: <span class="string">`url('/.../<span class="subst">$&#123;<span class="keyword">this</span>.image[<span class="number">0</span>]&#125;</span>@<span class="subst">$&#123;<span class="keyword">this</span>.image[<span class="number">1</span>]&#125;</span>x.png') no-repeat`</span> </span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;共享目录&apos;)&#125;：` + `$&#123;this.getShareCount&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getCifsShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;CIFS目录&apos;)&#125;：` + `$&#123;this.cifsStore.cifs_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getNfsShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;NFS目录&apos;)&#125;：` + `$&#123;this.nfsStore.nfs_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getFtpShareCountTip () &#123;</span><br><span class="line">return `$&#123;_(&apos;FTP目录&apos;)&#125;：` + `$&#123;this.ftpStore.ftp_share_dir_num || 0&#125;` + _(&apos;个&apos;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 对象总数</span><br><span class="line">getObjectTotalTip () &#123;</span><br><span class="line">return (`$&#123;_(&apos;对象总数&apos;)&#125;：` +</span><br><span class="line">`$&#123;this.objStore &amp;&amp; this.objStore.object_num || 0&#125;` +</span><br><span class="line">_(&apos;个&apos;));</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 用户账号</span><br><span class="line">getUsersTip () &#123;</span><br><span class="line">return (`$&#123;_(&apos;用户账号&apos;)&#125;：` +</span><br><span class="line">`$&#123;this.objStore &amp;&amp; this.objStore.user_num || 0&#125;` +</span><br><span class="line">_(&apos;个</span><br></pre></td></tr></table></figure><p>非常的繁琐,所以子组件简化为两个方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getCountTip() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">`<span class="subst">$&#123;_(<span class="keyword">this</span>.label)&#125;</span>：<span class="subst">$&#123;<span class="keyword">this</span>.count&#125;</span> <span class="subst">$&#123;_(<span class="string">'个'</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    getConnectTip() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">`<span class="subst">$&#123;_(<span class="string">'已连接'</span>)&#125;</span>：<span class="subst">$&#123;<span class="keyword">this</span>.connect&#125;</span> <span class="subst">$&#123;_(<span class="string">'个'</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="单位拆分"><a href="#单位拆分" class="headerlink" title="单位拆分"></a>单位拆分</h3><p><strong>原代码</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number"</span>&gt;</span>&#123;&#123;showNumber(objStore &amp;&amp; objStore.object_num).val&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"unit"</span>&gt;</span><span class="tag">&lt;<span class="name">lang</span>&gt;</span>&#123;&#123;showNumber(objStore &amp;&amp; objStore.object_num).unit&#125;&#125;<span class="tag">&lt;/<span class="name">lang</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次返回个对象，每次都要调用两次方法，非常别扭，substr这个方法MDN说已经块要废弃了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showNumber (num) &#123;</span><br><span class="line">    <span class="keyword">let</span> showNum = numSize(num || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (showNum &amp;&amp; !lodash.isNumber(showNum))&#123;</span><br><span class="line">        <span class="keyword">let</span> numPosition = showNum.search(<span class="regexp">/万|亿/g</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            val: showNum.substr(<span class="number">0</span>, numPosition),</span><br><span class="line">            unit: showNum.substr(numPosition)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        val: showNum,</span><br><span class="line">        unit: _(<span class="string">'个'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr><p><strong>我的优化</strong>：正则优化 使用 <code>split</code>，然后把计算放入data，template直接取，避免重复调用方法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number"</span>&gt;</span>&#123;&#123;unitValue[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"number-unit"</span>&gt;</span>&#123;&#123;unitValue[1]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showNumber() &#123;</span><br><span class="line">    <span class="keyword">let</span> showNum = numSize(<span class="keyword">this</span>.count);</span><br><span class="line">    lodash.isNumber(showNum)</span><br><span class="line">        ? <span class="keyword">this</span>.unitValue = [showNum, _(<span class="string">'个'</span>)]</span><br><span class="line">        : <span class="keyword">this</span>.unitValue = showNum.split(<span class="regexp">/(万|亿)/g</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>组件提取</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>抽象</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用css翻转背景图</title>
    <url>/2019/12/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E7%BF%BB%E8%BD%AC%E8%83%8C%E6%99%AF%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="如何使用css翻转背景图"><a href="#如何使用css翻转背景图" class="headerlink" title="如何使用css翻转背景图"></a>如何使用css翻转背景图</h1><p>在网上看的css 翻转，要么用html<img>标签，实体图，要么就是全部翻转了，</p><p>想到一个好办法，用伪元素处理背景图片</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">    .site-info-slave</span><br><span class="line">        <span class="attribute">position</span> relative</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1</span></span><br><span class="line">        &amp;::before</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">""</span></span><br><span class="line">            <span class="attribute">position</span>: absolute</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">            <span class="attribute">z-index</span>: -<span class="number">1</span></span><br><span class="line">            <span class="attribute">background</span>: url(xxx) no-repeat</span><br><span class="line">            <span class="attribute">transform</span>: rotate(-<span class="number">180deg</span>)</span><br></pre></td></tr></table></figure><p>可以进行任意角度旋转父元素</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><p>就防止背景超出</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>12月leetcode(链表)</title>
    <url>/2019/12/07/12%E6%9C%88leetcode(%E9%93%BE%E8%A1%A8)/</url>
    <content><![CDATA[<h1 id="12月leetcode-链表"><a href="#12月leetcode-链表" class="headerlink" title="12月leetcode(链表)"></a>12月leetcode(链表)</h1><h3 id="73-删除列表中的节点"><a href="#73-删除列表中的节点" class="headerlink" title="73 - 删除列表中的节点"></a>73 - 删除列表中的节点</h3><p>题目<br>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>解：</strong></p><blockquote><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p></blockquote><p>就是将这个节点的下一个复制到这一个</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(node, node.next)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  node.val = node.next.val</span><br><span class="line">  node.next = node.next.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>解：</strong> 因为是单链表 所以走到前一个位置就要停止 把下下个节点 挪到下一个，双指针为了考虑头节点删除这一特殊情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = head</span><br><span class="line">    <span class="comment">// 先指针探路，走到删除点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        first = first.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是空的说明 要删除的是首个节点 因为走到底了</span></span><br><span class="line">    <span class="keyword">if</span>(!first) <span class="keyword">return</span> head.next</span><br><span class="line">    <span class="keyword">let</span> second = head</span><br><span class="line">    <span class="comment">// 跟着步伐 当先指针走到底 后指针走到要删除前一个 跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(first.next) &#123;</span><br><span class="line">        first = first.next</span><br><span class="line">        second = second.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为在要删除的前一个 所以把下下个给到下个 等于把它抛弃了</span></span><br><span class="line">    second.next = second.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>12月leetcode（字符串）</title>
    <url>/2019/12/01/12%E6%9C%88leetcode%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="12月leetcode（字符串）"><a href="#12月leetcode（字符串）" class="headerlink" title="12月leetcode（字符串）"></a>12月leetcode（字符串）</h1><blockquote><p>下个小目标，12月份刷20道算法，不难，但是希望能坚持，leetcode 探索的基础算法，一直拖，之前刷了数组，现在才到字符串。看到别人半年刷了200多个+剑指 我就知道差距了，先坚持下来再说。</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>刷这些个算法 首先自己写，写不出来再看别人的源码，写出来了，学习执行时间靠前的代码，发现高手的同时也是语言高手，多向牛人学习他们的思维方式。</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>我的解:</strong></p><ul><li>先判断长度，不等于直接返回</li><li>拆成数组，然后排序，再和字符串比较</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">''</span>).sort().join() == t.split(<span class="string">''</span>).sort().join()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优解：</strong></p><p>定义一个26位的map 有遍历 往相应的槽里+1</p><p>这样就知道各个字符出现的次数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">// 创建一个26位的数组 里面都是0</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="comment">// 取这个字母的unicode -97 a 为 0</span></span><br><span class="line">o[s[i].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">p[t[i].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>]++</span><br><span class="line">&#125;</span><br><span class="line">o = o.toString()</span><br><span class="line">p = p.toString()</span><br><span class="line"><span class="comment">// 数组变字符串然后</span></span><br><span class="line"><span class="keyword">return</span> o === p</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>charCodeAt()</code> 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。</p><p><code>toString()</code> 方法返回指定对象的字符串形式。</p><p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.fill(value[, start[, end]])</span><br></pre></td></tr></table></figure><h4 id="arr-fill-参数"><a href="#arr-fill-参数" class="headerlink" title="arr.fill()参数"></a>arr.fill()参数</h4><ul><li><p><code>value</code></p><p>用来填充数组元素的值。</p></li><li><p><code>start</code> 可选</p><p>起始索引，默认值为0。</p></li><li><p><code>end</code> 可选</p><p>终止索引，默认值为 <code>this.length</code>。</p></li></ul><hr><h3 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>我的解：</strong>使用正则排除所有字母数字之外的符号，然后转小写，数组化 反转 字符串化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    x = s.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) === x</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h3><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>解：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 清除前后空白符</span></span><br><span class="line">     str = str.trim();</span><br><span class="line">     <span class="comment">// 正则，如果不是正负 数字开头 返回 0</span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="regexp">/^[+|-]?\d+/</span>.test(str)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取 字符串 转 数</span></span><br><span class="line">     <span class="keyword">let</span> val = + str.match(<span class="regexp">/^[+|-]?\d+/</span>);</span><br><span class="line">    <span class="keyword">let</span> base = <span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">     <span class="keyword">let</span> min = -base;</span><br><span class="line">     <span class="keyword">let</span> max = base<span class="number">-1</span>;</span><br><span class="line">     <span class="comment">// 判断大小边界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(val, max), min)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>简化后</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val = str.trim().match(<span class="regexp">/^[+|-]?\d+/</span>)</span><br><span class="line">    <span class="keyword">return</span> val ? <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(val, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), - (<span class="number">2</span>**<span class="number">31</span>)) : <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p>实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>我的解：</strong>看了这个题后，想了想，好像就是indexOf方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; haystack</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; needle</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haystack.indexOf(needle)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以在之前做一些判断直接返回 提升效率，我就不死磕了</p><hr><h3 id="报数"><a href="#报数" class="headerlink" title="报数"></a>报数</h3><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作 <code>&quot;one 1&quot;</code> (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>, “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> , <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p><p>注意：整数顺序将表示为一个字符串。</p><p><strong>解：</strong>正则匹配到数字， （\d）\1*表示匹配括号内相同的数字，匹配0到无数次，第一个返回匹配到相同数字的长度，第二个匹配到的字。</p><p>eg: ()()\1 匹配第一个括号 ()()\2匹配第二个括号内</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        prev = prev.replace(<span class="regexp">/(\d)\1*/g</span>, item =&gt;<span class="string">`<span class="subst">$&#123;item.length&#125;</span><span class="subst">$&#123;item[<span class="number">0</span>]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>replace()方法</strong></p><p><code>str.replace(regexp|substr, newSubStr|function)</code><br>参数<br><code>regexp (pattern)</code><br>一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。<br><code>substr (pattern)</code><br>一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。<br><code>newSubStr (replacement)</code><br>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。<br><code>function (replacement)</code><br>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。</p><hr><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>解：</strong>先判断数组长为 0 1 直接 返回</p><p>然后用第一项为比较项 如果没有在首位找到，就从末尾截取一位，直到匹配，</p><p>匹配成功 下一项匹配 返回最后还剩的截取字符串</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; strs</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr0 = strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span>(!arr0) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> len = strs.length</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[i].indexOf(arr0) !== <span class="number">0</span>)&#123;</span><br><span class="line">            arr0 = arr0.slice(<span class="number">0</span>, arr0.length<span class="number">-1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了速度比较快的代码，才发现 字符串可以用[] ，类似数组取到单个</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">''</span></span><br><span class="line">        <span class="comment">// 先取首项长度,遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 两个串从第一个开始比较 如果不相等直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>][i] !== strs[j][i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相等就加上来</span></span><br><span class="line">        a += strs[<span class="number">0</span>][i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>字符串就到此结束了，刷二遍的时候再把之前写完了的数组还有两个字符串的题补上，</p><p>下次刷链表了</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>JS双等判断</title>
    <url>/2019/12/01/JS%E5%8F%8C%E7%AD%89%E5%88%A4%E6%96%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="JS双等判断"><a href="#JS双等判断" class="headerlink" title="JS双等判断"></a>JS双等判断</h1><h3 id="双等"><a href="#双等" class="headerlink" title="双等 =="></a>双等 ==</h3><p><img src="/images/loading.png" data-original="https://pic2.zhimg.com/80/0fc2dd69d7f9d4083f347784446b7f0d_hd.png" alt="img"></p><ul><li><p>N表示ToNumber操作，即将操作数转为数字。</p></li><li><p>P表示ToPrimitive操作，即将操作数转为原始类型的值。</p><blockquote><p>toString()方法用来得到对象的一段文字描述；而valueOf()方法用来得到对象的特征值。</p></blockquote></li></ul><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>布尔值与其他类型的值作比较时，布尔值会转化为数字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="literal">false</span> -&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>字符串和数字做==运算时，需要使用ToNumber操作</p><p>当一个对象与一个非对象比较时，需要将对象转化为原始类型</p><p><strong>在运算过程中，所有类型的值都有一种向数字类型转化的趋势。</strong></p><ul><li><strong>undefined == null</strong>，结果是<strong>true</strong>。且它俩与所有其他值比较的结果都是<strong>false</strong>。</li><li><strong>String == Boolean</strong>，需要两个操作数同时转为Number。</li><li><strong>String/Boolean == Number</strong>，需要String/Boolean转为Number。</li><li><strong>Object == Primitive</strong>，需要Object转为Primitive(具体通过<strong>valueOf</strong>和<strong>toString</strong>方法)。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>总算把你JS原型搞懂了</title>
    <url>/2019/12/01/%E6%80%BB%E7%AE%97%E6%8A%8A%E4%BD%A0JS%E5%8E%9F%E5%9E%8B%E6%90%9E%E6%87%82%E4%BA%86/</url>
    <content><![CDATA[<h1 id="彻底搞明白JS原型"><a href="#彻底搞明白JS原型" class="headerlink" title="彻底搞明白JS原型"></a>彻底搞明白JS原型</h1><blockquote><p>一周考核中的JS原理题，表面checklist 实则考察Javascript原理，里面有很多题目没有理解，一个一个深挖，理解透，先把JS原型挖透</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>第一次做题的时候只做做对了四分之一，整个人对JavaScript这门语言又懵逼了。跑了三遍案例才过90分，痛定思痛一定要搞明白其中的原理。</p><p>周六便在公司专门找JS原型的文章看。发现涉及的JS其他知识点也有很多。先去了解查看prototype是什么，中途又去看new的理念，接着又是this指向。</p><p>其实这些知识点零零散散在论坛公众号都有看，但是看了似乎懂了，一知半解过几天又忘，感觉JS就像充满未知的无底洞。</p><p>用自己的语言总结一下，时不时复习应该能理解更深。</p><h3 id="new问题"><a href="#new问题" class="headerlink" title="new问题"></a>new问题</h3><p>关键字 <code>new</code> 跟着一个含参函数，用于告知浏览器我们想要创建一个对象</p><p>在调用函数前加一个 <code>new</code> ，它就会返回一个这个函数的实例化<strong>对象</strong>. 然后，就可以在这个对象上面添加一些属性 。</p><p>每次<code>new</code>都会开辟出新的一个堆。</p><ol><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象</li></ol><h3 id="Javascript各元素诞生"><a href="#Javascript各元素诞生" class="headerlink" title="Javascript各元素诞生"></a>Javascript各元素诞生</h3><p>__ proto __ 产生</p><p>当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>_proto_</code>属性。</p><p>prototype 原型</p><p><a href="https://zhuanlan.zhihu.com/p/22989691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22989691</a></p><p><img src="/images/loading.png" data-original="https://pic1.zhimg.com/v2-1b90d4ec60713acce99df0c498fff794_r.jpg" alt="preview"></p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/2/24/1691fc9305a0c6b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="proto-与prototype"><a href="#proto-与prototype" class="headerlink" title="_ proto_ 与prototype"></a>_ <em>proto_</em> 与prototype</h3><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/4/11/16a0b8d871768297?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="整体的联系"></p><p>我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是<strong>对象</strong>所独有的；② <code>prototype</code>属性是<strong>函数</strong>所独有的。但是由于JS中函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性，这点是致使我们产生困惑的很大原因之一</p><hr><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><strong>我们知道 apply() 和 call() 都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部的 this 指向）</strong>。然后，因为这两个方法会立即调用，所以为了弥补它们的缺失，还有个方法 <code>bind()</code>，它不会立即调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = &#123;</span><br><span class="line">    num: <span class="number">2</span>,</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">      &#125;).bind(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// &#125;).call(this);</span></span><br><span class="line">      <span class="comment">// &#125;).apply(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里的 this 是 fun，所以可以正确地访问 num,</span></span><br><span class="line"><span class="comment">     * 如果使用 bind()，会在点击之后打印 2；</span></span><br><span class="line"><span class="comment">     * 如果使用 call() 或者 apply()，那么在刷新网页的时候就会打印 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  fn.fun();</span><br></pre></td></tr></table></figure><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a = <span class="number">100</span>,</span><br><span class="line">    log:<span class="function"><span class="params">b</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    log2:<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.log()  <span class="comment">// 指向global</span></span><br><span class="line">obj.log2() <span class="comment">// 指向obj</span></span><br></pre></td></tr></table></figure><p>箭头函数的this与创建时的封闭词法上下文的this保持一致。</p><p><strong><code>this</code> 总是指向调用它所在方法的对象</strong></p><ul><li><strong>一般 this 指向问题，会发生在回调函数中。所以我们在写回调函数时，要注意一下 this 的指向问题。</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  birth: 1995,</span><br><span class="line">  getAge: function() &#123;</span><br><span class="line">    var b = this.birth; // 1995;</span><br><span class="line">    var fn = function() &#123;</span><br><span class="line">      return this.birth; </span><br><span class="line">    &#125;;</span><br><span class="line">    return fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getAge(); // undefined</span><br></pre></td></tr></table></figure><p><code>fn</code> 中的 <code>this</code> 指向变成 <code>undefined</code> 了。<br>因为这里重新定义了个 function,有一个新的函数上下文,</p><p>通过<code>call()</code>修正this指向</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1999</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1999</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.birth; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fn.call(obj); <span class="comment">// 通过 call()，将 obj 的 this 指向了 fn 中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge(); <span class="comment">// 1999</span></span><br></pre></td></tr></table></figure><p>也可以把上个this复值 <code>that = this</code></p><p>也可以使用箭头函数，箭头函数引用父级上下文</p><hr><h3 id="搞明白之后，可以自信解题了"><a href="#搞明白之后，可以自信解题了" class="headerlink" title="搞明白之后，可以自信解题了"></a>搞明白之后，可以自信解题了</h3><p>在网上搞了几个类似的题目</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">A.prototype.n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: <span class="number">2</span>,</span><br><span class="line">  m: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.n);</span><br><span class="line"><span class="built_in">console</span>.log(b.m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c.n);</span><br><span class="line"><span class="built_in">console</span>.log(c.m);</span><br></pre></td></tr></table></figure><p>A.prototype 函数的原型对象上增个 {n： 1}</p><p>然后c的原型对象被重新定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">undefine</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.a();</span><br><span class="line">f.b();</span><br><span class="line"></span><br><span class="line">F.a();</span><br><span class="line">F.b();</span><br></pre></td></tr></table></figure><p>对象的原型对象 为 <strong>神对象</strong> 加一个输出a的函数</p><p>函数的原型对象 <strong>机器对象</strong> 加一个输出b的函数</p><p>f为函数F的实例化对象</p><p>函数的原型对象 <strong>机器</strong> 通过原型链找到对象的原型对象 <strong>神</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">error<span class="string">`not a function`</span></span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>);</span><br></pre></td></tr></table></figure><p>问题1：1.<code>p.__proto__</code>等于什么？</p><p>p为Person的实例化对象，就是<code>Person.Prototype</code></p><p>问题2：<code>Person.__proto__</code>等于什么？</p><p>函数 对象原型 <strong>机器</strong><code>Fuction.Prototype</code></p><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;,</span><br><span class="line">    F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="string">'value a'</span>;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="string">'value b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.a);</span><br><span class="line"><span class="built_in">console</span>.log(foo.b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(F.a);</span><br><span class="line"><span class="built_in">console</span>.log(F.b)</span><br></pre></td></tr></table></figure><p>函数原型对象 <strong>机器</strong> 通过 原型链 找到对象原型对象 <strong>神</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">undefine</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><hr><p>在开始的时候，看着看着会看晕了</p><p>连续看了无数文章解析，自己敲，单步调试多次后，我仿佛打通了JS二脉，对JS原型有了自己的理解。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript原理</tag>
      </tags>
  </entry>
  <entry>
    <title>企业级web开发流程</title>
    <url>/2019/11/17/%E4%BC%81%E4%B8%9A%E7%BA%A7web%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="企业级web开发流程"><a href="#企业级web开发流程" class="headerlink" title="企业级web开发流程"></a>企业级web开发流程</h1><blockquote><p>入职一周，大致解了了企业的开发流程，我们工作室有很多借鉴的地方，比如UI设计师可以直接用sketch导出html格式的文章，前后端开发之前一定要定义好接口规范，学到了以后就避免很多返工</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h4 id="1-需求阶段"><a href="#1-需求阶段" class="headerlink" title="1. 需求阶段"></a>1. 需求阶段</h4><ul><li><p>用户/市场调研</p></li><li><p>问题分析：获取需求定义，又称软件需求规约.</p></li><li><p>需求分析：需求分析生成功能规约。</p></li><li><p>项目评估：了解开发难度，评估开发工作量，指定开大进度计划和里程碑节点。</p><p>对应岗位：产品经理</p><p>开发工具：Axure, xmind</p></li></ul><h4 id="2-设计阶段"><a href="#2-设计阶段" class="headerlink" title="2. 设计阶段"></a>2. 设计阶段</h4><ul><li><p><strong>交互设计</strong></p><p>对应岗位：交互设计师</p><p>开发工具：Axure</p></li><li><p><strong>UI设计</strong></p><p>对应岗位：UI设计师</p><p>开发工具：PS,sketch</p></li></ul><p><strong>每次定稿之前，必须前后端开发一起参与审稿，避免返工</strong></p><h4 id="3-开发阶段"><a href="#3-开发阶段" class="headerlink" title="3. 开发阶段"></a>3. 开发阶段</h4><p>开发之前，前后端务必，了解好整个软件系统结构，包括子系统、模块以及相关层次、说明每一模块的<strong>接口定义，命名规则</strong>，模块之间的调用关系等。</p><h4 id="4-测试阶段"><a href="#4-测试阶段" class="headerlink" title="4. 测试阶段"></a>4. 测试阶段</h4><ul><li>功能测试</li><li>压力测试</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发流程</category>
      </categories>
      <tags>
        <tag>开发流程</tag>
      </tags>
  </entry>
  <entry>
    <title>前端复习题</title>
    <url>/2019/11/10/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="一、CSS问题"><a href="#一、CSS问题" class="headerlink" title="一、CSS问题"></a>一、CSS问题</h3><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><blockquote><p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h4 id="2-css3的新特性"><a href="#2-css3的新特性" class="headerlink" title="2.css3的新特性"></a>2.css3的新特性</h4><blockquote><p>transtion transition-property 规定设置过渡效果的 CSS 属性的名称。</p></blockquote><blockquote><p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p></blockquote><blockquote><p>transition-timing-function 规定速度效果的速度曲线。</p></blockquote><blockquote><p>transition-delay 定义过渡效果何时开始。</p></blockquote><blockquote><p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p></blockquote><blockquote><p>ainimation实现动画效果主要由两部分组成：</p></blockquote><blockquote><p>通过类似Flash动画中的帧来声明一个动画；</p></blockquote><blockquote><p>在animation属性中调用关键帧声明的动画。</p></blockquote><blockquote><p>translate 3D建模效果</p></blockquote><h4 id="3-img中alt和title的区别"><a href="#3-img中alt和title的区别" class="headerlink" title="3.img中alt和title的区别"></a>3.img中alt和title的区别</h4><blockquote><p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化</p></blockquote><blockquote><p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p></blockquote><h4 id="4-用纯CSS创建一个三角形"><a href="#4-用纯CSS创建一个三角形" class="headerlink" title="4.用纯CSS创建一个三角形"></a>4.用纯CSS创建一个三角形</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        border-top: 40px solid transparent;</span><br><span class="line">        border-left: 40px solid transparent;</span><br><span class="line">        border-right: 40px solid transparent;</span><br><span class="line">        border-bottom: 40px solid #ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-如何理解CSS的盒子模型？"><a href="#5-如何理解CSS的盒子模型？" class="headerlink" title="5.如何理解CSS的盒子模型？"></a>5.如何理解CSS的盒子模型？</h4><blockquote><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p></blockquote><blockquote><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p></blockquote><h4 id="6-如何让一个div水平居中"><a href="#6-如何让一个div水平居中" class="headerlink" title="6.如何让一个div水平居中"></a>6.如何让一个div水平居中</h4><blockquote><p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p></blockquote><blockquote><p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p></blockquote><h4 id="7-如何让一个div水平垂直居中"><a href="#7-如何让一个div水平垂直居中" class="headerlink" title="7.如何让一个div水平垂直居中"></a>7.如何让一个div水平垂直居中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">position: relative / fixed; /* 相对定位或绝对定位均可 */</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-150px;</span><br><span class="line">margin-left:-250px;</span><br><span class="line"> 外边距为自身宽高的一半 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center; /* 垂直居中 */</span><br><span class="line">justify-content: center; /* 水平居中 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">width: 100px; /* 可省 */</span><br><span class="line">height: 100px; /* 可省 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-如何清除浮动？"><a href="#8-如何清除浮动？" class="headerlink" title="8.如何清除浮动？"></a>8.如何清除浮动？</h4><blockquote><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}</p></blockquote><blockquote><p>给浮动元素父级设置高度</p></blockquote><blockquote><p>父级同时浮动（需要给父级同级元素添加浮动）</p></blockquote><blockquote><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></blockquote><blockquote><p>给父级添加overflow:hidden 清除浮动方法</p></blockquote><blockquote><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float_div:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">clear:both;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">zoom:1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-css3实现三栏布局，左右固定，中间自适应"><a href="#9-css3实现三栏布局，左右固定，中间自适应" class="headerlink" title="9.css3实现三栏布局，左右固定，中间自适应"></a>9.css3实现三栏布局，左右固定，中间自适应</h4><blockquote><p>圣杯布局/双飞翼布局</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            min-height: 130px;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding: 0 220px 0 200px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: -220px;</span><br><span class="line">            right: -220px;</span><br><span class="line">            width: 220px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            background: blue;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;container&apos;&gt;</span><br><span class="line">        &lt;div class=&apos;middle&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;left&apos;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&apos;right&apos;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-display-none-和-visibility-hidden的区别"><a href="#10-display-none-和-visibility-hidden的区别" class="headerlink" title="10.display:none 和 visibility: hidden的区别"></a>10.display:none 和 visibility: hidden的区别</h4><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p></blockquote><blockquote><p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h4 id="11-CSS中-link-和-import-的区别是？"><a href="#11-CSS中-link-和-import-的区别是？" class="headerlink" title="11.CSS中 link 和@import 的区别是？"></a>11.CSS中 link 和@import 的区别是？</h4><blockquote><p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p></blockquote><blockquote><p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p></blockquote><blockquote><p>link方式的样式的权重 高于@import的权重.</p></blockquote><h4 id="12-position的absolute与fixed共同点与不同点"><a href="#12-position的absolute与fixed共同点与不同点" class="headerlink" title="12.position的absolute与fixed共同点与不同点"></a>12.position的absolute与fixed共同点与不同点</h4><blockquote><p>共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上</p></blockquote><blockquote><p>不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p></blockquote><h4 id="13-transition和animation的区别"><a href="#13-transition和animation的区别" class="headerlink" title="13..transition和animation的区别"></a>13..transition和animation的区别</h4><blockquote><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p></blockquote><blockquote><p>transition 规定动画的名字 规定完成过渡效果需要多少秒或毫秒 规定速度效果 定义过渡效果何时开始 animation 指定要绑定到选择器的关键帧的名称</p></blockquote><h4 id="14-CSS优先级"><a href="#14-CSS优先级" class="headerlink" title="14.CSS优先级"></a>14.CSS优先级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">	1.属性后面加!import 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">	2.作为style属性写在元素内的样式</span><br><span class="line">	3.id选择器</span><br><span class="line">	4.类选择器</span><br><span class="line">	5.标签选择器</span><br><span class="line">	6.通配符选择器（*）</span><br><span class="line">	7.浏览器自定义或继承</span><br><span class="line">**同一级别：后写的会覆盖先写的**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p></blockquote><h4 id="15-雪碧图："><a href="#15-雪碧图：" class="headerlink" title="15.雪碧图："></a>15.雪碧图：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        多个图片集成在一个图片中的图</span><br><span class="line">	使用雪碧图可以减少网络请求的次数，加快允许的速度</span><br><span class="line">	通过background-position，去定位图片在屏幕的哪个位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="二、JS问题"><a href="#二、JS问题" class="headerlink" title="二、JS问题"></a>二、JS问题</h1><h4 id="1-typeof和instance-of-检测数据类型有什么区别？"><a href="#1-typeof和instance-of-检测数据类型有什么区别？" class="headerlink" title="1.typeof和instance of 检测数据类型有什么区别？"></a>1.typeof和instance of 检测数据类型有什么区别？</h4><blockquote><p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p></blockquote><blockquote><p>不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.</p></blockquote><h4 id="16-使元素消失的方法"><a href="#16-使元素消失的方法" class="headerlink" title="16.使元素消失的方法"></a>16.使元素消失的方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visibility:hidden、display:none、z-index=-1、opacity：0</span><br><span class="line">1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</span><br><span class="line">2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span><br><span class="line">3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="谈一谈深克隆和浅克隆？"><a href="#谈一谈深克隆和浅克隆？" class="headerlink" title=".谈一谈深克隆和浅克隆？"></a>.谈一谈深克隆和浅克隆？</h4><blockquote><p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p></blockquote><blockquote><p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p></blockquote><h4 id="3-es6的新特性都有哪些？"><a href="#3-es6的新特性都有哪些？" class="headerlink" title="3.es6的新特性都有哪些？"></a>3.es6的新特性都有哪些？</h4><blockquote><p>let定义块级作用域变量 没有变量的提升，必须先声明后使用 let声明的变量，不能与前面的let，var，conset声明的变量重名</p></blockquote><blockquote><p>const 定义只读变量 const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改 const声明变量也是一个块级作用域变量 const声明的变量没有“变量的提升”，必须先声明后使用 const声明的变量不能与前面的let， var ， const声明的变量重 const定义的对象\数组中的属性值可以修改,基础数据类型不可以</p></blockquote><blockquote><p>ES6可以给形参函数设置默认值</p></blockquote><blockquote><p>在数组之前加上三个点（…）展开运算符</p></blockquote><blockquote><p>数组的解构赋值、对象的解构赋值</p></blockquote><blockquote><p>箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被new 箭头函数没有arguments实参集合,取而代之用…剩余运算符解决 箭头函数没有自己的this。他的this是继承当前上下文中的this 箭头函数没有函数原型 箭头函数不能当做Generator函数，不能使用yield关键字 不能使用call、apply、bind改变箭头函数中this指向 Set数据结构，数组去重</p></blockquote><h4 id="4-和-区别是什么？"><a href="#4-和-区别是什么？" class="headerlink" title="4.==和===区别是什么？"></a>4.==和===区别是什么？</h4><blockquote><p>=赋值</p></blockquote><blockquote><p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p></blockquote><blockquote><p>=== 只要数据类型不一样，就返回false；</p></blockquote><h4 id="5-常见的设计模式有哪些？"><a href="#5-常见的设计模式有哪些？" class="headerlink" title="5.常见的设计模式有哪些？"></a>5.常见的设计模式有哪些？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、js工厂模式</span><br><span class="line">2、js构造函数模式</span><br><span class="line">3、js原型模式</span><br><span class="line">4、构造函数+原型的js混合模式</span><br><span class="line">5、构造函数+原型的动态原型模式</span><br><span class="line">6、观察者模式</span><br><span class="line">7、发布订阅模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-call-bind-apply-的区别？"><a href="#6-call-bind-apply-的区别？" class="headerlink" title="6.call bind apply 的区别？"></a>6.call bind apply 的区别？</h4><blockquote><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p></blockquote><blockquote><p>call()和apply()的区别就在于，两者之间的参数。</p></blockquote><blockquote><p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p></blockquote><blockquote><p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。</p></blockquote><h4 id="7-js继承方式有哪些？"><a href="#7-js继承方式有哪些？" class="headerlink" title="7.js继承方式有哪些？"></a>7.js继承方式有哪些？</h4><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点</p></blockquote><h4 id="8-你怎样看待闭包？"><a href="#8-你怎样看待闭包？" class="headerlink" title="8.你怎样看待闭包？"></a>8.你怎样看待闭包？</h4><blockquote><p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p></blockquote><h4 id="9-你是如何理解原型和原型链的？"><a href="#9-你是如何理解原型和原型链的？" class="headerlink" title="9.你是如何理解原型和原型链的？"></a>9.你是如何理解原型和原型链的？</h4><blockquote><p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 <strong>proto</strong>存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过<strong>proto</strong>向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p></blockquote><h4 id="10-浏览器渲染的主要流程是什么"><a href="#10-浏览器渲染的主要流程是什么" class="headerlink" title="10.浏览器渲染的主要流程是什么?"></a>10.浏览器渲染的主要流程是什么?</h4><blockquote><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p></blockquote><h4 id="11-从输入url地址到页面相应都发生了什么？"><a href="#11-从输入url地址到页面相应都发生了什么？" class="headerlink" title="11.从输入url地址到页面相应都发生了什么？"></a>11.从输入url地址到页面相应都发生了什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、浏览器的地址栏输入URL并按下回车。</span><br><span class="line">2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。</span><br><span class="line">4、根据IP建立TCP连接（三次握手）。</span><br><span class="line">5、HTTP发起请求。</span><br><span class="line">6、服务器处理请求，浏览器接收HTTP响应。</span><br><span class="line">7、渲染页面，构建DOM树。</span><br><span class="line">8、关闭TCP连接（四次挥手）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-session、cookie、localStorage的区别"><a href="#12-session、cookie、localStorage的区别" class="headerlink" title="12.session、cookie、localStorage的区别"></a>12.session、cookie、localStorage的区别</h4><blockquote><p>相同点 都是保存在浏览器端，且同源的。</p></blockquote><blockquote><p>不同点</p></blockquote><ul><li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li><li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul><h4 id="13-js中跨域方法"><a href="#13-js中跨域方法" class="headerlink" title="13.js中跨域方法"></a>13.js中跨域方法</h4><blockquote><p>同源策略（协议+端口号+域名要相同）</p></blockquote><blockquote><p>1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p><blockquote><p>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据</p></blockquote></blockquote><blockquote><p>2、document.domain 基础域名相同 子域名不同</p></blockquote><blockquote><p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></blockquote><blockquote><p>4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><blockquote><p>5、利用h5新特性window.postMessage()</p></blockquote><h4 id="14-前端有哪些页面优化方法"><a href="#14-前端有哪些页面优化方法" class="headerlink" title="14.前端有哪些页面优化方法?"></a>14.前端有哪些页面优化方法?</h4><ul><li>减少 HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置 HTTP缓存</li><li>资源合并与压缩</li><li>合并 CSS图片，减少请求数的又一个好办法。</li><li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li><li>多图片网页使用图片懒加载。</li><li>在js中尽量减少闭包的使用</li><li>尽量合并css和js文件</li><li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li><li>减少对DOM的操作</li><li>在JS中避免“嵌套循环”和 “死循环”</li><li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul><h4 id="15-Ajax的四个步骤"><a href="#15-Ajax的四个步骤" class="headerlink" title="15.Ajax的四个步骤"></a>15.Ajax的四个步骤</h4><blockquote><p>1.创建ajax实例</p></blockquote><blockquote><p>2.执行open 确定要访问的链接 以及同步异步</p></blockquote><blockquote><p>3.监听请求状态</p></blockquote><blockquote><p>4.发送请求</p></blockquote><h4 id="16-数组去重的方法"><a href="#16-数组去重的方法" class="headerlink" title="16.数组去重的方法"></a>16.数组去重的方法</h4><blockquote><p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    var arr2 = arr.sort();</span><br><span class="line">    var res = [arr2[0]];</span><br><span class="line">    for(var i=1;i&lt;arr2.length;i++)&#123;</span><br><span class="line">        if(arr2[i] !== res[res.length-1])&#123;</span><br><span class="line">        res.push(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">利用下标查询</span><br><span class="line"> function unique(arr)&#123;</span><br><span class="line">    var newArr = [arr[0]];</span><br><span class="line">    for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(newArr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return newArr;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="17-ajax中get和post请求的区别"><a href="#17-ajax中get和post请求的区别" class="headerlink" title="17.ajax中get和post请求的区别"></a>17.ajax中get和post请求的区别</h4><ul><li>get 一般用于获取数据</li><li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li><li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li><li>get安全性较低</li><li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li><li>post 一般用于发送数据</li><li>post传递参数，需要把参数放进请求体中，发送给服务器；</li><li>post请求参数放进了请求体中，对大小没有要求；</li><li>post安全性比较高；</li><li>post请求不会走缓存；</li><li></li></ul><h4 id="18-ajax的状态码"><a href="#18-ajax的状态码" class="headerlink" title="18.ajax的状态码"></a>18.ajax的状态码</h4><blockquote><p>2开头</p></blockquote><ul><li>200 : 代表请求成功；</li></ul><blockquote><p>3开头</p></blockquote><ul><li>301 : 永久重定向；</li><li>302: 临时转移</li><li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li><li>307:临时重定向</li></ul><blockquote><p>以4开头的都是客户端的问题；</p></blockquote><ul><li>400 :数据/格式错误</li><li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li><li>404 : 路径错误，找不到文件</li></ul><blockquote><p>以5开头都是服务端的问题</p></blockquote><ul><li>500 : 服务器的问题</li><li>503: 超负荷；</li></ul><h4 id="19-移动端的兼容问题"><a href="#19-移动端的兼容问题" class="headerlink" title="19.移动端的兼容问题"></a>19.移动端的兼容问题</h4><ul><li><p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend</p></li><li><p>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}</p></li><li><p>设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p></li><li><p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p></li><li><p>设置用户截止缩放，一般写视口的时候就已经写好了。</p></li><li></li></ul><h4 id="20-JS中同步和异步-以及js的事件流"><a href="#20-JS中同步和异步-以及js的事件流" class="headerlink" title="20.JS中同步和异步,以及js的事件流"></a>20.JS中同步和异步,以及js的事件流</h4><blockquote><p>同步：在同一时间内做一件事情</p></blockquote><blockquote><p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p></blockquote><h4 id="21-JS中常见的异步任务"><a href="#21-JS中常见的异步任务" class="headerlink" title="21.JS中常见的异步任务"></a>21.JS中常见的异步任务</h4><blockquote><p>定时器、ajax、事件绑定、回调函数、async await、promise</p></blockquote><h4 id="22-TCP的三次握手和四次挥手"><a href="#22-TCP的三次握手和四次挥手" class="headerlink" title="22.TCP的三次握手和四次挥手"></a>22.TCP的三次握手和四次挥手</h4><blockquote><p>三次握手</p></blockquote><ul><li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li><li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li><li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li></ul><blockquote><p>四次挥手</p></blockquote><ul><li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li><li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li><li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li><li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><h4 id="23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="23.为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4><blockquote><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote></blockquote><h4 id="24-DOM-diff原理"><a href="#24-DOM-diff原理" class="headerlink" title="24.DOM diff原理"></a>24.DOM diff原理</h4><blockquote><ul><li>如果元素类型发生变化，直接替换</li><li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li></ul></blockquote><h4 id="25-作用域"><a href="#25-作用域" class="headerlink" title="25.作用域"></a>25.作用域</h4><blockquote><p>全局作用域</p></blockquote><ul><li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li></ul><blockquote><p>私有作用域</p></blockquote><ul><li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li></ul><blockquote><p>块级作用域</p></blockquote><ul><li>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</li></ul><blockquote><p>上级作用域</p></blockquote><ul><li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li></ul><h4 id="26-Promise处理异步"><a href="#26-Promise处理异步" class="headerlink" title="26.Promise处理异步"></a>26.Promise处理异步</h4><blockquote><p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p></blockquote><h4 id="27-map和forEach的区别"><a href="#27-map和forEach的区别" class="headerlink" title="27.map和forEach的区别"></a>27.map和forEach的区别</h4><blockquote><p>相同点</p></blockquote><ul><li>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</li></ul><blockquote><p>不同点</p></blockquote><ul><li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li></ul><blockquote><blockquote><p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p></blockquote></blockquote><h4 id="28-async-await函数"><a href="#28-async-await函数" class="headerlink" title="28.async await函数"></a>28.async await函数</h4><blockquote><p>async/await函数是异步代码的新方式</p></blockquote><blockquote><p>async/await是基于promise实现的</p></blockquote><blockquote><p>async/await使异步代码更像同步代码</p></blockquote><blockquote><p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p></blockquote><blockquote><p>默认返回一个promise实例，不能被改变</p></blockquote><blockquote><p>await下面的代码是异步，后面的代码是同步的</p></blockquote><h4 id="29-this指向"><a href="#29-this指向" class="headerlink" title="29.this指向"></a>29.this指向</h4><blockquote><ul><li>全局作用域下的this指向window</li><li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li><li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li><li>自执行函数中的this永远指向window</li><li>定时器中函数的this指向window</li><li>构造函数中的this指向当前的实例</li><li>call、apply、bind可以改变函数的this指向</li><li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li></ul></blockquote><h4 id="30-原型"><a href="#30-原型" class="headerlink" title="30.原型"></a>30.原型</h4><blockquote><blockquote><p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p></blockquote></blockquote><h4 id="31-异步回调（如何解决回调地狱）"><a href="#31-异步回调（如何解决回调地狱）" class="headerlink" title="31.异步回调（如何解决回调地狱）"></a>31.异步回调（如何解决回调地狱）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise、generator、async/await</span><br><span class="line"></span><br><span class="line">promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理</span><br><span class="line">	  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱</span><br><span class="line">	  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）</span><br><span class="line">	  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败</span><br><span class="line">		promise.all() 里面状态都改变，那就会输出，得到一个数组</span><br><span class="line">		promise.race() 里面只有一个状态变为rejected或者fulfilled即输出</span><br><span class="line">		promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="32-前端事件流"><a href="#32-前端事件流" class="headerlink" title="32.前端事件流"></a>32.前端事件流</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</span><br><span class="line">  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。</span><br><span class="line">      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。</span><br><span class="line">      3、冒泡阶段：事件又传播回文档</span><br><span class="line">   阻止冒泡事件event.stopPropagation()</span><br><span class="line">	  function stopBubble(e) &#123;</span><br><span class="line">    		if (e &amp;&amp; e.stopPropagation) &#123; // 如果提供了事件对象event 这说明不是IE浏览器</span><br><span class="line">      		e.stopPropagation()</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">      		window.event.cancelBubble = true //IE方式阻止冒泡</span><br><span class="line">    	      &#125;</span><br><span class="line">  		   &#125;</span><br><span class="line">   阻止默认行为event.preventDefault()</span><br><span class="line"> function stopDefault(e) &#123;</span><br><span class="line">    if (e &amp;&amp; e.preventDefault) &#123;</span><br><span class="line">      e.preventDefault()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // IE浏览器阻止函数器默认动作的行为</span><br><span class="line">      window.event.returnValue = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="33-事件如何先捕获后冒泡？"><a href="#33-事件如何先捕获后冒泡？" class="headerlink" title="33.事件如何先捕获后冒泡？"></a>33.事件如何先捕获后冒泡？</h4><blockquote><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></blockquote><ul><li>哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI事件：scroll resize</li></ul><h4 id="34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><a href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。" class="headerlink" title="34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。"></a>34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</p></blockquote><blockquote><p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p></blockquote><blockquote><p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p></blockquote><blockquote><p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p></blockquote><blockquote><p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p></blockquote><h4 id="35-setTimeout-和-setInterval的机制"><a href="#35-setTimeout-和-setInterval的机制" class="headerlink" title="35.setTimeout 和 setInterval的机制"></a>35.setTimeout 和 setInterval的机制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的</span><br><span class="line">待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="36-splice和slice、map和forEach、-filter-、reduce-的区别"><a href="#36-splice和slice、map和forEach、-filter-、reduce-的区别" class="headerlink" title="36.splice和slice、map和forEach、 filter()、reduce()的区别"></a>36.splice和slice、map和forEach、 filter()、reduce()的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，</span><br><span class="line"> 包含从start到end（不包含该元素）的数组方法</span><br><span class="line">	注意：该方法不会更新原数组，而是返回一个子数组</span><br><span class="line"> 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）</span><br><span class="line">	splice(index, howmany,item1,...itemx)</span><br><span class="line">		·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置</span><br><span class="line">		·howmany参数：必须，要删除的数量，</span><br><span class="line">		·item1..itemx:可选，向数组添加新项目</span><br><span class="line">3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据</span><br><span class="line">4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素</span><br><span class="line">5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值</span><br><span class="line">6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理	</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="VUE问题"><a href="#VUE问题" class="headerlink" title="VUE问题"></a>VUE问题</h1><h4 id="1-聊聊对vue的理解"><a href="#1-聊聊对vue的理解" class="headerlink" title="1.聊聊对vue的理解"></a>1.聊聊对vue的理解</h4><blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote><h4 id="2-V-model的原理是什么？"><a href="#2-V-model的原理是什么？" class="headerlink" title="2.V-model的原理是什么？"></a>2.V-model的原理是什么？</h4><blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p><ul><li>原理 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote><h4 id="3-谈谈对生命周期的理解"><a href="#3-谈谈对生命周期的理解" class="headerlink" title="3.谈谈对生命周期的理解"></a>3.谈谈对生命周期的理解</h4><ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li><li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li><li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li><li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li><li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li><li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li><li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li><li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul><h4 id="4-VUE和REACT有什么区别？"><a href="#4-VUE和REACT有什么区别？" class="headerlink" title="4.VUE和REACT有什么区别？"></a>4.VUE和REACT有什么区别？</h4><blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote><blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote><h4 id="5-vuex的流程"><a href="#5-vuex的流程" class="headerlink" title="5.vuex的流程"></a>5.vuex的流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。</span><br><span class="line">mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中</span><br><span class="line">通过mapGetter来动态获取state中的值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-vuex有哪几种状态和属性"><a href="#6-vuex有哪几种状态和属性" class="headerlink" title="6.vuex有哪几种状态和属性"></a>6.vuex有哪几种状态和属性</h4><blockquote><ul><li>state中保存着共有数据，数据是响应式的</li><li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li><li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li><li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li><li>modules：模块化vuex</li></ul></blockquote><h4 id="7-vue路由的两种模式"><a href="#7-vue路由的两种模式" class="headerlink" title="7.vue路由的两种模式"></a>7.vue路由的两种模式</h4><blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul><p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote><h4 id="8-vue中-key-值的作用"><a href="#8-vue中-key-值的作用" class="headerlink" title="8.vue中 key 值的作用"></a>8.vue中 key 值的作用</h4><blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote><blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote><h4 id="9-route和-router的区别"><a href="#9-route和-router的区别" class="headerlink" title="9$route和$router的区别"></a>9<code>$route</code>和<code>$router</code>的区别</h4><blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li><li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote><h4 id="10-vue-router守卫"><a href="#10-vue-router守卫" class="headerlink" title="10.vue-router守卫"></a>10.vue-router守卫</h4><blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote><ul><li>to: Route: 即将要进入的目标（路由对象）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.js 入口文件</span><br><span class="line">    import router from &apos;./router&apos;; // 引入路由</span><br><span class="line">    router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">    router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">      console.log(&apos;afterEach 全局后置钩子&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">    // 比如还未保存草稿，或者在用户离开前，</span><br><span class="line">    将setInterval销毁，防止离开之后，定时器还在调用。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="11.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><blockquote><p>请求后台资源的模块。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install axios -S装好</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote><h4 id="12-vue修饰符"><a href="#12-vue修饰符" class="headerlink" title="12.vue修饰符"></a>12.vue修饰符</h4><ul><li>stop：阻止事件的冒泡</li><li>prevent：阻止事件的默认行为</li><li>once：只触发一次</li><li>self：只触发自己的事件行为时，才会执行</li></ul><h4 id="13-vue项目中的性能优化"><a href="#13-vue项目中的性能优化" class="headerlink" title="13.vue项目中的性能优化"></a>13.vue项目中的性能优化</h4><blockquote><p>1.不要在模板里面写过多表达式</p></blockquote><blockquote><p>2.循环调用子组件时添加key</p></blockquote><blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote><blockquote><p>4.尽量少用float，可以用flex</p></blockquote><blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote><blockquote><p>6.路由懒加载</p></blockquote><h4 id="14-vue-extend和vue-component"><a href="#14-vue-extend和vue-component" class="headerlink" title="14.vue.extend和vue.component"></a>14.vue.extend和vue.component</h4><blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote><h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><blockquote><p>png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.</p></blockquote><blockquote><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></blockquote><blockquote><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p></blockquote><h1 id="React问题"><a href="#React问题" class="headerlink" title="React问题"></a>React问题</h1><h4 id="1-react和vue的区别"><a href="#1-react和vue的区别" class="headerlink" title="1.react和vue的区别"></a>1.react和vue的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   =&gt;  相同点：</span><br><span class="line">	1.数据驱动页面，提供响应式的试图组件</span><br><span class="line">	2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范</span><br><span class="line">	3.数据流动单向，都支持服务器的渲染SSR</span><br><span class="line">	4.都有支持native的方法，react有React native， vue有wexx</span><br><span class="line">=&gt;  不同点：</span><br><span class="line">	1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的</span><br><span class="line">	2.数据渲染：大规模的数据渲染，react更快</span><br><span class="line">	3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目</span><br><span class="line">	4.开发风格：react推荐做法jsx + inline style把html和css都写在js了</span><br><span class="line">		    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-redux中的reducer（纯函数）"><a href="#2-redux中的reducer（纯函数）" class="headerlink" title="2.redux中的reducer（纯函数）"></a>2.redux中的reducer（纯函数）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）</span><br><span class="line">更新state(这个state可以理解为上下累加器的结果）</span><br><span class="line">每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是&apos;自身消减&apos;(reduce),</span><br><span class="line">进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3-react的refs"><a href="#3-react的refs" class="headerlink" title="3.react的refs"></a>3.react的refs</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，</span><br><span class="line">它将接受地城dom元素或组件的已挂在实例，作为第一个参数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-react中的keys"><a href="#4-react中的keys" class="headerlink" title="4.react中的keys"></a>4.react中的keys</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5.React的生命周期"></a>5.React的生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三个状态：Mounting(已插入真实的DOM）</span><br><span class="line">	  Updating(正在被重新渲染)</span><br><span class="line">	  Unmounting(已移除真实的DOM)</span><br><span class="line">componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，</span><br><span class="line">componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-React子组件向父组件传值"><a href="#6-React子组件向父组件传值" class="headerlink" title="6.React子组件向父组件传值"></a>6.React子组件向父组件传值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><a href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…" class="headerlink" title="7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…"></a>7.为什么虚拟DOM会提高性能 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">www.zhihu.com/question/29…</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能</span><br><span class="line">具体实现步骤：</span><br><span class="line">	·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中</span><br><span class="line">        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异</span><br><span class="line">	·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8.diff算法"></a>8.diff算法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记</span><br><span class="line">3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面</span><br><span class="line">Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用</span><br><span class="line">react只会匹配相同的class的component（这里的class指的是组件的名字）</span><br><span class="line">合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制</span><br><span class="line">4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-简述下flux的思想"><a href="#9-简述下flux的思想" class="headerlink" title="9.简述下flux的思想"></a>9.简述下flux的思想</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flux的最大特点，就是数据的‘单向流动’</span><br><span class="line">1.用户访问View</span><br><span class="line">2.View发出用户的Action</span><br><span class="line">3.Dispatcher收到Action,要求state进行相应的更新</span><br><span class="line">4.store更新后，发出一个‘change’事件后，更新页面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-reac性能优化是哪个周期函"><a href="#10-reac性能优化是哪个周期函" class="headerlink" title="10.reac性能优化是哪个周期函"></a>10.reac性能优化是哪个周期函</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，</span><br><span class="line">如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="11-react怎么划分业务组件和技术组件"><a href="#11-react怎么划分业务组件和技术组件" class="headerlink" title="11.react怎么划分业务组件和技术组件"></a>11.react怎么划分业务组件和技术组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据组件的职责通常把组件分为UI组件和容器组件</span><br><span class="line">UI组件负责UI的呈现，容器组件负责管理数据和逻辑</span><br><span class="line">两者通过React-redux提供connect方法联系起来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="12-setState"><a href="#12-setState" class="headerlink" title="12.setState"></a>12.setState</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列</span><br><span class="line">而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值	</span><br><span class="line">那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</span><br><span class="line"></span><br><span class="line">同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state</span><br><span class="line"></span><br><span class="line">同步更新state:</span><br><span class="line">	setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。</span><br><span class="line">	第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行</span><br><span class="line">	也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步</span><br><span class="line"></span><br><span class="line">例子：componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">	fetch(&apos;https://test.com&apos;)</span><br><span class="line">    </span><br><span class="line">	.then((res) =&gt; res.json())</span><br><span class="line">    </span><br><span class="line">	.then(</span><br><span class="line">    (data) =&gt; &#123;</span><br><span class="line">this.setState(&#123; data:data &#125;);</span><br><span class="line">			StatusBar.setNetworkActivityIndicatorVisible(false);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h4 id="一、webpack打包文件体积过大？（最终打包为一个js文件）"><a href="#一、webpack打包文件体积过大？（最终打包为一个js文件）" class="headerlink" title="一、webpack打包文件体积过大？（最终打包为一个js文件）"></a>一、webpack打包文件体积过大？（最终打包为一个js文件）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.异步加载模块</span><br><span class="line">2.提取第三库</span><br><span class="line">3.代码压缩</span><br><span class="line">4.去除不必要的插件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、如何优化webpack构建的性能"><a href="#二、如何优化webpack构建的性能" class="headerlink" title="二、如何优化webpack构建的性能"></a>二、如何优化webpack构建的性能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积</span><br><span class="line">		 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理</span><br><span class="line">		 3.对一些组件库采用按需加载，避免无用的代码</span><br><span class="line">二、减少目录检索范围</span><br><span class="line">		 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度</span><br><span class="line">	</span><br><span class="line">三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、移动端的性能优化"><a href="#三、移动端的性能优化" class="headerlink" title="三、移动端的性能优化"></a>三、移动端的性能优化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1、首屏加载和按需加载，懒加载</span><br><span class="line">  2、资源预加载</span><br><span class="line">  3、图片压缩处理，使用base64内嵌图片</span><br><span class="line">  4、合理缓存dom对象</span><br><span class="line">  5、使用touchstart代替click（click 300毫秒的延迟）</span><br><span class="line">  6、利用transform:translateZ(0)，开启硬件GUP加速</span><br><span class="line">  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明</span><br><span class="line">  8、使用viewport固定屏幕渲染，加速页面渲染内容</span><br><span class="line">  9、尽量使用事件代理，避免直接事件绑定</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、Vue的SPA-如何优化加载速度"><a href="#四、Vue的SPA-如何优化加载速度" class="headerlink" title="四、Vue的SPA 如何优化加载速度"></a>四、Vue的SPA 如何优化加载速度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.减少入口文件体积</span><br><span class="line">2.静态资源本地缓存</span><br><span class="line">3.开启Gzip压缩</span><br><span class="line">4.使用SSR,nuxt.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、移动端300ms延迟"><a href="#五、移动端300ms延迟" class="headerlink" title="五、移动端300ms延迟"></a>五、移动端300ms延迟</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由来：</span><br><span class="line">300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，</span><br><span class="line">当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作</span><br><span class="line">因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕</span><br><span class="line">       </span><br><span class="line">解决方案：1.禁用缩放，设置meta标签 user-scalable=no</span><br><span class="line">	  2.fastclick.js</span><br><span class="line">		原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即</span><br><span class="line">		      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉</span><br><span class="line">fastclick.js还可以解决穿透问题</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、页面的重构；"><a href="#六、页面的重构；" class="headerlink" title="六、页面的重构；"></a>六、页面的重构；</h4><blockquote><p>在不改变外部行为的前提下，简化结构、添加可读性</p></blockquote><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h4 id="一、状态码："><a href="#一、状态码：" class="headerlink" title="一、状态码："></a>一、状态码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2XX（成功处理了请求状态）</span><br><span class="line">      200 服务器已经成功处理请求，并提供了请求的网页</span><br><span class="line">      201 用户新建或修改数据成功</span><br><span class="line">      202 一个请求已经进入后台</span><br><span class="line">      204 用户删除成功</span><br><span class="line">  3XX（每次请求使用的重定向不要超过5次）</span><br><span class="line">      304 网页上次请求没有更新，节省带宽和开销</span><br><span class="line">  4XX（表示请求可能出错，妨碍了服务器的处理）</span><br><span class="line">      400 服务器不理解请求的语法</span><br><span class="line">      401 用户没有权限（用户名，密码输入错误）</span><br><span class="line">      403 用户得到授权（401相反），但是访问被禁止</span><br><span class="line">      404 服务器找不到请求的网页，</span><br><span class="line">  5XX（表示服务器在处理请求的时候发生内部错误）</span><br><span class="line">      500 服务器遇到错误，无法完成请求</span><br><span class="line">      503 服务器目前无法使用（超载或停机维护）     </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><a href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销" class="headerlink" title="二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销"></a>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）</span><br><span class="line">2.304是	HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件</span><br><span class="line">3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A</span><br><span class="line">	并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304</span><br><span class="line"></span><br><span class="line">last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间</span><br><span class="line">		客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，</span><br><span class="line">		询问该事件之后文件是否被修改，没修改返回304</span><br><span class="line"></span><br><span class="line"> 有了Last-Modified，为什么还要用ETag？</span><br><span class="line">  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）</span><br><span class="line">  2、某些服务器不能精确的得到文件的最后修改时间</span><br><span class="line">  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get</span><br><span class="line"></span><br><span class="line">ETag，为什么还要用Last-Modified？</span><br><span class="line">  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改</span><br><span class="line">  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）</span><br><span class="line">  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三、get-post的区别"><a href="#三、get-post的区别" class="headerlink" title="三、get/post的区别"></a>三、get/post的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中</span><br><span class="line">2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制</span><br><span class="line">3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值</span><br><span class="line">4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="四、http协议的理解"><a href="#四、http协议的理解" class="headerlink" title="四、http协议的理解"></a>四、http协议的理解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议</span><br><span class="line">2.基于TCP/IP通信协议来传递数据（HTML，图片资源）</span><br><span class="line">3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统</span><br><span class="line">4.http请求信息request：</span><br><span class="line">	请求行（request line）、请求头部（header）,空行和请求数据四部分构成</span><br><span class="line"></span><br><span class="line">	请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</span><br><span class="line">	请求头部，用来说明服务器要使用的附加信息</span><br><span class="line">	空行，请求头部后面的空行是必须的</span><br><span class="line">	请求数据也叫主体，可以添加任意的其他数据。</span><br><span class="line">5.http相应信息Response</span><br><span class="line">	状态行、消息报头、空行和响应正文</span><br><span class="line"></span><br><span class="line">	状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成</span><br><span class="line">	消息报头，用来说明客户端要使用的一些附加信息</span><br><span class="line">	空行，消息报头后面的空行是必须的</span><br><span class="line">	响应正文，服务器返回给客户端的文本信息。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、http和https"><a href="#五、http和https" class="headerlink" title="五、http和https"></a>五、http和https</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密</span><br><span class="line">http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、http1-0-1-1-2-0的区别"><a href="#六、http1-0-1-1-2-0的区别" class="headerlink" title="六、http1.0 1.1 2.0的区别"></a>六、http1.0 1.1 2.0的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class="line">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class="line">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class="line"></span><br><span class="line">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class="line">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class="line">3.多路复用：一个连接可以并发处理多个请求</span><br><span class="line">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、web缓存"><a href="#七、web缓存" class="headerlink" title="七、web缓存"></a>七、web缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本</span><br><span class="line">2.缓存的好处</span><br><span class="line">        （1）减少不必要的请求</span><br><span class="line">    （2）降低服务器的压力，减少服务器的消耗</span><br><span class="line">    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="八、常见的web安全及防护原理"><a href="#八、常见的web安全及防护原理" class="headerlink" title="八、常见的web安全及防护原理"></a>八、常见的web安全及防护原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，</span><br><span class="line">            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，</span><br><span class="line">            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。</span><br><span class="line">		防范：1.对用户输入进行校验</span><br><span class="line">		       2.不适用动态拼接sql</span><br><span class="line">2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。</span><br><span class="line">		        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息</span><br><span class="line">			防范：1.尽量采用post而不使用get提交表单</span><br><span class="line">			      2.避免cookie中泄漏用户的隐式</span><br><span class="line">3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求</span><br><span class="line">			举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据</span><br><span class="line">			防范：在客服端页面增加伪随机数，通过验证码</span><br><span class="line">XSS和CSRF的区别：</span><br><span class="line">   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包</span><br><span class="line">   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="九、CDN（内容分发网络）"><a href="#九、CDN（内容分发网络）" class="headerlink" title="九、CDN（内容分发网络）"></a>九、CDN（内容分发网络）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。</span><br><span class="line">2.关键技术：内容存储和分发技术中</span><br><span class="line">3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术</span><br><span class="line">	    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><a href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）" class="headerlink" title="十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）"></a>十、TCP三次握手 (客服端和服务器端都需要确认各自可收发）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。</span><br><span class="line">第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段</span><br><span class="line">第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段</span><br><span class="line">第三次握手： 服务器端确认客服端收到了自己发送的报文段</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><a href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…" class="headerlink" title="十一、从输入url到获取页面的完整过程  blog.csdn.net/samjustin1/…"></a>十一、从输入url到获取页面的完整过程 <a href="https://blog.csdn.net/samjustin1/article/details/52650520" target="_blank" rel="noopener">blog.csdn.net/samjustin1/…</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存</span><br><span class="line">2.浏览器与服务器建立tcp链接（三次握手）</span><br><span class="line">3.浏览器向服务器发送http请求(请求和传输数据）</span><br><span class="line">4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器</span><br><span class="line">5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤</span><br><span class="line">6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><a href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print" class="headerlink" title="十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print"></a>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树</span><br><span class="line">概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树</span><br><span class="line">      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）</span><br><span class="line">      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置</span><br><span class="line">      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点</span><br><span class="line"></span><br><span class="line">重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上</span><br><span class="line">	触发重绘的条件：改变元素外观属性。如：color，background-color等</span><br><span class="line">	重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观</span><br><span class="line">注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局</span><br><span class="line"></span><br><span class="line">重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。</span><br><span class="line">	每个页面都需要一次回流，就是页面第一次渲染的时候</span><br><span class="line"></span><br><span class="line">重排一定会影响重绘，但是重绘不一定会影响重排</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十三、为什么css放在顶部而js写在后面"><a href="#十三、为什么css放在顶部而js写在后面" class="headerlink" title="十三、为什么css放在顶部而js写在后面"></a>十三、为什么css放在顶部而js写在后面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了</span><br><span class="line">2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。</span><br><span class="line">3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</span><br><span class="line"></span><br><span class="line">但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="十四、存储方式与传输方式"><a href="#十四、存储方式与传输方式" class="headerlink" title="十四、存储方式与传输方式"></a>十四、存储方式与传输方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m</span><br><span class="line">2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响</span><br><span class="line">3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）</span><br><span class="line">4.localStroage: h5的本地存储，数据永久保存在客服端</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie，sessionStorage，localStorage"><a href="#cookie，sessionStorage，localStorage" class="headerlink" title="cookie，sessionStorage，localStorage"></a>cookie，sessionStorage，localStorage</h4><p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象 session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id sessionStorage，localStorage仅在本地保存 3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB 4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage始终有效</p><p>SessionStorage和localStorage区别： 1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p><h4 id="token、cookie、session三者的理解？？？！！！"><a href="#token、cookie、session三者的理解？？？！！！" class="headerlink" title="token、cookie、session三者的理解？？？！！！"></a>token、cookie、session三者的理解？？？！！！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）</span><br><span class="line">    用户身份的验证方式    </span><br><span class="line"></span><br><span class="line">2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名</span><br><span class="line">    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）</span><br><span class="line"></span><br><span class="line">3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）</span><br><span class="line">    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><a href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）" class="headerlink" title="基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）"></a>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1、用户通过用户名和密码发送请求</span><br><span class="line">  2、服务器端验证</span><br><span class="line">  3、服务器端返回一个带签名的token，给客户端</span><br><span class="line">  4、客户端储存token，并且每次用于发送请求</span><br><span class="line">  5、服务器验证token并且返回数据</span><br><span class="line">  每一次请求都需要token</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</span><br><span class="line">  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App</span><br><span class="line">  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，</span><br><span class="line">     token不能转移到其他的App，也不能转到其他用户上。（适用于App）</span><br><span class="line">  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><a href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）" class="headerlink" title="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"></a>Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）</span><br><span class="line">  2、安全性问题。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>一、观察者模式：<a href="https://juejin.im/post/5a14e9edf265da4312808d86" target="_blank" rel="noopener">juejin.im/post/5a14e9…</a> <a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">juejin.im/post/5af05d…</a> 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p></blockquote><blockquote><p>二、发布-订阅者 有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p></blockquote><ul><li>-两者的区别： 1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h4 id="一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><a href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…" class="headerlink" title="一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…"></a>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://www.cnblogs.com/MrListening/p/5697459.html" target="_blank" rel="noopener">www.cnblogs.com/MrListening…</a></h4><h4 id="二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…"><a href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…" class="headerlink" title="二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.im/post/5a27c6…"></a>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.im/post/5a27c6946fb9a04509096248" target="_blank" rel="noopener">juejin.im/post/5a27c6…</a></h4><h4 id="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…"><a href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…" class="headerlink" title="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.im/post/5a2ff8…"></a>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.im/post/5a2ff8c651882533d0230a85" target="_blank" rel="noopener">juejin.im/post/5a2ff8…</a></h4><h4 id="四、十大排序"><a href="#四、十大排序" class="headerlink" title="四、十大排序"></a>四、十大排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。</span><br><span class="line">  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个</span><br><span class="line">	    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</span><br><span class="line">	    3.针对所有的元素重复以上的步骤，除了最后一个</span><br><span class="line">	    4.重复步骤1-3，直到排序完成。</span><br><span class="line">2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾</span><br><span class="line">  实现过程：</span><br><span class="line"></span><br><span class="line">3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入</span><br><span class="line">  实现过程：1.从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">	    2.取出下一个元素，在已排序的元素序列中冲后向前扫描</span><br><span class="line">	    3.如果该元素（以排序）大于新元素，将元素向后移一位</span><br><span class="line">	    4.在取出一个元素，比较之前的，直到找到自己合适的位置</span><br><span class="line"></span><br><span class="line">4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序</span><br><span class="line"></span><br><span class="line">1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现</span><br><span class="line">  实现过程：1.从数组中挑出一个元素，成为一个基准</span><br><span class="line">	    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）</span><br><span class="line">		这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。</span><br><span class="line">	    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序</span><br><span class="line">算法实现： function quickSort (arr) &#123;</span><br><span class="line">		if （arr.length &lt;= 1） &#123;return arr&#125;</span><br><span class="line">		var destIndex = Math.floor(arr.length/2)</span><br><span class="line">		var left = [], right = [];</span><br><span class="line">		var dest = arr.splice(destIndex,1)[0];</span><br><span class="line">		for (var i =0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			if (arr[i]&lt;dest) &#123;</span><br><span class="line">			left.push(arr[i])</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			right.push(arr[i]) &#125;</span><br><span class="line">		return quickSort(left).concat([dest],quickSort(right)</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。</span><br><span class="line">  实现过程：1.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="五、数组去重-juejin-im-post-5aed61…"><a href="#五、数组去重-juejin-im-post-5aed61…" class="headerlink" title="五、数组去重 juejin.im/post/5aed61…"></a>五、数组去重 <a href="https://juejin.im/post/5aed6110518825671b026bed#heading-6" target="_blank" rel="noopener">juejin.im/post/5aed61…</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.双重循环</span><br><span class="line">2.indexOf</span><br><span class="line">3.数组排序去重 最快你Olong</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">判断回文字符串：（递归的思想）</span><br><span class="line">	1.字符串分隔，倒转，聚合[...obj].reverse().join(&apos;&apos;)</span><br><span class="line">	2.字符串头部和尾部，逐次向中间检测 </span><br><span class="line">		实现：function isPalindrome(line) &#123;</span><br><span class="line">			line += &apos;&apos;;</span><br><span class="line">			for (var i=0,j=line.length-1;i&lt;j;i++,j--) &#123;</span><br><span class="line">				if (line.chartAt(i) !== line.chartAt(j) &#123;</span><br><span class="line">				return false</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">	3.递归</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="七、二分查找（有序数组的查找）"><a href="#七、二分查找（有序数组的查找）" class="headerlink" title="七、二分查找（有序数组的查找）"></a>七、二分查找（有序数组的查找）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数</span><br><span class="line"> (1) 一开始,数据范围覆盖整个数组。</span><br><span class="line"> (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。</span><br><span class="line"> (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T</span><br><span class="line">代码实现：function binarySearch (data, dest, start, end)&#123;</span><br><span class="line">		var end = end || data.length-1;</span><br><span class="line">		var start = start || 0;</span><br><span class="line">		var m = Math.floor((start+end)/2);</span><br><span class="line">		if (dest&lt;data[m])&#123;</span><br><span class="line">			return binarySearch(data, dest, 0, m-1)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return binarySearch(data, dest, m+1, end)</span><br><span class="line">		&#125;&#125;</span><br><span class="line">		return false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h4 id="一、动手实现一个bind（原理通过apply，call）"><a href="#一、动手实现一个bind（原理通过apply，call）" class="headerlink" title="一、动手实现一个bind（原理通过apply，call）"></a>一、动手实现一个bind（原理通过apply，call）</h4><p>一句话概括：1.bind()返回一个新函数，并不会立即执行。<br>2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数<br>3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind = function (obj, arg) &#123;</span><br><span class="line">   var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">   var context = this;</span><br><span class="line">   var bound = function (newArg) &#123;</span><br><span class="line">   arg = arg.concat(Array.prototype.slice.call(newArg);</span><br><span class="line">   return context.apply(obj, arg)</span><br><span class="line">&#125;</span><br><span class="line">  var F =  function () &#123;&#125;  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程</span><br><span class="line">  F.prototype = context.prototype;</span><br><span class="line">  bound.prototype =  new F();</span><br><span class="line">  return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、-AJAX-（异步的javascript和xml）"><a href="#二、-AJAX-（异步的javascript和xml）" class="headerlink" title="二、 AJAX （异步的javascript和xml）"></a>二、 AJAX （异步的javascript和xml）</h4><p>ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。<br>优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载<br>可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带<br>劣势：不支持back。对搜索引擎的支持比较弱；不容易调试<br>怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，<br>解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData(url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象</span><br><span class="line">    xhr.open(&apos;get&apos;, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份</span><br><span class="line">    xhr.send() //发送一个http请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;  //设置一个http请求状态的函数</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">        console.log(xhr.responseText)  // 获取异步调用返回的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Promise(getData(url)).resolve(data =&gt; data)</span><br><span class="line"></span><br><span class="line">	 AJAX状态码：0 - （未初始化）还没有调用send()方法</span><br><span class="line">		     1 - （载入）已调用send方法，正在发送请求</span><br><span class="line">		     2 - （载入完成呢）send()方法执行完成</span><br><span class="line">		     3 - （交互）正在解析相应内容</span><br><span class="line">		     4 - （完成）响应内容解析完成，可以在客户端调用了</span><br></pre></td></tr></table></figure><h4 id="三、函数节流（throttle）"><a href="#三、函数节流（throttle）" class="headerlink" title="三、函数节流（throttle）"></a>三、函数节流（throttle）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function throttle (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        var previous = 0;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            context = this;</span><br><span class="line">            args = arguments;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、函数防抖（dobounce）"><a href="#四、函数防抖（dobounce）" class="headerlink" title="四、函数防抖（dobounce）"></a>四、函数防抖（dobounce）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            var context = this;</span><br><span class="line">            var args = arguments;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                func.apply(context,args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.clone = function() &#123;</span><br><span class="line">  var newObject = this.constructor === Array ? [] : &#123;&#125;  //对象的深拷贝 获取对应的构造函数 [] 或者 &#123;&#125;</span><br><span class="line">  for (let e in this) &#123; //遍历对象的属性 in  this[e]</span><br><span class="line">    newObject[e] = typeof this[e] === &apos;object&apos; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型</span><br><span class="line">  &#125;</span><br><span class="line">  return newObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab"><a href="#六、实现一个简单的Promise-https-juejin-im-post-5b2f02cd5188252b937548ab" class="headerlink" title="六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab"></a>六、实现一个简单的Promise <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。</span><br><span class="line">    this.status = &apos;pending&apos;,</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 成功存放的数组</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">     // 失败存放法数组</span><br><span class="line">     this.onRejectedCallbacks = [];</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;resolve&apos;;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">        this.status = &apos;reject&apos;;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  then (onFullFilled,onRejected) &#123;</span><br><span class="line">    if (this.status == &apos;resolved&apos;) &#123;</span><br><span class="line">      onFullFilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;rejectd&apos;) &#123;</span><br><span class="line">      onRejected(this.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &apos;pending&apos;) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFullFilled(this.value);</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">          onRejected(this.reason);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&apos;hello world&apos;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then((data) =&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;,(err) =&gt;&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="七、发布订阅者模式（观察者模式）"><a href="#七、发布订阅者模式（观察者模式）" class="headerlink" title="七、发布订阅者模式（观察者模式）"></a>七、发布订阅者模式（观察者模式）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var event = &#123;&#125;; // 发布者</span><br><span class="line">event.clientList = [] //发布者的缓存列表</span><br><span class="line"></span><br><span class="line">event.listen = function (fn) &#123;  // 增加订阅者函数</span><br><span class="line">  this.clientList.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.trigger = function () &#123;  // 发布信息</span><br><span class="line">  for (var i =0;i&lt;this.clientList.length;i++) &#123;</span><br><span class="line">    var fn = this.clientList[i];</span><br><span class="line">    fn.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.listen (function(time) &#123;</span><br><span class="line">  console.log(&apos;正式上班时间为：&apos; +time)</span><br><span class="line">&#125;)</span><br><span class="line">event.trigger (&apos;2018/7&apos;)</span><br></pre></td></tr></table></figure><h4 id="八、手动写一个node服务器"><a href="#八、手动写一个node服务器" class="headerlink" title="八、手动写一个node服务器"></a>八、手动写一个node服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const server = http.createServer((req,res) =&gt; &#123;</span><br><span class="line">	if (reu.url == &apos;/&apos;) &#123;</span><br><span class="line">	const indexFile = fs.createReadStream(&apos;./index.html&apos;)</span><br><span class="line">	req.writeHead(200,&#123;&apos;context-Type&apos;:&apos;text/html;charset = utf8&#125;)</span><br><span class="line">	indexFile.pipe(res)</span><br><span class="line">&#125;</span><br><span class="line">server.listen(8080)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>深信服研发前端岗位实习面经</title>
    <url>/2019/11/05/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A0%94%E5%8F%91%E5%89%8D%E7%AB%AF%E5%B2%97%E4%BD%8D%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="深信服研发前端岗位实习面经"><a href="#深信服研发前端岗位实习面经" class="headerlink" title="深信服研发前端岗位实习面经"></a>深信服研发前端岗位实习面经</h1><h3 id="前两轮两轮技术面"><a href="#前两轮两轮技术面" class="headerlink" title="前两轮两轮技术面"></a>前两轮两轮技术面</h3><p>前端也学了有一年了，感觉学得差不多了，就去招聘网站看看岗位要求，</p><blockquote><p>长沙知名互联网公司基本没有😭 昨天逛实习僧，看到长沙有深信服的前端岗位又是招21届的又是vue技术栈 想试试水，投一个。</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>中间没有录音，凭记忆就这些了，下次一定要准备好复盘</p><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><p><strong>说说项目的亮点，难点</strong>，两次面试都说到了项目，第一次说了购物车模块实现，路由keep-alive生命周期什么的，第二次说的使用async await去失效的图片</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul><li>position relative absolute float</li><li>css的定位</li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li>怎么判断数组数据类型tinstanceof、Object.prototype.toString.call()等</li><li>原生ajax讲代码，请求过程</li><li>怎么原生实现同步ajax</li><li>setTimeout 执行顺序</li><li>异步同步，事件机制</li><li>宏任务与微任务</li><li>说一下get post区别</li><li>dom事件流 冒泡 捕获</li><li>事件代理</li><li>call apply区别</li><li>“==”和“===”的区别</li><li>for of 和for in区别</li></ul><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li>讲讲es6学了什么，</li><li>我说了let const 变量提升</li><li>promise async await</li><li>他叫 我说一下 set 和map</li></ul><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul><li>vue生命周期</li><li>vue router</li><li>组件怎么传参数 父子props emit 同组件 bus</li><li>vuex</li><li>说一下vue与react的区别</li></ul><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ul><li>说一下Webpack基本概念与配置</li><li>loader与plugin原理与实现 ，这个不太了解，我说一般使用vue-cli自动打包plugin按需加载</li></ul><h3 id="hr面试"><a href="#hr面试" class="headerlink" title="hr面试"></a>hr面试</h3><ul><li>自我介绍</li><li>说一说你平时怎么学习，</li><li>公司项目跟自己写项目区别，</li><li>说一说你看过什么书 ，</li><li>说一说你遇到的最大的困难，</li><li>还有什么问的吗，问他新人培训机制 是怎样的</li></ul><hr><p><strong>没想到一次试水面试，三轮面试就这样过了，上午面试第一个电话还在健身房洗澡，没接，打过去裤子都没穿，边穿衣服边面试，面完没想到说我还行😇</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器部署node新手教程（二）</title>
    <url>/2019/10/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="服务器部署node教程（二）"><a href="#服务器部署node教程（二）" class="headerlink" title="服务器部署node教程（二）"></a>服务器部署node教程（二）</h1><blockquote><p>期间经历了很多坑，多数还是找到了解决办法，相信经历了第一次，以后就能孰能生巧了。</p></blockquote><h3 id="安装最新的node-js环境"><a href="#安装最新的node-js环境" class="headerlink" title="安装最新的node.js环境"></a>安装最新的node.js环境</h3><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p><code>ssh 用户名</code></p><p><code>yum update -y</code>更新</p><p><code>yum install -y nodejs</code>安装nodejs</p><p>查看结果无误，不过版本太低低 删掉 rm</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572102034266.png" alt="1572102034266"></p><p><strong>去官网下</strong></p><p><code>https://nodejs.org/dist/</code></p><p>我下载的最新13版本</p><p><code>wget https://nodejs.org/dist/v13.0.1//node-v13.0.1-linux-x64.tar.xz</code></p><p>解压</p><p><code>tar -xvJf node-v13.0.1-linux-x64.tar.xz</code></p><p>利用软链接放到环境变量 必须用绝对路径 ，路径自己ls查看</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572105757441.png" alt="1572105757441"></p><p>成功🤞</p><h3 id="通过VsCode-ftp-连接接服务器"><a href="#通过VsCode-ftp-连接接服务器" class="headerlink" title="通过VsCode ftp 连接接服务器"></a>通过VsCode ftp 连接接服务器</h3><p>vscode安装插件<code>sftp</code></p><p><code>ctrl+shift+p</code>搜索<code>sftp:Config</code></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572106834768.png" alt="1572106834768"></p><p>配置config，用法字面意思能看懂，更复杂配置搜文档</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Jason"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"47.103.209.82"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"sftp"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"remotePath"</span>: <span class="string">"/home/frontend"</span>,</span><br><span class="line">    <span class="attr">"uploadOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ignore"</span>: [</span><br><span class="line">        <span class="string">".vscode"</span>,</span><br><span class="line">        <span class="string">".git"</span>,</span><br><span class="line">        <span class="string">".DS_Store"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"syncOption"</span>: &#123;</span><br><span class="line">        <span class="attr">"delete"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"update"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"watcher"</span>: &#123;</span><br><span class="line">        <span class="attr">"files"</span>: <span class="string">"**/*"</span>,</span><br><span class="line">        <span class="attr">"autoUpload"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"autoDelete"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"privateKeyPath"</span>: <span class="string">"~/.ssh/id_rsa"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572145404172.png" alt="1572145404172"></p><p>右键可以拉取推送到服务器</p><h3 id="配置nginx-反向代理"><a href="#配置nginx-反向代理" class="headerlink" title="配置nginx 反向代理"></a>配置nginx 反向代理</h3><p>安装<code>yum install -y nginx</code></p><p>配置nginx.conf，监听服务器本地的5000端口，详细配置请看nginx文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:3000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推入服务器，修改为可执行权限</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572154533239.png" alt="1572154533239"></p><p>覆盖掉原来的nginx配置文件</p><p><code># cp nginx.conf /etc/nginx/nginx.conf</code></p><p>重启nginx</p><p><code># systemctl restart nginx</code></p><p>浏览器输入ip，返回nginx error说明已经配上了</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572154823450.png" alt="1572154823450"></p><p>在服务器安装个express</p><p><code>npm install express -S</code></p><p>测试一下</p><p>趴到本地，建一个index.js测试文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理静态文件</span></span><br><span class="line">app.use(express.static(<span class="string">'client/dist'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, <span class="string">'client'</span>, <span class="string">'dist'</span>, <span class="string">'index.html'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/api/datas'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        name: <span class="string">'Jason'</span>,</span><br><span class="line">        wechat: <span class="string">'wjcyx99'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>推到服务器，运行 <code>node index.js</code><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572156101543.png" alt="1572156101543"></p><p>浏览器查看结果，成功👍</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572156042839.png" alt="1572156042839"></p><h3 id="创建全局模块软链接"><a href="#创建全局模块软链接" class="headerlink" title="创建全局模块软链接"></a>创建全局模块软链接</h3><p>刚刚 <code>cnpm install -g @vue/cli</code>安装个vue脚手架</p><p>找到vue 在这里</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572157762872.png" alt="1572157762872"></p><p>放到全局，有效果</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572157803313.png" alt="1572157803313"></p><p>使用forever 后台运行</p><p><a href="https://github.com/foreversd/forever" target="_blank" rel="noopener">https://github.com/foreversd/forever</a></p><p><code>npm install forever -g</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ forever start app.js          #启动</span><br><span class="line">$ forever stop app.js           #关闭</span><br></pre></td></tr></table></figure><h3 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h3><p>实验做得差不多了，给我的CityMALL打包上线</p><h3 id="linux下安装mongodb"><a href="#linux下安装mongodb" class="headerlink" title="linux下安装mongodb"></a>linux下安装mongodb</h3><ol><li>在官方下找到下载路径,CentOS红帽子公司的</li></ol><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572253297039.png" alt="1572253297039"></p><p><code>wget 路径</code></p><ol start="2"><li>下载完后解压到这个目录，没有创建</li></ol><p><code>tar -zxvf mongodb-linux-x86_64-rhel70-4.2.1.tgz -C /usr/local/mongoDB/</code></p><p>名字太长了，改个名<code># mv mongodb-linux-x86_64-rhel70-4.2.1 mongodbserver</code></p><ol start="3"><li><p>创建data数据，log日志，etc配置 文件夹</p><p>创建配置文件mongodb.conf</p></li></ol><p><code>cd /usr/local/mongoDB/mongodbserver/etc</code></p><p><code>vim mongodb.conf</code></p><blockquote><p>从mongodb3.2开始默认的存储引擎是WiredTiger，3.3版本之前的默认存储引擎是MMAPv1，mongodb4.x版本不再支持MMAPv1存储引擎。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbpath=/usr/local/mongoDB/mongodbserver/data/db #数据存放</span><br><span class="line">logpath=/usr/local/mongoDB/mongodbserver/data/logs/mongodb.log #日志存放</span><br><span class="line">port=27017 #端口</span><br><span class="line">logappend=true #追加方式写日志  </span><br><span class="line">noauth=true #不启用验证  </span><br><span class="line">fork=true #可在后台运行</span><br><span class="line">journal=true #每次写入会记录一条操作</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>添加环境变量</strong></li></ol><ul><li>在/etc/profile文件中，文末添加 export <code>vim /etc profile</code></li></ul><p><code>export PATH=$PATH:/usr/local/mongoDB/mongodbserver/bin</code></p><p>执行``source /etc/profile`，使系统环境变量立即生效</p><ul><li>将mongo路径软链到/usr/bin路径下，方便随处执行mongo命令</li></ul><p>执行命令: <code>ln -s /usr/local/mongoDB/mongodbserver/bin/mongo /usr/bin/mongo</code></p><p>通过配置文件运行，mongod</p><p><code># mongod --config /usr/local/mongoDB/mongodbserver/etc/mongodb.conf</code></p><p>运行mongo成功👍</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572262020655.png" alt="1572262020655"></p><p>到database 初始化mongoDB创建schema</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572442011030.png" alt="1572442011030"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> db = <span class="string">"mongodb://localhost/shoppingMall"</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.initSchemas = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    glob.sync(resolve(__dirname, <span class="string">'./schema'</span>, <span class="string">'**/*.js'</span>)).forEach(<span class="built_in">require</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库导入，修正"><a href="#数据库导入，修正" class="headerlink" title="数据库导入，修正"></a>数据库导入，修正</h3><p>之前写了api，直接在浏览器中输入，执行命令</p><p>之前的白酒分类是错的把它修正</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572488999983.png" alt="1572488999983"></p><h3 id="老是出现node-modules错误"><a href="#老是出现node-modules错误" class="headerlink" title="老是出现node_modules错误"></a>老是出现node_modules错误</h3><p>windows<code>cnpm install rimraf -g</code></p><p><code>rm -f /node_modules</code></p><p>linux <code>rm -rf node_modules</code></p><p>一般都是把node_modules删除重新下载<code>cnpm install</code>，有些还不能删除强行移动文件夹就行了</p><h3 id="不挂断在后台运行"><a href="#不挂断在后台运行" class="headerlink" title="不挂断在后台运行"></a>不挂断在后台运行</h3><ol><li><p>nohup<br>nohup 是 no hang up 的缩写，就是不挂断的意思。nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。</p></li><li><p>&amp;</p><p>&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出。</p></li></ol><p>使用命令 nohup COMMAND &amp; 这样就能使命令永久的执行下去，关闭终端窗口、Ctrl+c 、断开SSH连接都不会影响其运行，并且可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件。</p><h3 id="前台打包成静态文件"><a href="#前台打包成静态文件" class="headerlink" title="前台打包成静态文件"></a>前台打包成静态文件</h3><p>​ <code>npm run build</code> 生成dist文件夹放入service，直接就可以使用了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> staticFiles = <span class="built_in">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 dist目录为静态资源目录，用来存放 js css images 等</span></span><br><span class="line">app.use(staticFiles(path.resolve(__dirname, <span class="string">"./dist"</span>)))</span><br></pre></td></tr></table></figure><p>在手机测试成功后心情豁然开朗😎</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572520037662.png" alt="1572520037662"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>服务器部署</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>部署</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云部署新手教程（一）（购买服务器，免密登陆）</title>
    <url>/2019/10/25/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="阿里云部署项目新手教程（一）"><a href="#阿里云部署项目新手教程（一）" class="headerlink" title="阿里云部署项目新手教程（一）"></a>阿里云部署项目新手教程（一）</h1><h2 id="（购买服务器，免密登陆）"><a href="#（购买服务器，免密登陆）" class="headerlink" title="（购买服务器，免密登陆）"></a>（购买服务器，免密登陆）</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>阿里云有学生优惠10元一个月，我选择的是轻量应用服务器，有ssd内存，更高的带宽，但是限量1000G应该够用。选择系统镜像CentOS操作系统。</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>轻量应用服务器操作起来更简单。</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572003725828.png" alt="1572003725828"></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572004461160.png" alt="1572004461160"></p><h3 id="如何远程连接"><a href="#如何远程连接" class="headerlink" title="如何远程连接"></a>如何远程连接</h3><p>打开cmd终端输入<code>ssh root@0.0.0.0</code>root表示根用户名@后面接公网IP地址</p><p>连上来了</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572004847359.png" alt="1572004847359"></p><h3 id="保存ssh公钥免密登陆"><a href="#保存ssh公钥免密登陆" class="headerlink" title="保存ssh公钥免密登陆"></a>保存ssh公钥免密登陆</h3><p>终端 在~目录下 cd .ssh 进去.ssh文件夹，输入，没有ssh文件夹 创建 <code>md .ssh</code> bash<code>mkdir</code></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "myemail@myemail.com"</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter file in which to save the key (/home/Administrator/.ssh/id_rsa): C:\Users\Administrator\.ssh\id_rsa</span><br></pre></td></tr></table></figure><p>然后它会要你填写地址，dos得自己填，要不然会报错，因为unix命令都是相反的斜杠，成功之后生成了公钥私钥文件</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572008937745.png" alt="1572008937745"></p><p><strong>然后改回bash终端写命令，dos cmd 太不兼容了😥，全是坑，用git bash，ubantu bash 都可</strong></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572009417347.png" alt="1572009417347"></p><p><code>scp id_rsa.pub root@0.0.0.0:.</code></p><p>解释：复制 这个公钥 到你服务器root用户下的（默认文件夹下<code>:.</code>）</p><p>登陆服务器检查一下，文件已经过来了</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572009688607.png" alt="1572009688607"></p><p><code># cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>把公钥文件追加进来</p><p><code>vim</code>打开这个文件确认一下</p><p>然后重启一下<code># systemctl restart sshd</code></p><p>回到本地，删了公钥<code>$ rm id_rsa.pub</code></p><p>新建配置文件</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572010250446.png" alt="1572010250446"></p><p><code>$ code config</code>vscode 打开config,配置</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572010927402.png" alt="1572010927402"></p><p><code>ssh 用户名</code>免密登陆成功😎</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572010957144.png" alt="1572010957144"></p><h3 id="git-push-到github-ssh-免密推送"><a href="#git-push-到github-ssh-免密推送" class="headerlink" title="git push 到github ssh 免密推送"></a>git push 到github ssh 免密推送</h3><p>把之前的公钥写进来</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572015770953.png" alt="1572015770953"></p><p>把https推送修改成ssh推送</p><p><code>git remote set-url origin +ssh链接</code></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572015579162.png" alt="1572015579162"></p><p>免密推送成功😎</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/nodeToService/1572015804042.png" alt="1572015804042"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>服务器部署</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>部署，服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>1024程序员节+项目总结+日常</title>
    <url>/2019/10/24/1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/</url>
    <content><![CDATA[<h1 id="1024程序员节-项目总结-日常"><a href="#1024程序员节-项目总结-日常" class="headerlink" title="1024程序员节+项目总结+日常"></a>1024程序员节+项目总结+日常</h1><blockquote><p>今天程序员过节，自己呢，从学生向程序员慢慢进发了。</p></blockquote><p>学习了一年多，觉得自己也算是入门前端这个领域了。虽然是很日常的一天，但纪念第一次有了从学生到程序员的认同感的节日是有意义的。</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p><strong>说说我今天日常的一天。</strong></p><p>上午买了腾讯课堂的项目部署打折，这个商城项目写得也差不多了，在手机上测试了一下，修改了一些些bug</p><p><strong>1.点击商品详情页商品信息重复没有刷新</strong></p><p>是由于之前为了页面不刷新加了<code>&lt;keep-alive&gt;</code>导致所有页面重复加载就不会触发刷新。</p><p>在router index.js 文件下 <code>meta: { keepAlive:false //不需要被缓存的组件 }</code>在不需要缓存的页面加上配置。</p><p>在App.vue 文件下 对需要缓存的页面做一个判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;$route.meta.keepAlive&quot; /&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>2.如何在手机端调试写好的程序</strong></p><ul><li><p>首先要在同一个局域网下，手机与电脑在同一个局域网内，<strong>把防火墙关了</strong>，防火墙是个大坑，试了好久</p></li><li><p>cmd终端命令<code>ipconfig</code> 查看无线网的IP地址，在config&gt;index.js 配置下 <code>host: &#39;192.168.137.1&#39;,</code> 域名改成你的IP</p></li><li><p>请求接口配置文件也改成你的IP<code>const LOCALURL = &quot;http://192.168.137.1:3000/&quot;</code>成功访问后台接口</p></li><li><p>如果有json-server 模拟数据，在package.json=&gt;scripts下把host改为0.0.0.0就可以让所有IP访问到</p></li></ul><p><code>&quot;json:server&quot;: &quot;json-server --watch --host 0.0.0.0 --port 3001 goods.json&quot;</code></p><h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><p>前期跟着老师视屏做，照着视频敲，学完后发现这个项目不太完善，页面很多功能都没做，老师的教程也结束了，烂尾了，在掘金看技术胖的赞那么多，觉得看他的视频总没错，只能说期望太高了。那就只有自己就把一些不满意的地方都改了，这样也好，能有自己思考的空间。</p><p><strong>个人页面</strong>直接没讲，我就自己加了有赞的个人页面框架，把<strong>登陆注册</strong>加进去了。其他功能接口都没写。</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017219183.png" alt="1572017219183"></p><p><strong>购物车</strong>UI也做了相应优化，计算总价，checkbox。</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017252727.png" alt="1572017252727"></p><p><strong>商品详情</strong>统一用了vantUI组件，之前实在难看。</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017542406.png" alt="1572017542406"></p><p><strong>列表商品</strong>之前爬的图片链接失效，直接在后台把失效图片给洗了一遍。</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017315053.png" alt="1572017315053"></p><p>使用axios请求，把能请求到的数据写入新文件，请求不到就抛弃。之前先存一个数组，再一概写进去这是不行的，会返回一个空数组。多个异步请求，函数直接返回了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">newData.map(<span class="keyword">async</span>(value, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> result = <span class="keyword">await</span> axios.get(value.IMAGE1)</span><br><span class="line">                <span class="comment">//console.log(value)</span></span><br><span class="line">                fs.appendFile(<span class="string">'./data_json/newGoods2.json'</span>,<span class="built_in">JSON</span>.stringify(value)+<span class="string">','</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err + <span class="string">'bb'</span>)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>也算彻底弄懂了JS的运行顺序，异步同步，宏任务微任务，还有async/await，看了几篇文章。以后再单独拿出来一篇文章总结把。</p><p>mongoDB数据库，增加了一个休闲食品类别，把食品饮料栏变为两栏，要不然这一栏的子分类太多了，还有一个白酒的分类，里面数据却全是生鲜，技术胖老师完全不走心。我全都改了。</p><p>后期，还要把<strong>首页的所有图片链接跳转商品详情</strong>给完善了，</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017598297.png" alt="1572017598297"></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1572017627898.png" alt="1572017627898"></p><p><em>第二天完善了</em></p><p>首页分类跳到分类详情，在分类栏绑定@click方法，传入ID值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">goCategory(index)&#123;</span><br><span class="line">  <span class="comment">//console.log(index)</span></span><br><span class="line">  <span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">'CategoryList'</span>,<span class="attr">params</span>:&#123;<span class="attr">mallCategoryId</span>:index&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到商品分类，然后在<code>activated()</code>钩子函数中把具体页号传过来，默认第一个</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line">  <span class="keyword">let</span> firstCategoryIndex = <span class="keyword">this</span>.$route.params.mallCategoryId || <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.clickCategory(firstCategoryIndex, firstCategoryIndex + <span class="number">1</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>应用clickCategory方法点击到指定分类栏。</p><p>之前写在<code>create()</code>钩子中，没有效果，问题页面是keep-alive存在缓存，不会重新加载。</p><p><strong>知识点</strong>: 钩子函数的执行顺序</p><p>使用<code>keep-alive</code>的初次加载顺序</p><p><code>beforeRouteEnter --&gt; created --&gt; mounted --&gt; activated --&gt; deactivated</code></p><p>再次进入缓存的页面，只会触发<code>beforeRouteEnter --&gt;activated --&gt; deactivated</code></p><p>created和mounted不会再执行。</p><p>关于vue的路由还需要继续升入了解，现在知道的还太浅了。</p><p>之后学习一下怎么挂在服务器。</p><hr><h3 id="说一说傍晚的狗血京东校招"><a href="#说一说傍晚的狗血京东校招" class="headerlink" title="说一说傍晚的狗血京东校招"></a>说一说傍晚的狗血京东校招</h3><p>群里通知说今天晚上有京东的校招，下午赶紧把简历完善了去试试水。</p><p>兴致勃勃去那里，开始宣讲，先是说京东怎么待遇好，几万员工，什么环境，强东哥怎么怎么厉害。然后ppt开始显示<strong>京东顾问</strong>？？？我觉得好像是京东，不对劲，讲师开始宣传怎么当客服来了。三千一个月的京东<strong>客服</strong>，太会蹭京东的热点了，还只招客服3000一个月。。。“就没人提问了吗，都是家里有矿的可以走了”，然后我叫室友一起溜走了。本科生当客服，真有人愿意吗？纯体力活，不值得给强哥卖命，有时间还是学点真本事吧。</p><h3 id="再说一说上周的狗血拓维"><a href="#再说一说上周的狗血拓维" class="headerlink" title="再说一说上周的狗血拓维"></a>再说一说上周的狗血拓维</h3><p>去拓维看热闹。校招招60个java，就5个前端，笔试题全是java，就只有两个前端题一个填空，数组合并字符串：<code>arr.join(&#39;&#39;)</code>，手写代码打点计时器用<code>setinterval+闭包函数</code>写了，交个白卷勾个前端，走了。</p><p>结果回来路上打电话，叫回去面试，面试官说他是团队LEADER，java后台但是懂一些前端。</p><p>面试官问我小程序生命周期，学了几个月我有点模糊忘记了，硬着头皮把vue生命周期说得头头是道,面试官说我‘说得不错’。</p><p>然后要我写个移动登陆布局，他rem都不知道，他觉得rem是栅格布局，跟他解释根元素字体大小都不懂，他把rem理解为栅格布局？？</p><p><code>transform：translate</code>也不知道我说是位移,他硬是说动画，我说动画是<code>transition</code>或者用<code>animation</code>可以实现，估计他没听懂，说我平常是不是复制粘贴。</p><p>我说我没有，我都是自己写代码，我觉得可能登陆布局没什么好证明实力的，立马给他手写了个双飞翼部。就叫我等通知就没有然后了。</p><p>我觉得根本不懂前端基础就来面试别人，不懂装懂批判别人很可耻，现场没有前端可以电话别的前端同事阿。</p><p>拉黑拓维公司，大一期末的时候，给粮食局装新系统，招实习生去装，我积极报名了，期末过后培训了三天结果还是水了我们四个大一的，就去了一个大一，其余都是大二大三一个没刷，根本没有一行代码，就是装系统体力活，凭什么刷我们低年级。</p><p>算是看透这个公司了，给政府，华为做外包，其美名曰：‘战略合作’。</p><hr><p>吐槽归吐槽，毕竟二流本科，也没什么好资源，要怪也只能怪自己高中只有这个水平进这样的学校。有机会进来工作室，也算是一种幸运，看外面的世界，心态格局就跟班上有些还在浑浑噩噩度日不是一个档次了，努力努力争取跳出平凡。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（九）tabbar</title>
    <url>/2019/10/21/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B9%9D%EF%BC%89tabbar/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（九）tabbar"><a href="#vue-js商城项目（九）tabbar" class="headerlink" title="vue.js商城项目（九）tabbar"></a>vue.js商城项目（九）tabbar</h1><h3 id="取消路由中的-号"><a href="#取消路由中的-号" class="headerlink" title="取消路由中的#号"></a>取消路由中的#号</h3><p>在new Router()的下一行添加上：mode: ‘history’,</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="使用vant-tabBar组件"><a href="#使用vant-tabBar组件" class="headerlink" title="使用vant tabBar组件"></a>使用vant tabBar组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;van-tabbar</span><br><span class="line">      v-model=&quot;active&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;van-tabbar-item icon=&quot;shop&quot; to=&apos;/&apos;&gt;首页&lt;/van-tabbar-item&gt;</span><br><span class="line">      &lt;van-tabbar-item icon=&quot;records&quot; to=&apos;/CategoryList&apos;&gt;分类&lt;/van-tabbar-item&gt;</span><br><span class="line">      &lt;van-tabbar-item icon=&quot;cart&quot; to=&apos;/Cart&apos;&gt;购物车&lt;/van-tabbar-item&gt;</span><br><span class="line">      &lt;van-tabbar-item icon=&quot;contact&quot; to=&apos;User&apos;&gt;我的&lt;/van-tabbar-item&gt;</span><br><span class="line">    &lt;/van-tabbar&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&apos;Tab&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route(to, from) &#123;</span><br><span class="line">      console.log(to)</span><br><span class="line">      switch (to.fullPath) &#123;</span><br><span class="line">        case &apos;/&apos;:</span><br><span class="line">          this.active = 0;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;/CategoryList&apos;:</span><br><span class="line">          this.active = 1;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;/Cart&apos;:</span><br><span class="line">          this.active = 2;</span><br><span class="line">          break;</span><br><span class="line">        case &apos;/User&apos;:</span><br><span class="line">          this.active = 3;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          this.active = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在App.vue中写入组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">    &lt;Tab v-show=&quot;!$route.meta.fullScreen&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Tab from &apos;@/components/pages/Tab&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Tab</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在router中如果不是首级，设置全屏</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">    fullScreen: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js中就可以做出判断</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（八）购物车</title>
    <url>/2019/10/17/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（八）购物车"><a href="#vue-js商城项目（八）购物车" class="headerlink" title="vue.js商城项目（八）购物车"></a>vue.js商城项目（八）购物车</h1><h3 id="得到购物车数据方法编写"><a href="#得到购物车数据方法编写" class="headerlink" title="得到购物车数据方法编写"></a>得到购物车数据方法编写</h3><p>先要取得localStorage里的数据，我们先在data里注册两个属性<code>cartInfo</code>(购物车中商品的信息)和<code>isEmpty</code>（购物是否为空的标识，方便页面呈现）,然后再编写具体的<code>getCartInfo()</code>方法</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到购物车的商品</span></span><br><span class="line">  getCartInfo() &#123;</span><br><span class="line">    <span class="comment">//判断localStorage里是否有购物车数据</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.cartInfo) &#123;</span><br><span class="line">      <span class="comment">//如果有数据，我们去除并赋值给cartInfo</span></span><br><span class="line">      <span class="keyword">this</span>.cartInfo = <span class="built_in">JSON</span>.parse(localStorage.cartInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印到控制台查看效果</span></span><br><span class="line">    <span class="comment">//console.log(' this.cartInfo:' + JSON.stringify(this.cartInfo))</span></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="keyword">this</span>.cartInfo.length &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="加入购物车的方法"><a href="#加入购物车的方法" class="headerlink" title="加入购物车的方法"></a>加入购物车的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addGoodsToCart() &#123;</span><br><span class="line">      <span class="comment">//取出购物车内的商品数据</span></span><br><span class="line">      <span class="keyword">let</span> cartInfo = localStorage.cartInfo ? <span class="built_in">JSON</span>.parse(localStorage.cartInfo) : []</span><br><span class="line">      <span class="comment">//判断购物车内是否已经有这个商品</span></span><br><span class="line">      <span class="comment">//如果没有返回undeifnd，如果有返回第一个查找到的数据</span></span><br><span class="line">      <span class="keyword">let</span> isHaveGoods = cartInfo.find(<span class="function"><span class="params">cart</span> =&gt;</span> cart.goodsId == <span class="keyword">this</span>.goodsId)</span><br><span class="line">      <span class="built_in">console</span>.log(isHaveGoods)</span><br><span class="line">      <span class="keyword">if</span> (!isHaveGoods) &#123;</span><br><span class="line">        <span class="comment">//没有商品直接添加到数组中</span></span><br><span class="line">        <span class="comment">//重新组成添加到购物车的信息</span></span><br><span class="line">        <span class="keyword">let</span> newGoodsInfo = &#123;</span><br><span class="line">          goodsId: <span class="keyword">this</span>.goodsInfo.ID,</span><br><span class="line">          Name: <span class="keyword">this</span>.goodsInfo.NAME,</span><br><span class="line">          price: <span class="keyword">this</span>.goodsInfo.PRESENT_PRICE,</span><br><span class="line">          image: <span class="keyword">this</span>.goodsInfo.IMAGE1,</span><br><span class="line">          count: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cartInfo.push(newGoodsInfo) <span class="comment">//添加到购物车</span></span><br><span class="line">        localStorage.cartInfo = <span class="built_in">JSON</span>.stringify(cartInfo) <span class="comment">//操作本地数据</span></span><br><span class="line">        Toast.success(<span class="string">'添加成功'</span>)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.success(<span class="string">'已有此商品'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'Cart'</span> &#125;)  <span class="comment">//进行跳转</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="计算总价"><a href="#计算总价" class="headerlink" title="计算总价"></a>计算总价</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    totalMoney() &#123;</span><br><span class="line">      <span class="keyword">let</span> allMoney = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.cartInfo.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        allMoney += item.price * item.count</span><br><span class="line">      &#125;)</span><br><span class="line">      localStorage.cartInfo = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.cartInfo)</span><br><span class="line">      <span class="keyword">return</span> allMoney</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="修改购物车计数器事件"><a href="#修改购物车计数器事件" class="headerlink" title="修改购物车计数器事件"></a>修改购物车计数器事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-checkbox</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">"card-goods__item"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">v-for</span>=<span class="string">"(item,index) in cartInfo"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">:name</span>=<span class="string">"item.goodsId"</span></span></span><br><span class="line"><span class="tag">       &gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">van-card</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:title</span>=<span class="string">"item.Name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:num</span>=<span class="string">"item.count"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:price</span>=<span class="string">"item.price"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">:thumb</span>=<span class="string">"item.image"</span></span></span><br><span class="line"><span class="tag">           @<span class="attr">click.stop</span></span></span><br><span class="line"><span class="tag">         &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">van-stepper</span></span></span><br><span class="line"><span class="tag">             <span class="attr">slot</span>=<span class="string">"footer"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">v-model</span>=<span class="string">"item.count"</span></span></span><br><span class="line"><span class="tag">             </span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">van-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">van-checkbox</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">van-checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1571473946368.png" alt="1571473946368"></p><p>点击stepper时会触发checkbox的事件，用@click.stop阻止card内部事件冒泡</p><h3 id="计算总价-1"><a href="#计算总价-1" class="headerlink" title="计算总价"></a>计算总价</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">totalMoney() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.cartInfo.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + (<span class="keyword">this</span>.checkedGoods.indexOf(item.goodsId) !== <span class="number">-1</span> ? item.price*item.count : <span class="number">0</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)*<span class="number">100</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以用一行代码写出来，为了清晰写了两行，使用reduce函数增加总价，判断打勾的商品，如果存在就用价格乘以数量，如果不存在加0.</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1571568902600.png" alt="1571568902600"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;van-checkbox</span><br><span class="line">  class=&quot;card-goods__item&quot;</span><br><span class="line">  v-for=&quot;(item,index) in cartInfo&quot;</span><br><span class="line">  :key=&quot;index&quot;</span><br><span class="line">  :name=&quot;item.goodsId&quot;</span><br><span class="line">  v-model=&quot;checked&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在vant组件中，<code>：name</code>属性中的值会存入<code>data() checkedGoods: [], //是否选中的物品</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（七）</title>
    <url>/2019/10/15/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（七）"><a href="#vue-js商城项目（七）" class="headerlink" title="vue.js商城项目（七）"></a>vue.js商城项目（七）</h1><h3 id="数据提纯"><a href="#数据提纯" class="headerlink" title="数据提纯"></a>数据提纯</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./goods.json'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newData = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pushData = []</span><br><span class="line">    newData.RECORDS.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.IMAGE1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            i++</span><br><span class="line">            <span class="built_in">console</span>.log(value.NAME)</span><br><span class="line">            pushData.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    fs.writeFile(<span class="string">'./newGoods.json'</span>, <span class="built_in">JSON</span>.stringify(pushData), <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'写文件操作失败'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'写文件操作成功'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>提取有图的json数据</p><h3 id="存入mongoose"><a href="#存入mongoose" class="headerlink" title="存入mongoose"></a>存入mongoose</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./newGoods.json'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">        <span class="keyword">let</span> saveCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> Goods = mongoose.model(<span class="string">'Goods'</span>)</span><br><span class="line">        data.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//console.log(value)</span></span><br><span class="line">            <span class="keyword">let</span> newGoods = <span class="keyword">new</span> Goods(value)</span><br><span class="line">            newGoods.save().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                saveCount++</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'成功'</span> + saveCount)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + error)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1570762124307.png" alt="1570762124307"></p><h3 id="双栏列表"><a href="#双栏列表" class="headerlink" title="双栏列表"></a>双栏列表</h3><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1571132512573.png" alt="1571132512573"></p><p>前端axios请求后台，后台查询数据库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  getCategory() &#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: url.getCategoryList,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//console.log(response)</span></span><br><span class="line">        <span class="keyword">if</span> (response.data.code == <span class="number">200</span> &amp;&amp; response.data.message) &#123;</span><br><span class="line">          <span class="keyword">this</span>.category = response.data.message</span><br><span class="line">          <span class="comment">//console.log(this.category)</span></span><br><span class="line">          <span class="keyword">this</span>.getCategorySubByCategoryId(<span class="keyword">this</span>.category[<span class="number">0</span>].ID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Toast(<span class="string">'服务器错误，数据取得失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  clickCategory(index, categoryId) &#123;</span><br><span class="line">    <span class="keyword">this</span>.categoryIndex = index</span><br><span class="line">    <span class="keyword">this</span>.page = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.finished = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.goodList = []</span><br><span class="line">    <span class="keyword">this</span>.getCategorySubByCategoryId(categoryId)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//根据大类ID读取小类类别列表</span></span><br><span class="line">  getCategorySubByCategoryId(categoryId) &#123;</span><br><span class="line"></span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: url.getCategorySubList,</span><br><span class="line">      method: <span class="string">'post'</span>,</span><br><span class="line">      data: &#123; <span class="attr">categoryId</span>: categoryId &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//console.log(response)</span></span><br><span class="line">        <span class="keyword">if</span> (response.data.code == <span class="number">200</span> &amp;&amp; response.data.message) &#123;</span><br><span class="line">          <span class="keyword">this</span>.categorySub = response.data.message</span><br><span class="line">          <span class="keyword">this</span>.active = <span class="number">0</span></span><br><span class="line">          <span class="keyword">this</span>.categorySubId = <span class="keyword">this</span>.categorySub[<span class="number">0</span>].ID</span><br><span class="line">          <span class="keyword">this</span>.onLoad()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Toast(<span class="string">'服务器错误，数据取得失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.categorySubId = <span class="keyword">this</span>.categorySubId?<span class="keyword">this</span>.categorySubId:<span class="keyword">this</span>.categorySub[<span class="number">0</span>].ID</span><br><span class="line">      <span class="keyword">this</span>.getGoodList()</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onRefresh() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isRefresh = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">this</span>.finished = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">this</span>.goodList=[]</span><br><span class="line">      <span class="keyword">this</span>.page=<span class="number">1</span></span><br><span class="line">      <span class="keyword">this</span>.onLoad()</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取商品列表</span></span><br><span class="line">  getGoodList() &#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: url.getGoodsListByCategorySubID,</span><br><span class="line">      method: <span class="string">'post'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        categorySubId: <span class="keyword">this</span>.categorySubId,</span><br><span class="line">        page: <span class="keyword">this</span>.page</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response)</span><br><span class="line">        <span class="keyword">if</span> (response.data.code == <span class="number">200</span> &amp;&amp; response.data.message.length) &#123;</span><br><span class="line">          <span class="keyword">this</span>.page++</span><br><span class="line">          <span class="keyword">this</span>.goodList = <span class="keyword">this</span>.goodList.concat(response.data.message)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.finished = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.finished)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//点击子类获取商品信息</span></span><br><span class="line">  onClickCategorySub(index, title) &#123;</span><br><span class="line">    <span class="comment">//console.log( this.categorySub)</span></span><br><span class="line">    <span class="keyword">this</span>.categorySubId = <span class="keyword">this</span>.categorySub[index].ID</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.categorySubId)</span><br><span class="line">    <span class="keyword">this</span>.goodList = []</span><br><span class="line">    <span class="keyword">this</span>.finished = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.page = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.onLoad()</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>复习CSS的笔记</title>
    <url>/2019/10/15/%E5%A4%8D%E4%B9%A0CSS%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="复习CSS的笔记"><a href="#复习CSS的笔记" class="headerlink" title="复习CSS的笔记"></a>复习CSS的笔记</h1><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p><em>html</em></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><ul><li>使用flex方法</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: deepskyblue;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="comment">/* 实现元素水平居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="comment">/* 实现元素垂直居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CSS 移动外边距方法</li></ul><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571047255135.png" alt="1571047255135"></p><p>使用absolute百分比移动时，是按左上角点移动的，修正宽高的一半</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="comment">/* 下面两种方式均可 */</span></span><br><span class="line">  <span class="comment">/* margin-top: -50px;</span></span><br><span class="line"><span class="comment">  margin-left: -50px; */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到正确图形</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571047448336.png" alt="1571047448336"></p><h3 id="引用CSS方式"><a href="#引用CSS方式" class="headerlink" title="引用CSS方式"></a>引用CSS方式</h3><ul><li><strong>行内样式</strong></li></ul><p>直接对 HTML 的标记使用 style 属性，然后将 CSS 代码直接写进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;color: #fff; backgournd: deepskyblue;&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>内嵌式</strong></li></ul><p>将 CSS 写 <code>&lt;head&gt;</code> 与 <code>&lt;/head&gt;</code> 之间，并且用 <code>&lt;style&gt;</code> 和 <code>&lt;/style&gt;</code> 标记进行声明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    p &#123;</span><br><span class="line">      color: #fff;</span><br><span class="line">      background: deepskyblue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>链接式</strong></li></ul><p>通过将 <code>&lt;style&gt;</code> 上的 CSS 提起到指定的 CSS 文件上，然后通过 <code>&lt;link&gt;</code> 的方式在 HTML 上链接起来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link href=&quot;reset.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>导入样式</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    @import url(reset.css);</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>各种方式的优先级</strong></li></ul><p>在优先级上，<strong>行内样式</strong> &gt; <strong>链接式</strong> &gt; <strong>内嵌式</strong> &gt; <strong>@import 导入式</strong>。</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ul><li>CSS 解析顺序</li></ul><p>在 CSS 的选择器中，它会按照优先级 <strong>从右向左解析</strong>，因为这样匹配元素的时候，能尽量少地查找，所以选择器最好写地简洁一点。</p><ul><li>CSS 常用选择器</li></ul><ol><li>通配符：<code>*</code></li><li>ID 选择器：<code>#ID</code></li><li>类选择器：<code>.class</code></li><li>元素选择器：<code>p</code>、<code>a</code> 等……</li><li>后代选择器：<code>p span</code>、<code>div a</code> 等……</li><li>子选择器： <code>ul&gt;li</code></li><li>伪类选择器：<code>a:hover li:nth-child</code> 等……</li><li>属性选择器：<code>input[type=&quot;text&quot;]</code> 等……</li><li>子元素选择器：<code>li:firth-child</code>、<code>p:nth-child(1)</code> 等……</li></ol><ul><li>CSS 选择器权重</li></ul><p>!important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认</p><h3 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h3><ul><li>优先使用flex</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: flex-end;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        flex: 1;</span><br><span class="line">        background: green;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line">        background: red;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>自适应自适应自适应自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>固定固定固定固定固定固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571126095796.png" alt="1571126095796"></p><ul><li>左侧浮动，右侧设置margin-left 空出左侧宽度</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">     float: left;</span><br><span class="line">     width: 200px;</span><br><span class="line">     background: green;</span><br><span class="line">     height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">margin-left</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">      background: red;</span><br><span class="line">      height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571126444923.png" alt="1571126444923"></p><h3 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h3><ul><li>flex版本</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">        background: green;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        background: red;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">         flex: 1;</span><br><span class="line">         background: yellow;</span><br><span class="line">         height: 200px;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>普通版同两列一样，左右浮动，中间板块margin出左右的宽度</li></ul><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>margin负一下，左右两边顶上来，中间设个padding</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">   header&#123;</span><br><span class="line">       background: cadetblue;</span><br><span class="line">   &#125;</span><br><span class="line">   footer&#123;</span><br><span class="line">       background: antiquewhite;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">       width: 100%;</span><br><span class="line">       background: coral;</span><br><span class="line">		height: 200px;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.main</span>&#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background: yellow;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.mianChild</span>&#123;</span></span><br><span class="line">        padding: 0 100px 0 200px;</span><br><span class="line">        background: yellow;</span><br><span class="line"><span class="css">		<span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">        background: green;</span><br><span class="line"><span class="css">		<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        background: red;</span><br><span class="line"><span class="css">		<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>我是头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mianChild"</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>我是底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571127881156.png" alt="1571127881156"></p><ul><li>使用flex布局跟上面一样<code>justify-content: space-between;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">   header&#123;</span><br><span class="line">       background: cadetblue;</span><br><span class="line">   &#125;</span><br><span class="line">   footer&#123;</span><br><span class="line">       background: antiquewhite;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">       background: coral;</span><br><span class="line">		height: 200px;</span><br><span class="line"><span class="css">		<span class="selector-tag">display</span><span class="selector-pseudo">:flex</span>;</span></span><br><span class="line">		justify-content: space-between;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.main</span>&#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">        background: yellow;</span><br><span class="line">         flex: 1;</span><br><span class="line">         height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">        background: green;</span><br><span class="line"><span class="css">		<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        background: red;</span><br><span class="line"><span class="css">		<span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>我是头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mianChild"</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>我是底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="em-和-rem"><a href="#em-和-rem" class="headerlink" title="em 和 rem"></a>em 和 rem</h3><ul><li>em相对容器字体大小，容器没设置大小往父元素找</li></ul><blockquote><p>CSS继承：字体样式通常可以继承，尺寸相关样式不能继承</p></blockquote><ul><li>rem相对根元素（html元素）字体大小</li></ul><h3 id="行内元素和行内块元素"><a href="#行内元素和行内块元素" class="headerlink" title="行内元素和行内块元素"></a>行内元素和行内块元素</h3><p>都是同行显示，</p><ul><li>行内元素 <code>display:inline</code>不可设置宽高</li><li>行内块元素<code>display:inline-block</code>可以设置宽高</li></ul><h3 id="BFC-Block-Formatting-Context-块级格式化上下文"><a href="#BFC-Block-Formatting-Context-块级格式化上下文" class="headerlink" title="BFC(Block Formatting Context 块级格式化上下文)"></a>BFC(Block Formatting Context 块级格式化上下文)</h3><blockquote><p>在BFC中，每一个盒子（子元素）的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄）。</p></blockquote><p><strong>BFC的特征</strong></p><p>（1）所有子元素（包含浮动元素）与容器（父元素）左边对齐</p><p>（2）属于同一个BFC的父元素和子元素，相邻的父子或者兄弟间margin垂直方向会重叠，若2个元素属于不同的BFC，则垂直方向不会重叠</p><p>（3）可以自动撑开容器（若子元素是float的，父元素设置<code>overflow:hidden</code>，父元素就形成一个BFC）</p><p><strong>创建BFC</strong>，满足下列的任意一个或多个条件即可：</p><p>1、float的值不是none。（float:left 或者float:right）</p><p>2、position的值不是static或者relative。（position:absolute或者position:fixed）</p><p>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex</p><p>4、overflow的值不是visible（overflow:hidden、overflow:scroll）</p><p>5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个BFC</p><h3 id="box-sizing的属性"><a href="#box-sizing的属性" class="headerlink" title="box-sizing的属性"></a>box-sizing的属性</h3><ul><li><code>content-box</code> W3C标准盒模型 设置width/height属性是指<strong>content</strong>部分</li><li><code>border-box</code> IE传统盒模型 设置width/height属性包括了<strong>content+padding+border</strong></li></ul><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571130210731.png" alt="1571130210731"></p><h3 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 1<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 2<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_transition-property.asp" target="_blank" rel="noopener">transition-property</a></th><th>规定应用过渡的 CSS 属性的名称。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-duration.asp" target="_blank" rel="noopener">transition-duration</a></td><td>定义过渡效果花费的时间。默认是 0。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp" target="_blank" rel="noopener">transition-timing-function</a></td><td>规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-delay.asp" target="_blank" rel="noopener">transition-delay</a></td><td>规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><p>分别对标四个属性 解释：过渡宽度 过程一秒 匀速 延迟两米奥</p><h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><p><a href="https://www.runoob.com/cssref/css-animatable.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/css-animatable.html</a></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span><span class="selector-pseudo">:myfirst</span> 5<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>:blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>:green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@keyframes 加一个动画名， 前边百分号表示时间节点</p><h3 id="超出宽度的文字省略号"><a href="#超出宽度的文字省略号" class="headerlink" title="超出宽度的文字省略号"></a>超出宽度的文字省略号</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item-name</span>&#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">width</span>:X em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多少em就是多少个字</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/CSS_review/1571132042889.png" alt="1571132042889"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端, css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（六）登陆</title>
    <url>/2019/10/10/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%85%AD%EF%BC%89%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（六）登陆"><a href="#vue-js商城项目（六）登陆" class="headerlink" title="vue.js商城项目（六）登陆"></a>vue.js商城项目（六）登陆</h1><h3 id="在User-js进行一个比较密码的函数封装"><a href="#在User-js进行一个比较密码的函数封装" class="headerlink" title="在User.js进行一个比较密码的函数封装"></a>在User.js进行一个比较密码的函数封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">userSchema.methods = &#123;</span><br><span class="line">        <span class="comment">//密码比对的方法</span></span><br><span class="line">        comparePassword: <span class="function">(<span class="params">_password, password</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                bcrypt.compare(_password, password, (err, isMatch) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!err) resolve(isMatch)</span><br><span class="line">                    <span class="keyword">else</span> reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="进行接口的封装"><a href="#进行接口的封装" class="headerlink" title="进行接口的封装"></a>进行接口的封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/login'</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">//得到前端传递过来的数据</span></span><br><span class="line">    <span class="keyword">let</span> loginUser = ctx.request.body</span><br><span class="line">    <span class="built_in">console</span>.log(loginUser)</span><br><span class="line">    <span class="keyword">let</span> userName = loginUser.userName</span><br><span class="line">    <span class="keyword">let</span> password = loginUser.password</span><br><span class="line">        <span class="comment">//引入User的model</span></span><br><span class="line">    <span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>)</span><br><span class="line">        <span class="comment">//查找用户名是否存在，如果存在开始比对密码</span></span><br><span class="line">    <span class="keyword">await</span> User.findOne(&#123; <span class="attr">userName</span>: userName &#125;).exec().then(<span class="keyword">async</span>(result) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">//console.log(User)</span></span><br><span class="line">            <span class="comment">//当用户名存在时，开始比对密码</span></span><br><span class="line">            <span class="keyword">let</span> newUser = <span class="keyword">new</span> User() <span class="comment">//因为是实例方法，所以要new出对象，才能调用</span></span><br><span class="line">            <span class="keyword">await</span> newUser.comparePassword(password, result.password)</span><br><span class="line">                .then(<span class="function">(<span class="params">isMatch</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//返回比对结果</span></span><br><span class="line">                    ctx.body = &#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: isMatch &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//出现异常，返回异常</span></span><br><span class="line">                    <span class="built_in">console</span>.log(error)</span><br><span class="line">                    ctx.body = &#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">message</span>: error &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.body = &#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'用户名不存在'</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">        ctx.body = &#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">message</span>: error &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="前台axios请求"><a href="#前台axios请求" class="headerlink" title="前台axios请求"></a>前台axios请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.$axios</span><br><span class="line">    .post(url.login, &#123;</span><br><span class="line">      userName: <span class="keyword">this</span>.username,</span><br><span class="line">      password: <span class="keyword">this</span>.password</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response);</span><br><span class="line">      <span class="keyword">if</span> (response.data.code == <span class="number">200</span> &amp;&amp; response.data.message) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          localStorage.userInfo = &#123; <span class="attr">userName</span>: <span class="keyword">this</span>.username &#125;;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;, <span class="number">500</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            Toast.success(<span class="string">"登录成功"</span>);</span><br><span class="line">            <span class="keyword">this</span>.$router.push(<span class="string">"/"</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            Toast.fail(<span class="string">"登陆状态保存失败"</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.fail(<span class="string">"登录失败"</span>);</span><br><span class="line">        <span class="keyword">this</span>.openLoading = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">      Toast.fail(<span class="string">"登录失败"</span>);</span><br><span class="line">      <span class="keyword">this</span>.openLoading = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="验证登陆自动跳转"><a href="#验证登陆自动跳转" class="headerlink" title="验证登陆自动跳转"></a>验证登陆自动跳转</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">   <span class="keyword">if</span>(localStorage.userInfo)&#123;</span><br><span class="line">     Toast.success(<span class="string">'已经登陆'</span>)</span><br><span class="line">     <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（五）加密</title>
    <url>/2019/09/25/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%94%EF%BC%89%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（五）加密"><a href="#vue-js商城项目（五）加密" class="headerlink" title="vue.js商城项目（五）加密"></a>vue.js商城项目（五）加密</h1><h3 id="加盐处理"><a href="#加盐处理" class="headerlink" title="加盐处理"></a>加盐处理</h3><p>把原来的密码里，加入一些其他的字符串，并且我们可以自己设置加入字符串的强度</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>我们使用的MD5加密或者hash256加密算法，其实他们都是hash的算法。就是把你的密码进行一次不可逆的编译，这样就算别人得到了这个密码值，也不能进行直接登录操作</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="安装与使用bcrypt"><a href="#安装与使用bcrypt" class="headerlink" title="安装与使用bcrypt"></a>安装与使用bcrypt</h3><p><code>npm i bcryptjs --save</code></p><p>安装bcryptjs 由js编写可以防止依赖错误，原生的有依赖visual stido ，python</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">userSchema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        bcrypt.genSalt(SALT_WORK_FACTOR, (err, salt) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err)</span><br><span class="line">            bcrypt.hash(<span class="keyword">this</span>.passWord, salt, (err, hash) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err)</span><br><span class="line">                <span class="keyword">this</span>.passWord = hash</span><br><span class="line">                next()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（四）(后台准备)</title>
    <url>/2019/09/25/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（四）-后台准备"><a href="#vue-js商城项目（四）-后台准备" class="headerlink" title="vue.js商城项目（四）(后台准备)"></a>vue.js商城项目（四）(后台准备)</h1><blockquote><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="打开mongo数据库服务"><a href="#打开mongo数据库服务" class="headerlink" title="打开mongo数据库服务"></a>打开mongo数据库服务</h3><p><code>mongod -dbpath E:\mongodb\data\db</code></p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> db = <span class="string">"mongodb://localhost/shoppingMall"</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">exports.initSchemas = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    glob.sync(resolve(__dirname, <span class="string">'./schema'</span>, <span class="string">'**/*.js'</span>)).forEach(<span class="built_in">require</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.connect = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    mongoose.connect(db, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxConnectTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//把所有连接放到这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加数据库监听事件</span></span><br><span class="line">        mongoose.connection.on(<span class="string">'disconnected'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'***********数据库断开***********'</span>)</span><br><span class="line">            <span class="keyword">if</span> (maxConnectTimes &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                maxConnectTimes++</span><br><span class="line">                mongoose.connect(db)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject()</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数据库出现问题，程序无法搞定，请人为修理......'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        mongoose.connection.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'***********数据库错误***********'</span>)</span><br><span class="line">                <span class="keyword">if</span> (maxConnectTimes &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    maxConnectTimes++</span><br><span class="line">                    mongoose.connect(db)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数据库出现问题，程序无法搞定，请人为修理......'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//链接打开的时</span></span><br><span class="line">        mongoose.connection.once(<span class="string">'open'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'MongoDB connected successfully'</span>)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义schema"><a href="#定义schema" class="headerlink" title="定义schema"></a>定义schema</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"><span class="keyword">let</span> ObjectId = Schema.Types.ObjectId</span><br><span class="line">    <span class="comment">//创建schema</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">        UserId: ObjectId,</span><br><span class="line">        userName: &#123; <span class="attr">unique</span>: <span class="literal">true</span>, <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">        passWord: <span class="built_in">String</span>,</span><br><span class="line">        createAt: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now() &#125;,</span><br><span class="line">        lastLoginAt: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now() &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//发布模型</span></span><br><span class="line">mongoose.model(<span class="string">'User'</span>, userSchema)</span><br></pre></td></tr></table></figure><h3 id="测试插入，查询"><a href="#测试插入，查询" class="headerlink" title="测试插入，查询"></a>测试插入，查询</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> &#123; connect, initSchemas &#125; = <span class="built_in">require</span>(<span class="string">'./database/init.js'</span>)</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> connect()</span><br><span class="line">    initSchemas()</span><br><span class="line">    <span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>)</span><br><span class="line">    <span class="keyword">let</span> oneUser = <span class="keyword">new</span> User(&#123; <span class="attr">userName</span>: <span class="string">'jason'</span>, <span class="attr">passWord</span>: <span class="string">'123456'</span> &#125;)</span><br><span class="line">    oneUser.save().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'插入成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> users = <span class="keyword">await</span> User.findOne(&#123;&#125;).exec()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'------------------'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(users)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">'&lt;h1&gt;hello koa&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[Server] starting port 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>这些都是基本设置，之前学过</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（三）</title>
    <url>/2019/09/22/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（三）"><a href="#vue-js商城项目（三）" class="headerlink" title="vue.js商城项目（三）"></a>vue.js商城项目（三）</h1><h3 id="（filter）精度价格"><a href="#（filter）精度价格" class="headerlink" title="（filter）精度价格"></a>（filter）精度价格</h3><blockquote><p>在很多电商项目中，有许多价格标签需要精确到小数点后两位。</p></blockquote><p><strong>创建一个js文件</strong></p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toMoney</span>(<span class="params">money = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> money.toFixed(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精确到小数点后两位</p><p><strong>在需要的文件引入</strong></p><p><code>import {toMoney} from &quot;@/filter/moneyFilter.js&quot;</code></p><p>script中写filter方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line"></span><br><span class="line">    moneyFilter(money)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> toMoney(money)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$&#123;&#123;item.price | moneyFilter&#125;&#125;($&#123;&#123;item.mallPrice | moneyFilter&#125;&#125;)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568899469165.png" alt="1568982154665"></p><hr><h3 id="分离URL"><a href="#分离URL" class="headerlink" title="分离URL"></a>分离URL</h3><p><strong>创立一个独立的配置文件，当域名需要修改的时候，只需修改一次</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BASEURL = <span class="string">"http://localhost:3001/"</span></span><br><span class="line"><span class="keyword">const</span> URL = &#123;</span><br><span class="line">    getShoppingMallInfo: BASEURL + <span class="string">'data'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = URL</span><br></pre></td></tr></table></figure><p>在需要的组件中引入</p><p><code>import url from &quot;@/serviceAPI.config.js&quot;</code></p><p>在axios中直接获取暴露的url</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    axios(&#123;</span><br><span class="line"></span><br><span class="line">​      url: url.getShoppingMallInfo,</span><br><span class="line"></span><br><span class="line">​      method: <span class="string">"get"</span></span><br><span class="line"></span><br><span class="line">​    &#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（二）（楼层导航）</title>
    <url>/2019/09/19/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（二）（楼层导航）"><a href="#vue-js商城项目（二）（楼层导航）" class="headerlink" title="vue.js商城项目（二）（楼层导航）"></a>vue.js商城项目（二）（楼层导航）</h1><blockquote><p>轮播图在上个笔记讲了，可以用vant内置轮播图组件也可以用swiper组件,组件化形式写一个楼层推荐</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="首页布局"><a href="#首页布局" class="headerlink" title="首页布局"></a>首页布局</h3><p><strong>先看效果图，大概就是这样</strong></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568898689120.png" alt="1568898689120"></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568898707521.png" alt="1568898707521"></p><p>index.js引入路由</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ShoppingMall <span class="keyword">from</span> <span class="string">'@/components/pages/ShoppingMall'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        name: <span class="string">'ShoppingMall'</span>,</span><br><span class="line">        component: ShoppingMall</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="jsonServer模块模拟json数据"><a href="#jsonServer模块模拟json数据" class="headerlink" title="jsonServer模块模拟json数据"></a>jsonServer模块模拟json数据</h3><p>（1）安装</p><blockquote><p>$ npm install -g json-server</p></blockquote><p>（2）使用</p><ul><li><p>创建json文件db.json，把需要的数据写进来</p></li><li><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1568899075948.png" alt="1568899075948"></p></li><li><p>使用全局json-server命令，启动mock服务。这个mock服务，管理的数据，就是db.json。</p><blockquote><p>$ json-server –watch –port 3001 db.json</p></blockquote></li></ul><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568898999140.png" alt="1568898999140"></p><h3 id="使用axios获取数据"><a href="#使用axios获取数据" class="headerlink" title="使用axios获取数据"></a>使用axios获取数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">     url: <span class="string">"http://localhost:3001/data"</span>,</span><br><span class="line">     method: <span class="string">"get"</span></span><br><span class="line">   &#125;)</span><br><span class="line">     .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(response);</span><br><span class="line">       <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.category = response.data.category;</span><br><span class="line">         <span class="keyword">this</span>.advertesPicture = response.data.advertesPicture.PICTURE_ADDRESS;</span><br><span class="line">         <span class="keyword">this</span>.recommendGoods = response.data.recommend;</span><br><span class="line">         <span class="keyword">this</span>.floorName = response.data.floorName</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.floorName)&#123;</span><br><span class="line">           <span class="keyword">this</span>.floorContent[key] = response.data[key]</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(error)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p>视频老师给的json数据，获取各种信息</p><h3 id="楼层组件化"><a href="#楼层组件化" class="headerlink" title="楼层组件化"></a>楼层组件化</h3><p><strong>父组件遍历</strong></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568899469165.png" alt="1568899469165"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 楼层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in floorName"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">floorComponent</span> <span class="attr">:floorData</span>=<span class="string">"floorContent[index]"</span> <span class="attr">:floorTitle</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">floorComponent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>v-for</code>遍历这样json数据添加任意个楼层任意个数据都能遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.floorName = response.data.floorName</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.floorName)&#123;</span><br><span class="line">  <span class="keyword">this</span>.floorContent[key] = response.data[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先取到楼层名对象，然后遍历，</p><p><code>response.data[key]</code>用变量取对象的值必须使用方括号[变量]</p><p><strong>通过props传递给子组件</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floor-rule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"floorData0.image"</span> <span class="attr">width</span>=<span class="string">"100%"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in floorData.slice(1)"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item.image"</span> <span class="attr">width</span>=<span class="string">"100%"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一个图片最大拎出来，然后再遍历<code>.slice(1)</code>截取第一个以后的对象</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>swiper组件使用</title>
    <url>/2019/09/18/swiper%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="swiper组件使用"><a href="#swiper组件使用" class="headerlink" title="swiper组件使用"></a>swiper组件使用</h1><hr><h3 id="引入-vue-awesome-swiper-的两种方式"><a href="#引入-vue-awesome-swiper-的两种方式" class="headerlink" title="引入 vue-awesome-swiper 的两种方式"></a>引入 vue-awesome-swiper 的两种方式</h3><ul><li>全局引入</li></ul><p>可以直接使用全局引入，引入代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueAwesomeSwiper <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// require styles</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/dist/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper, <span class="comment">/* &#123; default global options &#125; */</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><ul><li>以组件形式引入</li></ul><p>这种方式是在需要的页面以<code>component</code> 的形式引入，好处就是依赖性不强。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'swiper/dist/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; swiper, swiperSlide &#125; <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    swiper,</span><br><span class="line">    swiperSlide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="一个简单的轮播图"><a href="#一个简单的轮播图" class="headerlink" title="一个简单的轮播图"></a>一个简单的轮播图</h3><p>新建一个<code>swiperDefault.vue</code>文件。写入如下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;swiper :options=<span class="string">"swiperOption"</span>&gt;</span><br><span class="line">      &lt;swiper-slide <span class="class"><span class="keyword">class</span></span>=<span class="string">"swiper-slide"</span> v-<span class="keyword">for</span>=<span class="string">"(item, index) in slide"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">          Slide &#123;&#123;item&#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/swiper&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import "vue-awesome-swiper/</span>node_modules/swiper/dist/css/swiper.css<span class="string">"</span></span><br><span class="line"><span class="string">import &#123; swiper, swiperSlide &#125; from "</span>vue-awesome-swiper<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      slide: [1, 2, 3, 4, 5, 6],</span></span><br><span class="line"><span class="string">      swiperOption:&#123;</span></span><br><span class="line"><span class="string">        swiperOption:&#123;</span></span><br><span class="line"><span class="string">        // 滑动最后页进入第一页</span></span><br><span class="line"><span class="string">        loop:true,</span></span><br><span class="line"><span class="string">          pagination:&#123;</span></span><br><span class="line"><span class="string">              el:'.swiper-pagination',</span></span><br><span class="line"><span class="string">              // 可以点击</span></span><br><span class="line"><span class="string">              clickable:true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  components: &#123; swiper, swiperSlide &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">.swiper-slide &#123;</span></span><br><span class="line"><span class="string">  height: 4rem;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  padding-top: 3rem;</span></span><br><span class="line"><span class="string">  border-bottom: 1px solid #ccc;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>代码写好后，在<code>.vue</code>文件里进行引入使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> swiperDefault <span class="keyword">from</span> <span class="string">'../swiper/swiperDefault'</span></span><br></pre></td></tr></table></figure><p>然后注册组件,其实上节课的代码也是可以封装成一个component的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;swiper,swiperSlide,swiperDefault&#125;,</span><br></pre></td></tr></table></figure><p>注册好后，直接在<code>template</code>里使用就可以了.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;swiperDefault&gt;&lt;/swiperDefault&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1568809332660.png" alt="1568809332660"></p><h4 id="竖屏切换效果"><a href="#竖屏切换效果" class="headerlink" title="竖屏切换效果"></a>竖屏切换效果</h4><p>在配置项里直接配置<code>direction</code>就可以了，配置竖屏代码如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">swiperOption:&#123;</span><br><span class="line">    direction:<span class="string">'vertical'</span>,</span><br></pre></td></tr></table></figure><h3 id="区域滚动效果"><a href="#区域滚动效果" class="headerlink" title="区域滚动效果"></a>区域滚动效果</h3><p>加入上划下拉的组件，在一定区域内局部可以滚动，如文章，或者广告</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;swiper <span class="class"><span class="keyword">class</span></span>=<span class="string">"swiper"</span> :options=<span class="string">"swiperOption"</span>&gt;</span><br><span class="line">            &lt;swiper-slide <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span>&gt;</span><br><span class="line">                &lt;div&gt;大段文章...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>swiper-slide&gt;</span><br><span class="line">        &lt;<span class="regexp">/swiper&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import "vue-awesome-swiper/</span>node_modules/swiper/dist/css/swiper.css<span class="string">"</span></span><br><span class="line"><span class="string">import &#123; swiper, swiperSlide &#125; from "</span>vue-awesome-swiper<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      swiperOption:&#123;</span></span><br><span class="line"><span class="string">            // 竖屏滚动</span></span><br><span class="line"><span class="string">            direction:'vertical',</span></span><br><span class="line"><span class="string">            // 一屏之内swiperslide数量</span></span><br><span class="line"><span class="string">            slidesPerView: 'auto',</span></span><br><span class="line"><span class="string">            // 滑动不自动贴合</span></span><br><span class="line"><span class="string">            freeMode: true,</span></span><br><span class="line"><span class="string">            // 鼠标滚轮控制</span></span><br><span class="line"><span class="string">            mousewheel:true</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  components: &#123; swiper, swiperSlide &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string">.swiper&#123;</span></span><br><span class="line"><span class="string">    height: 300px;</span></span><br><span class="line"><span class="string">    overflow: hidden;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.text&#123;</span></span><br><span class="line"><span class="string">    font-size:18px;</span></span><br><span class="line"><span class="string">    text-align: left;</span></span><br><span class="line"><span class="string">    padding: 30px;</span></span><br><span class="line"><span class="string">    height: auto;</span></span><br><span class="line"><span class="string">    box-sizing: border-box;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p><strong>更多效果请访问swiper 官方API，手写原生js轮播图请看我的淘宝静态首页项目</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue, 前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js商城项目（一）（前期准备）</title>
    <url>/2019/09/15/vue.js%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="vue-js商城项目（一）（前期准备）"><a href="#vue-js商城项目（一）（前期准备）" class="headerlink" title="vue.js商城项目（一）（前期准备）"></a>vue.js商城项目（一）（前期准备）</h1><blockquote><p>vue 的基础知识也学习完了，跟着视频教程做了几个小demo，想结合之前学过的node，做一个综合性的商城项目</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="前端开发环境搭建"><a href="#前端开发环境搭建" class="headerlink" title="前端开发环境搭建"></a>前端开发环境搭建</h3><p><strong><em>1.使用vue-cli生成项目目录</em></strong></p><p>打开<code>VScode</code>创建文件夹</p><ul><li>全局安装vue-cli，在终端里输入，<code>npm install vue-cli -g</code>全局安装</li><li>在终端中输入 <code>vue install</code>，引入依赖模块</li><li>在终端中输入 <code>vue init webpack</code></li></ul><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1568534019828.png" alt="1568534019828"></p><p>国内网络不行请使用国内镜像<code>cmpn</code></p><p><strong><em>2.测试环境是否安装成功</em></strong></p><ul><li>使用<code>npm run dev</code> 进行测试环境的打开。</li><li>在浏览器中输入 <code>http://localhost:8080</code> 进行测试。</li></ul><p><strong>成功页</strong></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/vue_shopping/1568534068722.png" alt="1568534068722"></p><hr><h3 id="引入Vant组件库"><a href="#引入Vant组件库" class="headerlink" title="引入Vant组件库"></a>引入Vant组件库</h3><p>vant是有赞前端团队提供的Vue组件库。</p><p>终端输入<code>cnpm i vant -S</code>安装</p><p>没有cnpm 直接使用淘宝源<code>npm install 项目名 --save --registry=https://registry.npm.taobao.org</code></p><p><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a> 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">npm i babel-plugin-import -D</span><br><span class="line">// 在.babelrc 中添加配置</span><br><span class="line">// 注意：webpack 1 无需设置 libraryDirectory</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'import'</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">'vant'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="string">'vant'</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">// 接着你可以在代码中直接引入 Vant 组件</span><br><span class="line">// 插件会自动将代码转化为方式二中的按需引入形式</span><br><span class="line">import &#123; Button &#125; from <span class="string">'vant'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><p><code>rem</code>（font size of the root element）是相对长度单位。相对于<strong>根元素</strong>（即html元素）<code>font-size</code><strong>字体大小</strong>计算值的倍数。<strong>em相对于父元素，rem相对于根元素</strong></p><p>使用js适配，主流移动端web适配方案</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到手机屏幕的宽度</span></span><br><span class="line"><span class="keyword">let</span> htmlWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="comment">//得到html的Dom元素</span></span><br><span class="line"><span class="keyword">let</span> htmlDom = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//设置根元素字体大小,iphone678屏幕宽度375px标准375/16</span></span><br><span class="line">htmlDom.style.fontSize = htmlWidth / <span class="number">23.4375</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>初识KOA（上）</title>
    <url>/2019/08/07/2019-8-6%20%E5%88%9D%E8%AF%86KOA/</url>
    <content><![CDATA[<h1 id="初识KOA（上）"><a href="#初识KOA（上）" class="headerlink" title="初识KOA（上）"></a>初识KOA（上）</h1><blockquote><p>新一代node框架入门，前置知识：node基础,数据库基础，了解Koa怎么搭建服务器的,不适合通读，<strong>推荐跟文章实际操作</strong>（手把手教学）</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>如果有<strong>知识点</strong>未知请看：</p><p><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a><br><a href="https://koa.bootcss.com/" target="_blank" rel="noopener">koa文档</a><br><a href="https://juejin.im/post/5c0397186fb9a049b5068e54" target="_blank" rel="noopener">前端er，你真的会用 async 吗？</a><br><a href="https://juejin.im/post/5d116ae5518825328779c9d5" target="_blank" rel="noopener">async/await 应知应会</a><br><a href="https://juejin.im/post/5b9db6925188255c3b7d78cb" target="_blank" rel="noopener">如何避开 async/await 地狱</a></p><p>之前对JS异步,这一块有点生疏，多看点博客</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p><p><strong>1.新建文件夹</strong></p><p>初始化package.json，终端输入</p><p><code>npm init --yes</code></p><p><strong>2.下载KOA</strong></p><p>终端输入<code>cnpm install koa</code></p><p>当前文件夹下会出来node_moudules，模块依赖包</p><p><strong>3.安装nodemon</strong></p><p>它会监测项目中的所有文件，一旦发现文件有改动，Nodemon 会自动重启应用</p><p><code>cnpm install nodemon -D</code> -g 安装全局</p><p><strong>4.在package.json中配置nodemon</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">      "start": "nodemon app.js"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>5.在文件夹中新建文件<code>app.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Server started...'</span>))</span><br></pre></td></tr></table></figure><p><strong>6.终端输入<code>nodemon app.js</code>测试启动</strong></p><p>搭建服务器成功</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565091025993.png" alt="1565091025993"></p><p><strong>7.测试导入一个koa 模块 <code>koa-json</code></strong></p><p>终端下载<code>cnpm install koa-json</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">'koa-json'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(json())</span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; (ctx.body = &#123; <span class="attr">msg</span>: <span class="string">'Hello world!'</span> &#125;))</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Server started...'</span>))</span><br></pre></td></tr></table></figure><p>在浏览器查看，出现json</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565097503676.png" alt="1565097503676"></p><p><strong>8. <code>app.context</code></strong></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565097690435.png" alt="1565097690435"></p><p><strong>9.路由模块 Koa-router</strong></p><p>终端输入<code>cnpm install koa-router</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//引入模块，实例化</span></span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line">   <span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter()</span><br><span class="line">   router.get(<span class="string">'/test'</span>, ctx =&gt; (ctx.body = <span class="string">'hello Router!'</span>))</span><br><span class="line">       <span class="comment">//配置路由模块</span></span><br><span class="line">   app.use(router.routes()).use(router.allowedMethods())</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565098676663.png" alt="1565098676663"></p><p><strong>10.如果引入HTML的话，需要模板引擎ejs</strong></p><p>终端输入<code>cnpm install koa-ejs</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> render = <span class="built_in">require</span>(<span class="string">'koa-ejs'</span>)</span><br><span class="line"><span class="comment">//配置模板引擎</span></span><br><span class="line">render(app, &#123;</span><br><span class="line">    <span class="comment">//当前路径的views文件夹</span></span><br><span class="line">    root: path.join(__dirname, <span class="string">'views'</span>),</span><br><span class="line">    layout: <span class="string">'layout'</span>,</span><br><span class="line">    viewExt: <span class="string">'html'</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,</span><br><span class="line">    debug: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由跳转</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        title: <span class="string">'I love node'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//layout.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">title</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565101335597.png" alt="1565101335597"></p><p><strong>11.数据传递和渲染</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟数据</span></span><br><span class="line"><span class="keyword">const</span> things = [&#123;<span class="attr">name</span>:<span class="string">'friends'</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">'family'</span>&#125;]</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        title: <span class="string">'I love node'</span>,</span><br><span class="line">        things: things</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">title</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">things.forEach</span>(<span class="attr">thing</span> =&gt;</span>&#123; %&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">%=</span> <span class="attr">thing</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565161017644.png" alt="1565161017644"></p><p><strong>12.导航和添加内容</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/add'</span>, showAdd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">showAdd</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'add'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件夹<code>partials</code>navBar.html</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565184485779.png" alt="1565184485779"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//add</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"display-4 mb-4"</span>&gt;</span></span><br><span class="line">    添加</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/add"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"thing"</span> <span class="attr">class</span>=<span class="string">"form-control form-control-lg"</span> <span class="attr">placeholder</span>=<span class="string">"随便。。。"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"添加"</span> <span class="attr">class</span>=<span class="string">"btn btn-dark btn-lg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"btn btn-danger btn-lg"</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//navBar</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-expand-lg navbar-light bg-light mb-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Jason`s App<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"navbar-toggler"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#navbarSupportedContent"</span> <span class="attr">aria-controls</span>=<span class="string">"navbarSupportedContent"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"navbarSupportedContent"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"navbar-nav ml-auto"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">href</span>=<span class="string">"/add"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<code>layout.html</code>body中引入</p><p><code>&lt;% include partials/navBar.html %&gt;</code></p><p>最终效果</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/1565184216539.png" alt="1565184216539"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这篇刚好入门，下一步将要解决如何完善功能和路由参数，本地服务器与刚学的MongoDB，创建测试接口等</p><p>由于不是写网页内容，侧重了解node后端就引用了Bootstrap的CSS样式</p><p>还会有下一篇文章，等我先学一下下，新手入门，高手轻喷。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>node, koa</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>初识MongoDB</title>
    <url>/2019/08/06/MongoDB/</url>
    <content><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><ul><li><p>一个数据库对应多个集合</p><ul><li>一个集合对应多个文档对象</li><li>在mongo中不论是db还是集合，你都无需去创建他</li><li>直接就当他已经存在，直接Use来使用</li><li><strong>把文档比喻成数据库的一行，一个集合相当于一张表</strong><ul><li>use db名称;<ul><li>接着会被切换到该db中</li></ul></li><li><code>db.要创建的集合名称.save({})</code>;这样集合就被创建了</li></ul></li></ul></li><li><p><strong>解决32位异常</strong><br>mongod –dbpath=”路径” –journal –storageEngine=mmapv1</p></li></ul><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><ul><li><p>1:启动服务器</p><ul><li><code>mongod --dbpath &quot;e:/mongodb/data/db&quot;</code> // 目录一定要存在自己创建随便名称‘<ul><li>尽量设置在非系统盘 <code>C盘生成目录是需要权限的</code></li></ul></li><li>如果看到<code>waiting for connections on port 27017</code>说明服务已经启动</li></ul></li><li><p>客户端连接服务器<strong>另开一个命令行</strong></p><ul><li><code>mongo</code> 默认连接的是test数据库</li></ul></li><li><p>查询有哪些数据库</p><ul><li>查询数据库：<code>show dbs;</code></li><li>切换数据库: <code>use 数据库名;</code></li></ul></li><li><p>查询当前db下有哪些集合</p><ul><li><code>show collections;</code></li></ul></li><li><p>查询数据：</p><ul><li><code>db.集合名.find();</code> //查询出来的是文档对象 document<ul><li><code>db.users.find();</code></li><li>查询名字为sun的，<code>db.users.find({name:&quot;sun&quot;});</code></li><li>查询集合中文档数量<code>db.users.find().count()</code></li><li><code>db.users.find({num:{$lte:10}}.skip(10).limit(10))</code>小于等于10,跳过十条，查10条</li><li>lt=less than, ​gt=great than</li><li>查询小于1000 或大于2000的员工，db.empty.find({$or:[sal:{$lt:1000},{sal:{$gt:gt:2000}}]})</li><li><code>db.users.find().sort({id:1，name:1})</code>1表示升序-1表示降序，先比ID，如果一样比名字</li><li><code>db.users.find({},{name:1})</code>只显示名字，可以列出想想显示字段</li></ul></li></ul></li><li><p>插入数据： <code>db.collection.insert({contry:&#39;中国&#39;,name:&#39;小明&#39;,score:77})</code></p><ul><li>插入多条用数组<code>db.student.insert([ {name:&quot;bajie&quot;,age:23}, {name:&quot;shaheshang&quot;,age:66}, ])</code></li></ul></li><li><p>添加数据:</p><ul><li><p><code>db.集合名.save(对象)</code> //mongo默认会给我们加入_id作为该文档对象的唯一标识</p></li><li><p><code>db.users.save({contry:&#39;中国&#39;,name:&#39;小明&#39;,score:77});</code></p></li><li><p><code>db.users.update({name:&#39;小明&#39;},{$push:{contry:&#39;印度&#39;})</code></p></li><li><p><code>db.users.update({name:&#39;小明&#39;},{$addToSet:{contry:&#39;印度&#39;})</code>如果重复不会添加</p></li></ul></li></ul><ul><li><p>删除数据:</p><ul><li><code>db.集合名.remove(条件对象);</code>//条件匹配就会被全部删除</li><li><code>db.users.remove({name:&#39;小明&#39;}，true);</code>只会删除第一个匹配</li><li>如果给定一个空对像，会匹配全部<code>db.集合名.remove({})</code>=这个性能更好<code>db.collection.drop()</code></li><li><code>db.dropDatabase</code>删库</li></ul></li><li><p>更新数据:<strong>默认情况下只修改一个</strong></p><ul><li><p><code>db.集合名.update({匹配条件对象},{$set:{修改后的对象}})</code></p></li><li><p><code>db.users.update({name:&#39;小明&#39;},{$set:{contry:&#39;印度&#39;}})</code></p></li><li><p>修改多个</p><p><code>db.users.updateMany</code></p><p><code>db.users.update({name:&#39;小明&#39;},{$set:{contry:&#39;印度&#39;}}，{multi:true})</code>设置属性</p><p>​ $inc​增加</p></li></ul></li></ul><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	练习：</span><br><span class="line"> 查询姓名为小明的学生</span><br><span class="line">       db.users.find(&#123;name:&apos;小明&apos;&#125;);;   查询英语成绩大于90分的同学</span><br><span class="line">       db.users.find(&#123;score:&#123;$gt:90&#125;&#125;); //查找成绩大于90分$gt</span><br><span class="line">       //$lt小于</span><br><span class="line">查询数学成绩不等于88的同学</span><br><span class="line">       db.users.find(&#123;score:&#123;$ne:88&#125;&#125;);   查询总分大于200分的所有同学</span><br><span class="line">       db.users.find(&#123;score:&#123;$gt:200&#125;&#125;);</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul><li><code>db.users.find().skip(3).limit(3);</code></li><li>db.集合名称.find().跳到3.显示3条<pre><code>+ limit 0,3</code></pre></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><code>db.users.find().sort({key:排序方式});</code></li><li><code>db.users.find().sort({&#39;score&#39;:1});</code> //正数代表升序，负数代表降序</li></ul><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><ul><li><code>db.users.find({name:{$regex:&#39;小&#39;}});</code></li><li><code>db.users.find({name:{$regex:&#39;明&#39;}});</code></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>需要求当前集合的记录数：</li><li><code>db.users.find().count();</code></li><li>求最大值<br>-求整个集合的总成绩<pre><code>+ db.集合名.聚合({ 组的划分规则{_id:&apos;1&apos;,显示内容:{$sum:&apos;$score&apos;}} })</code></pre><ul><li>求所有人的平均分<ul><li><code>db.users.aggregate({$group:{_id:&#39;1&#39;,sumscore:{$avg:&#39;$score&#39; } }});</code></li></ul></li><li>求按国家分组，求所有国家的总分<ul><li><code>db.users.aggregate({$group:{_id:&#39;$contry&#39;,sumScore:{$sum:&#39;$score&#39;}}});</code></li></ul></li></ul></li><li>添加基础数据:<br>db.users.save({contry:’中国’,name:’小明’,score:77});<br>db.users.save({contry:’中国’,name:’小红’,score:88});<br>db.users.save({contry:’中国’,name:’小张’,score:99});<br>db.users.save({contry:’美国’,name:’jack’,score:45});<br>db.users.save({contry:’美国’,name:’rose’,score:67});<br>db.users.save({contry:’美国’,name:’mick’,score:89});</li></ul><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.orders.insert([</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">1</span>, <span class="string">"item"</span> : <span class="string">"almonds"</span>, <span class="string">"price"</span> : <span class="number">12</span>, <span class="string">"quantity"</span> : <span class="number">2</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">2</span>, <span class="string">"item"</span> : <span class="string">"pecans"</span>, <span class="string">"price"</span> : <span class="number">20</span>, <span class="string">"quantity"</span> : <span class="number">1</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">3</span>  &#125;</span><br><span class="line">]);</span><br><span class="line">db.inventory.insert([</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">1</span>, <span class="string">"sku"</span> : <span class="string">"almonds"</span>, <span class="attr">description</span>: <span class="string">"product 1"</span>, <span class="string">"instock"</span> : <span class="number">120</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">2</span>, <span class="string">"sku"</span> : <span class="string">"bread"</span>, <span class="attr">description</span>: <span class="string">"product 2"</span>, <span class="string">"instock"</span> : <span class="number">80</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">3</span>, <span class="string">"sku"</span> : <span class="string">"cashews"</span>, <span class="attr">description</span>: <span class="string">"product 3"</span>, <span class="string">"instock"</span> : <span class="number">60</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">4</span>, <span class="string">"sku"</span> : <span class="string">"pecans"</span>, <span class="attr">description</span>: <span class="string">"product 4"</span>, <span class="string">"instock"</span> : <span class="number">70</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">5</span>, <span class="string">"sku"</span>: <span class="literal">null</span>, <span class="attr">description</span>: <span class="string">"Incomplete"</span> &#125;,</span><br><span class="line">   &#123; <span class="string">"_id"</span> : <span class="number">6</span> &#125;</span><br><span class="line">]);</span><br><span class="line">db.orders.aggregate([</span><br><span class="line">   &#123;</span><br><span class="line">     $lookup:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">"inventory"</span>,</span><br><span class="line">         localField: <span class="string">"item"</span>,</span><br><span class="line">         foreignField: <span class="string">"sku"</span>,</span><br><span class="line">         <span class="keyword">as</span>: <span class="string">"inventory_docs"</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><ul><li><a href="https://docs.mongodb.com/manual/reference/operator/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/</a></li></ul><h4 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h4><ul><li>公钥 公开的加密方式</li><li>私钥 存在服务器的唯一解公钥加密的方式</li><li>签名 确保数据的一致性</li><li>证书 确保当前发送数据单位可信</li></ul><h3 id="使用mongoose"><a href="#使用mongoose" class="headerlink" title="使用mongoose"></a>使用mongoose</h3><p><code>npm i mongoose --save</code></p><p><code>stuModel.find({},{name:1,_id:0},{skip:3,limit:1},(err,docs)=&gt;{ if(!err){console.log(docs)} })</code>只查询name,跳过三个只显示1<br><code>stuModel.find({},&quot;name -_id&quot;,(err,docs)=&gt;{ if(!err){console.log(docs)} })</code>跟上一样</p><p><strong>连接mongo,进行简单操作</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://127.0.0.1/test"</span>)</span><br><span class="line">mongoose.connection.once(<span class="string">"open"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"连接成功"</span>))</span><br><span class="line">mongoose.connection.once(<span class="string">"close"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"连接断开"</span>))</span><br><span class="line">    <span class="comment">//mongoose.disconnect()</span></span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stuSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'female'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    address: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stuModel = mongoose.model(<span class="string">"student"</span>, stuSchema)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*stuModel.create(&#123;</span></span><br><span class="line"><span class="comment">    name: 'jiachen',</span></span><br><span class="line"><span class="comment">    age: 20,</span></span><br><span class="line"><span class="comment">    gender: 'man',</span></span><br><span class="line"><span class="comment">    address: 'yiyang'</span></span><br><span class="line"><span class="comment">&#125;, (err) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    if (!err) &#123;</span></span><br><span class="line"><span class="comment">        console.log('插入成功')</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;)*/</span></span><br><span class="line">stuModel.findOne(&#123;&#125;,(err,doc)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        doc.update(&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">28</span>&#125;&#125;,err=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'modify success'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>初识断点调试</title>
    <url>/2019/07/26/%E5%88%9D%E8%AF%86%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="初识断点调试"><a href="#初识断点调试" class="headerlink" title="初识断点调试"></a>初识断点调试</h1><blockquote><p>之前用console.log调试，比较麻烦，发现断电调试非常好用</p></blockquote><h3 id="使用VS-Code调试node"><a href="#使用VS-Code调试node" class="headerlink" title="使用VS Code调试node"></a>使用VS Code调试node</h3><ul><li>打开vscode</li></ul><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/cutdot1.png" alt="1564132432137"></p><p>点击调试虫子，然后添加配置，使用node</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/cutdot2.png" alt="1564132500339"></p><p>添加之后发现多了一个文件，进去修改配置</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/cutdot3.png" alt="1564132604123"></p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/cutdot4.png" alt="1564133154968"></p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/cutdot5.png" alt="1564132943710"></p><p>断点之后可以查看变量当中的数据,找出bug</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用node连接Mysql，简单的注册登陆demo</title>
    <url>/2019/07/26/%E4%BD%BF%E7%94%A8node%E8%BF%9E%E6%8E%A5Mysql%EF%BC%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%A8%E5%86%8C%E7%99%BB%E9%99%86demo/</url>
    <content><![CDATA[<h1 id="使用node连接Mysql，简单的注册登陆demo"><a href="#使用node连接Mysql，简单的注册登陆demo" class="headerlink" title="使用node连接Mysql，简单的注册登陆demo"></a>使用node连接Mysql，简单的注册登陆demo</h1><blockquote><p>初步使用，学习node过程中小笔记</p></blockquote><h3 id="创建工作区"><a href="#创建工作区" class="headerlink" title="创建工作区"></a>创建工作区</h3><p>使用cnpm 国内淘宝的一个npm镜像，速度更快</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao .org</span><br></pre></td></tr></table></figure><p>管理员运行Cmd在工作区，初始化一些包</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm init</span><br></pre></td></tr></table></figure><p>在启动MySQL的过程中有点小问题，官网下载的压缩包，配置老是出错，可能是跟之前安装了一些集成环境的软件有冲突，遂放弃，直接用 <strong>PHPStudy</strong> 这个集成软件</p><h3 id="如何创建与数据库的连接"><a href="#如何创建与数据库的连接" class="headerlink" title="如何创建与数据库的连接"></a>如何创建与数据库的连接</h3><p>创建表，使用<strong>SQL</strong></p><p>设ID为主键，自动递增</p><p>然后插入一条数据测试一下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`user_table`</span></span><br><span class="line">(</span><br><span class="line"><span class="string">`ID`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT primary <span class="keyword">key</span>,</span><br><span class="line"><span class="string">`userName`</span>  <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`passWord`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user_table`</span> (<span class="string">`userName`</span>,<span class="string">`passWord`</span>) <span class="keyword">VALUES</span> (<span class="string">'jason'</span>,<span class="string">'afsdg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/node_mysql1.png" alt="1564126756258"></p><p>引入MySQL模块，使node与数据库建立连接</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"><span class="keyword">let</span> db = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>, <span class="comment">//地址</span></span><br><span class="line">    user: <span class="string">'root'</span>, <span class="comment">//用户名</span></span><br><span class="line">    password: <span class="string">'root'</span>, <span class="comment">//密码</span></span><br><span class="line">    port: <span class="string">'3306'</span>, <span class="comment">//端口号</span></span><br><span class="line">    database: <span class="string">'数据库名'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="简单的SQL查询"><a href="#简单的SQL查询" class="headerlink" title="简单的SQL查询"></a>简单的SQL查询</h3><p>在query() 方法里直接写SQL语句，返回结果回调</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.query(<span class="string">`UPDATE user_table  SET passWord='22134' where ID=0`</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'错了'</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注册登陆demo"><a href="#注册登陆demo" class="headerlink" title="注册登陆demo"></a>注册登陆demo</h3><p>用 <code>createConnection</code> 创建 Mysql 连接，每执行一次 <code>connection.query</code> 都是一个全新的连接，会造成一个资源的极大浪费，降低性能。</p><figure class="highlight plain"><figcaption><span>`分发`、`复用`、`管理` 这些连接。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let db = mysql.createPool(&#123;</span><br><span class="line">    host: &apos;localhost&apos;,</span><br><span class="line">    user: &apos;root&apos;,</span><br><span class="line">    password: &apos;root&apos;,</span><br><span class="line">    port: &apos;3306&apos;,</span><br><span class="line">    database: &apos;XXX&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>连接数据库后，与网页建立连接，数据判断很重要</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//解析URL</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; user, pass &#125; = query;</span><br><span class="line">    <span class="built_in">console</span>.log(url.parse(req.url, <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">switch</span> (pathname) &#123;</span><br><span class="line">        <span class="comment">//接口</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/reg'</span>:</span><br><span class="line">            <span class="comment">//校验</span></span><br><span class="line">            <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "username can\'t be null"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pass) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "password can\'t be null"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^\w&#123;4,16&#125;$/</span>.test(user)) &#123;<span class="comment">//控制长度，字符，防止非法SQL注入</span></span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "username is invaild"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/['|"]/</span>.test(pass)) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "password is invaild"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                db.query(<span class="string">`SELECT * FROM user_table WHERE userName='<span class="subst">$&#123;user&#125;</span>'`</span>, (err, data) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 1, "msg": "database error"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 2, "msg": "this username exsits"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        db.query(<span class="string">`INSERT INTO user_table (userName,passWord) VALUES('<span class="subst">$&#123;user&#125;</span>','<span class="subst">$&#123;pass&#125;</span>')`</span>, (err, data) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                                res.write(<span class="string">'&#123;"err": 2, "msg": "database error"&#125;'</span>);</span><br><span class="line">                                res.end();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                res.write(<span class="string">'&#123;"err": 0, "msg": "success"&#125;'</span>);</span><br><span class="line">                                res.end();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/login'</span>:</span><br><span class="line">            <span class="comment">//校验</span></span><br><span class="line">            <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "username can\'t be null"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pass) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "password can\'t be null"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^\w&#123;4,16&#125;$/</span>.test(user)) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "username is invaild"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/['|"]/</span>.test(pass)) &#123;</span><br><span class="line">                res.write(<span class="string">'&#123;"err": 1, "msg": "password is invaild"&#125;'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                db.query(<span class="string">`SELECT * FROM user_table WHERE userName='<span class="subst">$&#123;user&#125;</span>'`</span>, (err, data) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 1, "msg": "database error"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 1, "msg": "no this user"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[<span class="number">0</span>].passWord != pass) &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 1, "msg": "username or password is incorrect"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.write(<span class="string">'&#123;"err": 0, "msg": "success"&#125;'</span>);</span><br><span class="line">                        res.end();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//读取html文件</span></span><br><span class="line">            <span class="keyword">let</span> rs = fs.createReadStream(<span class="string">`www<span class="subst">$&#123;pathname&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">let</span> gz = zlib.createGzip();</span><br><span class="line">            res.setHeader(<span class="string">'content-encoding'</span>, <span class="string">'gzip'</span>);</span><br><span class="line">            <span class="comment">//使用管道先压缩</span></span><br><span class="line">            rs.pipe(gz).pipe(res);</span><br><span class="line">            rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">                res.writeHeader(<span class="number">404</span>);</span><br><span class="line">                res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>随便创一个，点击注册</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/node_mysql2.png" alt="1564132774040"><br>通过断点调试，查看到，query中的数据<br><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/node_mysql3.png" alt="1564132943710"><br>数据库中存在新增用户<br><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/node_mysql4.png" alt="1564132971403"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>后台</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>毛概课后复习参考答案</title>
    <url>/2019/07/03/%E6%AF%9B%E6%A6%82%E8%AF%BE%E5%90%8E%E5%A4%8D%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%EF%BC%9A/</url>
    <content><![CDATA[<p>课后复习题参考：</p><p><strong>第一章</strong></p><p>1、毛泽东思想的含义</p><p>毛泽东思想是马克思主义中国化的第一个重大理论成果，是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶，是党必须长期坚持的指导思想。</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>2、毛泽东思想形成发展的历史条件</p><p>19世纪末20世纪初，世界进入帝国主义和无产阶级革命时代，作为中国反帝反封建民主革命指导思想的毛泽东思想，正是在这样的时代条件下形成和发展起来的。</p><p>中国共产党领导人民进行革命和建设的成功实践是毛泽东思想形成和发展的实践基础。</p><p>3、毛泽东思想的主要内容和活的灵魂。</p><p>主要内容：新民主主义革命理论、社会主义革命和社会主义建设理论、革命军队建设和军事战略的理论、政策和策略的理论、思想政治工作和文化工作的理论、党的建设理论，这些是毛泽东思想科学体系的主要内容。</p><p>活的灵魂：实事求是、群众路线、独立自主是毛泽东思想的活的灵魂。</p><p>选择题：毛泽东思想在土地革命战争时期形成，在抗日战争时期走向成熟，并在解放战争时期和中华人民共和国成立后继续发展。</p><p><strong>第二章</strong></p><p>1、新民主主义革命总路线：1948年，他在《在晋绥干部会议上的讲话》中完整地表述了总路线的内容，即无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量，是新民主主义革命的指导路线。</p><p>2、怎样理解中国革命必须由无产阶级及其政党来领导？</p><p>无产阶级及其政党的领导，是中国革命取得胜利的根本保证，无产阶级的领导权是中国革命的中心问题。</p><p>中国革命必须由无产阶级及其政党来领导，这是历史发展的必然：由于帝国主义不允许中国民族资产阶级建立独立的资产阶级共和国，而是要把中国变成它们的殖民地和半殖民地；由于中国民族资产阶级的软弱性和妥协性，它们不愿意也不能够彻底推翻帝国主义和封建势力；由于中国无产阶级的强大和革命的彻底性，领导中国革命的重任，历史地落到了中国无产阶级及其政党的肩上。</p><p>中国无产阶级及其政党能领导中国革命的可能性：中国无产阶级除了具有一般无产阶级的基本优点外，还具有自身的特点和优点。一是深受外国资本主义、本国封建势力和资产阶级的三重压迫，比任何别的阶级都来得坚决和彻底；二是它分布集中，有利于无产阶级队伍的组织和团结，有利于革命思想的传播和强大革命力量的形成；三是它的成员中的大部分出身于破产农民，便于和农民结成亲密的联盟。</p><p>无产阶级及其政党对中国革命的领导权不是自然而然得来的，而是在与资产阶级争夺领导权的斗争中实现的。</p><p>3、新民主主义的政治纲领是：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。新民主主义共和国既不同于欧美式的资产阶级专政的共和国，又和苏联式的无产阶级专政的社会主义共和国相区别。</p><p>4、新民主主义的经济纲领是：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</p><p>5、中国革命必须走农村包围城市、武装夺取政权的道路的必然性？</p><p>这是由中国所处的时代特点和具体国情决定的。一方面，在半殖民地半封建的中国社会，内无民主制度而受封建主义的压迫，外无民族独立而受帝国主义的压迫，这决定了中国革命的主要斗争形式只能是武装斗争，以革命的武装消灭反革命的武装，相应的主要组织形式必然是军队。另一方面，近代中国是一个农业大国，农民占全国人口的绝大多数，是无产阶级可靠的同盟军和革命的主力军，这决定了在中国开展革命斗争，必须充分地发动农民，凝聚农民阶级的革命力量，即走农村道路。</p><p>6、中国革命之所以能走农村包围城市、武装夺取政权的道路的可能性。</p><p>第一，近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，为党在农村开展革命提供了可能；第二，农民革命愿望强烈，且革命的群众基础好。第三，全国革命形势的继续向前发展，为在农村建设革命根据地提供了客观条件。第四，相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾。第五，党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件。</p><p>6、农村革命道路的主要内容。</p><p>中国革命走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系。</p><p>三者有机统一：土地革命是民主革命的基本内容；武装斗争是中国革命的主要形式，是农村根据地建设和土地革命的强有力保证；农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托。</p><p>7、如何理解新民主主义革命的三大法宝及其相互关系？</p><p>统一战线、武装斗争、党的建设中国共产党在中国革命中战胜敌人的三个主要的法宝，是新民主主义革命胜利的基本经验。</p><p>三者之间的关系：统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器。统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱，党的组织则是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士。</p><p><strong>第三章</strong></p><p>1、为什么说新民主主义社会是一个过渡性社会？</p><p>从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。</p><p>从经济上看，五种经济成分并存，即社会主义性质的国营经济、半社会主义性质的合作社经济、农民和手工业者的个体经济、私人资本主义经济和国家资本主义经济。其中主要的经济成分是三种：社会主义经济、个体经济和资本主义经济。</p><p>从政治上看，与三种主要经济成分之对应，中国社会的阶级构成主要是工人阶级、农民阶级和其他小资产阶级、民族资产阶级等基本的阶级力量。</p><p>在新民主主义社会中，社会主义的因素不论在经济上还是在政治上都已经居于领导地位，但非社会主义因素仍有很大比重。</p><p>总之，新民主主义社会是属于社会主义体系的，是逐步过渡到社会主义社会的过渡性质的社会。</p><p>2、党在过渡时期的总路线</p><p>党在过渡时期的总路线的内容：从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造，简单概括为“一化三改”。</p><p>过渡时期的总路线是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力与发展生产力、变革生产关系与发展生产力的有机统一。</p><p>\3. 如何理解中国确立社会主义基本制度的重大意义？</p><p>社会主义基本制度的确立是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提。</p><p>社会主义基本制度的确立，极大地促进了我国社会生产力的发展也初步显示了社会主义的优越性，还为在中国这样一个社会生产力水平十分落后的东方大国进行社会主义建设积累了重要经验。</p><p>中国社会主义基本制度的确立，是世界社会主义发展史上又一个历史性的伟大胜利，也进一步改变了世界政治经济格局，增强了社会主义的力量，对维护世界和平产生了积极影响。</p><p>我国社会主义基本制度的确立，再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。</p><p><strong>第四章</strong></p><p>1、毛泽东关于社会主义社会基本矛盾的思想？</p><p>矛盾是普遍存在的，社会主义社会同样充满着矛盾，正是这些矛盾推动着社会主义社会不断地向前发展。</p><p>在社会主义社会中，基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。</p><p>但社会主义社会的基本矛盾不是对抗性的矛盾，而是非对抗性的矛盾。社会主义社会基本矛盾运动具有“又相适应又相矛盾”的特点，是在生产关系和生产力基本适应、上层建筑和经济基础基本适应条件下的矛盾，是在人民根本利益一致基础上的矛盾。</p><p>社会主义社会基本矛盾可以经过社会主义制度本身，不断地得到解决。</p><p>2、毛泽东关于区分两类不同性质矛盾和正确处理人民内部矛盾两类性质不同社会矛盾的理论？</p><p>社会主义社会存在两类不同性质矛盾，这就是敌我矛盾和人民内部矛盾。敌我矛盾是根本利益对立基础上的矛盾，因而是对抗性的矛盾。人民内部矛盾是在人民根本利益一致基础上的矛盾，因而是非对抗性的矛盾。必须严格区分和正确处理两类不同性质的矛盾。</p><p>敌我矛盾采用专政的方法解决。人民内部矛盾采用民主的方法，如对于政治思想领域的人民内部矛盾，实行“团结—批评—团结”的方针；对于科学文化领域里的矛盾，实行“百花齐放、百家争鸣”的方针；对于共产党和民主党派的矛盾，实行“长期共存、互相监督”的方针</p><p>正确处理人民内部矛盾的问题是社会主义国家政治生活的主题。</p><p>\2. 党对社会主义建设道路初步探索的重大意义？</p><p>党对社会主义建设道路初步探索在理论和实践上取得的一系列重要成果，对于巩固我国社会主义制度，开创和发展中国特色社会主义，促进世界社会主义的发展，具有重要意义。</p><p>第一，巩固和发展了我国的社会主义制度。第二，为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。第三，丰富了科学社会主义的理论和实践。</p><p><strong>第五章</strong></p><p>1、邓小平理论形成的社会历史条件。</p><p>邓小平理论贯穿解放思想、实事求是的思想路线，围绕“什么是社会主义、怎样建设社会主义”这个首要的基本的理论问题。邓小平理论形成的社会历史条件：第一、和平与发展成为时代主题是邓小平理论形成的时代背景。第二，社会主义建设的经验教训是邓小平理论形成的历史根据。第三，改革开放和现代化建设的实践是邓小平理论形成的现实依据。</p><p>2、邓小平理论的社会主义本质论？</p><p>1992年初，邓小平在南方谈话中对社会主义本质作了总结性理论概括：“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。”</p><p>3、邓小平的社会主义初级阶段理论？</p><p>我国处在社会主义初级阶段，是邓小平和我们党对当代中国基本国情的科学判断。社会主义初级阶段的论断包括两层含义：第一，我国已经进入社会主义社会，必须坚持而不能离开社会主义。第二，我国的社会主义社会还处在不发达的阶段，必须正视而不能超越初级阶段。</p><ol start="4"><li>党的基本路线</li></ol><p>党的十三大报告提出了党在社会主义初级阶段的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。</p><p>党的基本路线在改革开放实践中不断充实和完善。党的十七大把“和谐”与“富强、民主、文明”一起写入了基本路线。党的十九大进一步修改为“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”，不仅将“美丽”纳入了基本路线，而且将“现代化国家”提升为“现代化强国”，扩展了党的基本路线的内涵，提升了社会主义初级阶段的奋斗目标。</p><p>5、邓小平的社会主义市场经济理论？</p><p>邓小平社会主义市场经济理论的要点有：一是计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义；二是计划和市场都是经济手段，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者结合起来；三是市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在。</p><p><strong>第六章</strong></p><p>1、“三个代表”重要思想的形成条件？</p><p>第一，“三个代表”重要思想是在对冷战结束后国际局势科学判断的基础上形成的。冷战结束后世界多极化和经济全球化的趋势在曲折中发展，和平与发展仍是时代的主题。我们党所处的国际国内环境已经发生并还在经历着前所未有的巨大变化，这是“三个代表”重要思想产生的最重要的时代背景。第二，“三个代表”重要思想是在科学判断党的历史方位和总结历史经验的基础上提出来的。党所处的地位和环境、党所肩负的历史任务、党的自身状况，都发生了新的重大变化。进一步提高党的领导水平和执政水平、提高拒腐防变和抵御风险的能力，是我们党必须解决好的两大历史性课题。“三个代表”重要思想的提出，正是立足于党的历史、总结党的历史经验得出的重要结论。第三，“三个代表”重要思想是在建设中国特色社会主义伟大实践基础上形成的。</p><p>2、“三个代表”重要思想的核心观点</p><p>围绕着“建设一个什么样的党、怎样建设党”这一重大现实问题，江泽民提出了“三个代表”重要思想。“中国共产党必须始终代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。”这是对“三个代表”重要思想的集中概括。</p><p><strong>第七章</strong></p><ol><li>科学发展观的科学内涵？</li></ol><p>科学发展观，第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。这是对科学发展观的集中概括。</p><p>课后复习题参考：</p><p><strong>第八章</strong></p><p>1、中国特色社会主义进入新时代的重大意义？</p><p>答：中国特色社会主义进入新时代，在中华人民共和国发展史上、中华民族发展史上具有重大意义，在世界社会主义发展史上、人类社会发展史上也具有重大意义。</p><p>第一、从中华民族复兴的历史进程看，中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景。</p><p>第二、从科学社会主义发展进程看，中国特色社会主义进入新时代，意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。</p><p>第三，从人类文明进程看，中国特色社会主义进入新时代，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。</p><p>2.试论述新时代我国社会主要矛盾已发生了怎样的转化？并说明实现这一转化的主要依据是什么？</p><p>答：党的十九大明确指出，我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。主要依据有以下三个方面：</p><p>一是经过改革开放40年的发展，我国社会生产力水平总体上显著提高，很多方面进入世界前列。如我国国内生产总值自2010年开始稳居世界第二位……这说明，我国进入社会主义初级阶段以来的“落后的社会生产”已经发生了新的阶段性变化。</p><p>二是人民生活水平显著提高，对美好生活的向往更加强烈，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。这说明，人民群众对于日益增长的“物质文化需要”层次更高、内容范围更广，出现了阶段性的新特征。</p><p>三是影响满足人们美好生活需要的因素很多，但主要是发展的不平衡不充分问题。发展不平衡，主要指各区域各领域各方面发展不平衡，制约了全国发展水平提升。发展不充分，主要指一些地区、一些领域、一些方面还存在发展不足的问题，发展的任务仍然很重。发展不平衡不充分问题表现在很多方面。</p><p>这些发展不平衡不充分问题相互掣肘，带来很多社会矛盾和问题，是当前和今后一个时期制约我国发展和满足人民日益增长的美好生活需要的主要根源。</p><p><strong>第九章</strong></p><p>1.新时代建设中国特色社会主义的总任务？</p><p>坚持和发展中国特色社会主义的总任务，是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。中国梦是中华民族伟大复兴的形象表达，中国梦的本质是国家富强、民族振兴、人民幸福。</p><p>2.新时代中国特色社会主义发展的战略安排？</p><p>从全面建成小康社会到基本实现现代化，再到全面建成社会主义现代化强国，是新时代中国特色社会主义发展的战略安排。全面建设社会主义现代化国家的进程分两个阶段：第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，基本实现社会主义现代化。第二个阶段，从2035年到本世纪中叶；在基本实现现代化的基础上，再奋斗15年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。</p><p><strong>第十章</strong></p><pre><code>1.新时代如何推进现代化经济体系建设？</code></pre><p>推动建设现代化经济体系，必须贯彻创新、协调、绿色、开放、共享的新发展理念，必须坚持供给侧结构性改革，，推动经济发展质量变革、效率变革、动力变革，实现高质量增长。</p><ol start="2"><li>如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一？</li></ol><p>走中国特色社会主义道路，必须坚持党的领导、人民当家作主和依法治国的有机统一。</p><p>党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治伟大实践。</p><ol start="3"><li>如何推动社会主义文化繁荣兴盛？</li></ol><p>推动社会主义文化繁荣兴盛，必须坚持走中国特色社会主义文化发展道路：第一，必须巩固马克思主义在意识形态领域的指导地位，牢牢把握意识形态工作领导权；第二，必须弘扬社会主义核心值体系和核心价值观。社会主义核心价值体系由马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观四个方面内容构成。社会主义核心价值观是富强、民主、文明、和谐，自由、民主、公正、法治，爱国、敬业、诚信、友善。第三，必须坚定文化自信，建设社会主义文化强国，大力发展文化事业和文化产业，提高国家文化软实力。</p><ol start="4"><li>如何在发展中加强和改善民生？</li></ol><p>民生是人民幸福之基、社会和谐之本，在发展中加强和改善民生，第一，必须提高和改善民生水平，包括优先发展教育事业，提高就业质量和人民收入水平，加强社会保障体系建设，坚决打赢脱贫攻坚战，实施健康中国战略；第二，必须加强和创新社会治理，包括创新社会治理体制，改进社会治理方式等；第三，坚持国家总统安全观，包括完善国家安全体系，健全公共安全等。</p><ol start="5"><li>如何建设美丽中国？</li></ol><p>建设美丽中国，首先必须坚持人与自然和谐共生，形成人与自然和谐发展的新格局，把节约资源放在首位，坚持保护优先，着力推进绿色发展，实现最严格的环境保护政策，加快生态文明体制改革。</p><p><strong>第十一章</strong></p><p>1.党在新形势下治国理政的总方略？</p><p>“四个全面”战略布局是我们党在新形势下治国理政的总方略。全面建成小康社会是战略目标，全面深化改革、全面依法治国、全面从严治党是战略举措。</p><p>2.全面深化改革的总目标？</p><p>全面深化改革的总目标是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。</p><p>3.如何走中国特色社会主义法治道路？</p><p>坚持中国共产党的领导，党的领导是社会主义法治最根本的保证。坚持人民在全面依法治国中的主体地位。坚持法律面前人人平等。坚持依法治国和以德治国相结合。坚持从中国实际出发。</p><p>4.新时代党的建设总要求？</p><p>新时代党的建设总要求是：坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p><p><strong>第十二章</strong></p><p>1.习近平强军思想的主要内容？</p><p>习近平强军思想深刻回答了“新时代建设一支什么样的强大人民军队、怎样建设强大人民军队”的时代课题，其主要内容有：一是强国必须强军；二是建设世界一流军队。三是党对军队的绝对领导是人民军队建军之本。四是必须构建中国特色现代军事力量体系。五是必须加强军队作风建设和纪律建设。六是推进强军事业必须坚持政治建军、改革强军、科技兴军、依法治军，更加注重聚焦实战、更加注重创新驱动、更加注重体系建设、更加注重集约高效、更加注重军民融合，全面提高革命化现代化正规化水平。七是改革是强军的必由之路。九是现代化军队必须构建中国特色军事法治体系。十是军民融合发展是兴国之举、强军之策。</p><p><strong>第十三章</strong></p><p>1.如何认识当今世界发展趋势？</p><p>第一、世界多极化在曲折中发展；第二、 经济全球化深入发展；第三、 文化多样化持续推进；第四，社会信息化快速发展</p><p>2.如何理解构建人类命运共同体思想？</p><p>第一，政治上，要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路。第二，安全上，要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。第三，经济上，要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。第四，文化上，要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越。第五，生态上，要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园。</p><p><strong>第十四章</strong></p><ol><li>党的领导是中国特色社会主义最本质的特征</li></ol><p>第一，这是由科学社会主义的理论逻辑所决定的，坚持无产阶级政党的领导是无产阶级革命和社会主义建设取得胜利的根本保证。第二，这是由中国特色社会主义产生与发展的历史逻辑所决定的。历史和现实证明，没有中国共产党的领导，就没有中国特色社会主义的产生与发展。</p><p>第三，这是由中国特色社会主义迈向新征程的实践逻辑所决定的。实现中华民族伟大复兴，关键在党。</p><ol start="2"><li>党的领导是中国特色社会主义制度的最大优势</li></ol><p>中国共产党的领导是中国特色社会主义制度的最大优势。第一，党是中国特色社会主义制度的创建者。第二，党的领导是充分发挥中国特色社会主义制度优势的根本保障。第三，党的自身优势是中国特色社会主义制度优势的主要来源。</p><ol start="3"><li>新时代中国共产党的历史使命？</li></ol><p>新时代中国共产党的历史使命，就是统揽伟大斗争、伟大工程、伟大事业、伟大梦想，在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴。</p><ol start="4"><li>党是最高政治领导力量？</li></ol><p>第一，这是马克思主义政党的基本要求。第二，这是对党领导革命、建设和改革历史经验的深刻总结。第三，这是推进伟大事业的根本保证。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>思政</category>
      </categories>
  </entry>
  <entry>
    <title>Java面试题</title>
    <url>/2019/06/28/Java_qes/</url>
    <content><![CDATA[<h5 id="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</span><br><span class="line">Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h5 id="2、JDK和JRE的区别是什么？"><a href="#2、JDK和JRE的区别是什么？" class="headerlink" title="2、JDK和JRE的区别是什么？"></a>2、JDK和JRE的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）--编译器、调试器和其他工具。</span><br><span class="line"></span><br><span class="line">Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</span><br></pre></td></tr></table></figure><h5 id="3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span><br><span class="line"></span><br><span class="line">Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</span><br><span class="line"></span><br><span class="line">java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</span><br></pre></td></tr></table></figure><h5 id="4、是否可以在static环境中访问非static变量？"><a href="#4、是否可以在static环境中访问非static变量？" class="headerlink" title="4、是否可以在static环境中访问非static变量？"></a>4、是否可以在static环境中访问非static变量？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span><br></pre></td></tr></table></figure><h5 id="5、Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#5、Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="5、Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5、Java支持的数据类型有哪些？什么是自动拆装箱？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br><span class="line"></span><br><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short,boolean,int,long,float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程</span><br></pre></td></tr></table></figure><h5 id="6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？"><a href="#6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？" class="headerlink" title="6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span><br></pre></td></tr></table></figure><h5 id="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。</span><br><span class="line">Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</span><br><span class="line">Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</span><br></pre></td></tr></table></figure><h5 id="8、Java支持多继承么？"><a href="#8、Java支持多继承么？" class="headerlink" title="8、Java支持多继承么？"></a>8、Java支持多继承么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</span><br></pre></td></tr></table></figure><h5 id="9、接口和抽象类的区别是什么？"><a href="#9、接口和抽象类的区别是什么？" class="headerlink" title="9、接口和抽象类的区别是什么？"></a>9、接口和抽象类的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span><br><span class="line">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</span><br><span class="line">类可以实现很多个接口，但是只能继承一个抽象类</span><br><span class="line">类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</span><br><span class="line">抽象类可以在不提供接口方法实现的情况下实现接口。</span><br><span class="line">Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</span><br><span class="line">Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</span><br><span class="line">接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</span><br><span class="line">也可以参考JDK8中抽象类和接口的区别</span><br></pre></td></tr></table></figure><h5 id="10、什么是值传递和引用传递？"><a href="#10、什么是值传递和引用传递？" class="headerlink" title="10、什么是值传递和引用传递？"></a>10、什么是值传递和引用传递？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</span><br><span class="line"></span><br><span class="line">引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本,并不是原对象本身。</span><br><span class="line"></span><br><span class="line">一般认为,java内的基础类型数据传递都是值传递.java中实例对象的传递是引用传递</span><br></pre></td></tr></table></figure><h5 id="11、进程和线程的区别是什么？"><a href="#11、进程和线程的区别是什么？" class="headerlink" title="11、进程和线程的区别是什么？"></a>11、进程和线程的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程与进程的区别归纳：</span><br><span class="line"></span><br><span class="line">a.地址空间和其它资源</span><br><span class="line">：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</span><br><span class="line">b.通信：</span><br><span class="line">进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</span><br><span class="line">c.调度和切换</span><br><span class="line">：线程上下文切换比进程上下文切换要快得多。d.在多线程OS中，进程不是一个可执行的实体。</span><br></pre></td></tr></table></figure><h5 id="12、创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#12、创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="12、创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>12、创建线程有几种不同的方式？你喜欢哪一种？为什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有4种方式可以用来创建线程：</span><br><span class="line">继承Thread类</span><br><span class="line">实现Runnable接口</span><br><span class="line">应用程序可以使用Executor框架来创建线程池</span><br><span class="line"></span><br><span class="line">实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</span><br><span class="line"></span><br><span class="line">还有一种方式是实现Callable接口</span><br></pre></td></tr></table></figure><h5 id="13、概括的解释下线程的几种可用状态。"><a href="#13、概括的解释下线程的几种可用状态。" class="headerlink" title="13、概括的解释下线程的几种可用状态。"></a>13、概括的解释下线程的几种可用状态。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.新建(new)：新创建了一个线程对象。</span><br><span class="line"></span><br><span class="line">2.可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start</span><br><span class="line">()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</span><br><span class="line"></span><br><span class="line">3.运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</span><br><span class="line"></span><br><span class="line">4.阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cputimeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cputimeslice转到运行(running)状态。阻塞的情况分三种：</span><br><span class="line"></span><br><span class="line">(一).等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waittingqueue)中。</span><br><span class="line"></span><br><span class="line">(二).同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lockpool)中。</span><br><span class="line"></span><br><span class="line">(三).其他阻塞:运行(running)的线程执行Thread.sleep(longms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。            当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</span><br><span class="line"></span><br><span class="line">5.死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</span><br></pre></td></tr></table></figure><h5 id="14、同步方法和同步代码块的区别是什么？"><a href="#14、同步方法和同步代码块的区别是什么？" class="headerlink" title="14、同步方法和同步代码块的区别是什么？"></a>14、同步方法和同步代码块的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line"></span><br><span class="line">同步方法默认用this或者当前类class对象作为锁；</span><br><span class="line"></span><br><span class="line">同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</span><br><span class="line"></span><br><span class="line">同步方法使用关键字synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）&#123;代码内容&#125;进行修饰；</span><br></pre></td></tr></table></figure><h5 id="15、在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#15、在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="15、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>15、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</span><br></pre></td></tr></table></figure><h5 id="16、什么是死锁-deadlock-？"><a href="#16、什么是死锁-deadlock-？" class="headerlink" title="16、什么是死锁(deadlock)？"></a>16、什么是死锁(deadlock)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</span><br><span class="line">不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</span><br><span class="line">请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</span><br><span class="line">循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</span><br></pre></td></tr></table></figure><h5 id="17、如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#17、如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="17、如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>17、如何确保N个线程可以访问N个资源同时又不导致死锁？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</span><br></pre></td></tr></table></figure><h5 id="18、Java集合类框架的基本接口有哪些？"><a href="#18、Java集合类框架的基本接口有哪些？" class="headerlink" title="18、Java集合类框架的基本接口有哪些？"></a>18、Java集合类框架的基本接口有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</span><br><span class="line">Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</span><br><span class="line">Collection：代表一组对象，每一个对象都是它的子元素。</span><br><span class="line">Set：不包含重复元素的Collection。</span><br><span class="line">List：有顺序的collection，并且可以包含重复元素。</span><br><span class="line">Map：可以把键(key)映射到值(value)的对象，键不能重复。</span><br></pre></td></tr></table></figure><h5 id="19、为什么集合类没有实现Cloneable和Serializable接口？"><a href="#19、为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="19、为什么集合类没有实现Cloneable和Serializable接口？"></a>19、为什么集合类没有实现Cloneable和Serializable接口？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</span><br></pre></td></tr></table></figure><h5 id="20、什么是迭代器-Iterator-？"><a href="#20、什么是迭代器-Iterator-？" class="headerlink" title="20、什么是迭代器(Iterator)？"></a>20、什么是迭代器(Iterator)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</span><br><span class="line"></span><br><span class="line">迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的</span><br><span class="line"></span><br><span class="line">remove(ObjectObj)删除，可以通过迭代器的remove()方法删除。</span><br></pre></td></tr></table></figure><h5 id="21、Iterator和ListIterator的区别是什么？"><a href="#21、Iterator和ListIterator的区别是什么？" class="headerlink" title="21、Iterator和ListIterator的区别是什么？"></a>21、Iterator和ListIterator的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面列出了他们的区别：</span><br><span class="line">Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</span><br><span class="line">Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</span><br><span class="line">ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span><br></pre></td></tr></table></figure><h5 id="22、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#22、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="22、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>22、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一：快速失败（fail—fast）         在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出ConcurrentModificationException。          原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。     注意：这里异常的抛出条件是检测到modCount！=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。     场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。   二：安全失败（fail—safe）     采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。     原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。     缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。         场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</span><br></pre></td></tr></table></figure><h5 id="23、Java中的HashMap的工作原理是什么？"><a href="#23、Java中的HashMap的工作原理是什么？" class="headerlink" title="23、Java中的HashMap的工作原理是什么？"></a>23、Java中的HashMap的工作原理是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(loadfactor)和扩容极限(thresholdresizing)。</span><br></pre></td></tr></table></figure><h5 id="24、hashCode-和equals-方法的重要性体现在什么地方？"><a href="#24、hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="24、hashCode()和equals()方法的重要性体现在什么地方？"></a>24、hashCode()和equals()方法的重要性体现在什么地方？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</span><br></pre></td></tr></table></figure><h5 id="25、HashMap和Hashtable有什么区别？"><a href="#25、HashMap和Hashtable有什么区别？" class="headerlink" title="25、HashMap和Hashtable有什么区别？"></a>25、HashMap和Hashtable有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</span><br><span class="line">HashMap允许键和值是null，而Hashtable不允许键或者值是null。</span><br><span class="line">Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</span><br><span class="line">HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</span><br><span class="line">一般认为Hashtable是一个遗留的类。</span><br></pre></td></tr></table></figure><h5 id="26、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#26、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="26、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>26、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面列出了Array和ArrayList的不同点：</span><br><span class="line">Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</span><br><span class="line">Array大小是固定的，ArrayList的大小是动态变化的。</span><br><span class="line">ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</span><br><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></table></figure><h5 id="27、ArrayList和LinkedList有什么区别？"><a href="#27、ArrayList和LinkedList有什么区别？" class="headerlink" title="27、ArrayList和LinkedList有什么区别？"></a>27、ArrayList和LinkedList有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</span><br><span class="line">ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</span><br><span class="line">相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</span><br><span class="line">LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span><br><span class="line">也可以参考ArrayListvs.LinkedList。</span><br></pre></td></tr></table></figure><h5 id="28、Comparable和Comparator接口是干什么的？列出它们的区别。"><a href="#28、Comparable和Comparator接口是干什么的？列出它们的区别。" class="headerlink" title="28、Comparable和Comparator接口是干什么的？列出它们的区别。"></a>28、Comparable和Comparator接口是干什么的？列出它们的区别。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。</span><br><span class="line">Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</span><br></pre></td></tr></table></figure><h5 id="29、什么是Java优先级队列-Priority-Queue-？"><a href="#29、什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="29、什么是Java优先级队列(Priority Queue)？"></a>29、什么是Java优先级队列(Priority Queue)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(naturalorder)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</span><br></pre></td></tr></table></figure><h5 id="30、你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#30、你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="30、你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>30、你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是一个渐进上界。</span><br><span class="line">大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。</span><br></pre></td></tr></table></figure><h5 id="31、如何权衡是使用无序的数组还是有序的数组？"><a href="#31、如何权衡是使用无序的数组还是有序的数组？" class="headerlink" title="31、如何权衡是使用无序的数组还是有序的数组？"></a>31、如何权衡是使用无序的数组还是有序的数组？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有序数组最大的好处在于查找的时间复杂度是O(logn)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</span><br></pre></td></tr></table></figure><h5 id="32、Java集合类框架的最佳实践有哪些？"><a href="#32、Java集合类框架的最佳实践有哪些？" class="headerlink" title="32、Java集合类框架的最佳实践有哪些？"></a>32、Java集合类框架的最佳实践有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。</span><br><span class="line">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。</span><br><span class="line">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。</span><br><span class="line">使用JDK提供的不变类(immutableclass)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。</span><br><span class="line">编程的时候接口优于实现。</span><br><span class="line">底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</span><br></pre></td></tr></table></figure><h5 id="33、Enumeration接口和Iterator接口的区别有哪些？"><a href="#33、Enumeration接口和Iterator接口的区别有哪些？" class="headerlink" title="33、Enumeration接口和Iterator接口的区别有哪些？"></a>33、Enumeration接口和Iterator接口的区别有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</span><br></pre></td></tr></table></figure><h5 id="34、HashSet和TreeSet有什么区别？"><a href="#34、HashSet和TreeSet有什么区别？" class="headerlink" title="34、HashSet和TreeSet有什么区别？"></a>34、HashSet和TreeSet有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</span><br><span class="line">另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</span><br></pre></td></tr></table></figure><h5 id="35、Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#35、Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="35、Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>35、Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。</span><br><span class="line"></span><br><span class="line">垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</span><br></pre></td></tr></table></figure><h5 id="36、System-gc-和Runtime-gc-会做什么事情？"><a href="#36、System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="36、System.gc()和Runtime.gc()会做什么事情？"></a>36、System.gc()和Runtime.gc()会做什么事情？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</span><br></pre></td></tr></table></figure><h5 id="37、finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#37、finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="37、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>37、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收器(garbagecollector)决定回收某对象时，就会运行该对象的finalize()方法但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(JavaNativeInterface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</span><br></pre></td></tr></table></figure><h5 id="38、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#38、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="38、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>38、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</span><br></pre></td></tr></table></figure><h5 id="39、Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space"><a href="#39、Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space" class="headerlink" title="39、Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?"></a>39、Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</span><br><span class="line"></span><br><span class="line">堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">永久代是用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类的方法(字节码...)</span><br><span class="line">类名(Sring对象)</span><br><span class="line">.class文件读到的常量信息</span><br><span class="line">class对象相关的对象列表和类型列表(e.g.,方法对象的array).</span><br><span class="line">JVM创建的内部对象</span><br><span class="line">JIT编译器优化用的信息</span><br></pre></td></tr></table></figure><h5 id="40、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#40、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="40、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>40、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</span><br></pre></td></tr></table></figure><h5 id="41、在Java中，对象什么时候可以被垃圾回收？"><a href="#41、在Java中，对象什么时候可以被垃圾回收？" class="headerlink" title="41、在Java中，对象什么时候可以被垃圾回收？"></a>41、在Java中，对象什么时候可以被垃圾回收？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</span><br></pre></td></tr></table></figure><h5 id="42、JVM的永久代中会发生垃圾回收么？"><a href="#42、JVM的永久代中会发生垃圾回收么？" class="headerlink" title="42、JVM的永久代中会发生垃圾回收么？"></a>42、JVM的永久代中会发生垃圾回收么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(FullGC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免FullGC是非常重要的原因。请参考下Java8：从永久代到元数据区</span><br><span class="line">(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</span><br></pre></td></tr></table></figure><h5 id="43、Java中的两种异常类型是什么？他们有什么区别？"><a href="#43、Java中的两种异常类型是什么？他们有什么区别？" class="headerlink" title="43、Java中的两种异常类型是什么？他们有什么区别？"></a>43、Java中的两种异常类型是什么？他们有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。</span><br></pre></td></tr></table></figure><h5 id="44、Java中Exception和Error有什么区别？"><a href="#44、Java中Exception和Error有什么区别？" class="headerlink" title="44、Java中Exception和Error有什么区别？"></a>44、Java中Exception和Error有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。</span><br></pre></td></tr></table></figure><h5 id="45、throw和throws有什么区别？"><a href="#45、throw和throws有什么区别？" class="headerlink" title="45、throw和throws有什么区别？"></a>45、throw和throws有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Throw用于方法内部，Throws用于方法声明上</span><br><span class="line"></span><br><span class="line">2、Throw后跟异常对象，Throws后跟异常类型</span><br><span class="line"></span><br><span class="line">3、Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型</span><br></pre></td></tr></table></figure><h5 id="46、异常处理完成以后，Exception对象会发生什么变化？"><a href="#46、异常处理完成以后，Exception对象会发生什么变化？" class="headerlink" title="46、异常处理完成以后，Exception对象会发生什么变化？"></a>46、异常处理完成以后，Exception对象会发生什么变化？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception对象会在下一个垃圾回收过程中被回收掉。</span><br></pre></td></tr></table></figure><h5 id="47、finally代码块和finalize-方法有什么区别？"><a href="#47、finally代码块和finalize-方法有什么区别？" class="headerlink" title="47、finally代码块和finalize()方法有什么区别？"></a>47、finally代码块和finalize()方法有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。</span><br></pre></td></tr></table></figure><h5 id="48、什么是Applet？"><a href="#48、什么是Applet？" class="headerlink" title="48、什么是Applet？"></a>48、什么是Applet？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javaapplet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。</span><br></pre></td></tr></table></figure><h5 id="49、解释一下Applet的生命周期"><a href="#49、解释一下Applet的生命周期" class="headerlink" title="49、解释一下Applet的生命周期"></a>49、解释一下Applet的生命周期</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">applet可以经历下面的状态：</span><br><span class="line">Init：每次被载入的时候都会被初始化。</span><br><span class="line">Start：开始执行applet。</span><br><span class="line">Stop：结束执行applet。</span><br><span class="line">Destroy：卸载applet之前，做最后的清理工作。</span><br></pre></td></tr></table></figure><h5 id="50、当applet被载入的时候会发生什么？"><a href="#50、当applet被载入的时候会发生什么？" class="headerlink" title="50、当applet被载入的时候会发生什么？"></a>50、当applet被载入的时候会发生什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，创建applet控制类的实例，然后初始化applet，最后开始运行。</span><br></pre></td></tr></table></figure><h5 id="51、Applet和普通的Java应用程序有什么区别？"><a href="#51、Applet和普通的Java应用程序有什么区别？" class="headerlink" title="51、Applet和普通的Java应用程序有什么区别？"></a>51、Applet和普通的Java应用程序有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。</span><br><span class="line">进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Javaapplet不需要这样的函数来开始执行。</span><br><span class="line">最后，Javaapplet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。</span><br></pre></td></tr></table></figure><h5 id="52、Java-applet有哪些限制条件？"><a href="#52、Java-applet有哪些限制条件？" class="headerlink" title="52、Java applet有哪些限制条件？"></a>52、Java applet有哪些限制条件？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要是由于安全的原因，给applet施加了以下的限制：</span><br><span class="line">applet不能够载入类库或者定义本地方法。</span><br><span class="line">applet不能在宿主机上读写文件。</span><br><span class="line">applet不能读取特定的系统属性。</span><br><span class="line">applet不能发起网络连接，除非是跟宿主机。</span><br><span class="line">applet不能够开启宿主机上其他任何的程序。</span><br></pre></td></tr></table></figure><h5 id="53、什么是不受信任的applet？"><a href="#53、什么是不受信任的applet？" class="headerlink" title="53、什么是不受信任的applet？"></a>53、什么是不受信任的applet？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不受信任的applet是不能访问或是执行本地系统文件的Javaapplet，默认情况下，所有下载的applet都是不受信任的。</span><br></pre></td></tr></table></figure><h5 id="54、从网络上加载的applet和从本地文件系统加载的applet有什么区别？"><a href="#54、从网络上加载的applet和从本地文件系统加载的applet有什么区别？" class="headerlink" title="54、从网络上加载的applet和从本地文件系统加载的applet有什么区别？"></a>54、从网络上加载的applet和从本地文件系统加载的applet有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。</span><br><span class="line">当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。</span><br><span class="line">从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。</span><br></pre></td></tr></table></figure><h5 id="55、applet类加载器是什么？它会做哪些工作？"><a href="#55、applet类加载器是什么？它会做哪些工作？" class="headerlink" title="55、applet类加载器是什么？它会做哪些工作？"></a>55、applet类加载器是什么？它会做哪些工作？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。</span><br><span class="line">当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stackoverflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。</span><br></pre></td></tr></table></figure><h5 id="56、applet安全管理器是什么？它会做哪些工作？"><a href="#56、applet安全管理器是什么？它会做哪些工作？" class="headerlink" title="56、applet安全管理器是什么？它会做哪些工作？"></a>56、applet安全管理器是什么？它会做哪些工作？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。</span><br></pre></td></tr></table></figure><h5 id="57、弹出式选择菜单-Choice-和列表-List-有什么区别"><a href="#57、弹出式选择菜单-Choice-和列表-List-有什么区别" class="headerlink" title="57、弹出式选择菜单(Choice)和列表(List)有什么区别"></a>57、弹出式选择菜单(Choice)和列表(List)有什么区别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。</span><br></pre></td></tr></table></figure><h5 id="58、什么是布局管理器？"><a href="#58、什么是布局管理器？" class="headerlink" title="58、什么是布局管理器？"></a>58、什么是布局管理器？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">布局管理器用来在容器中组织组件。</span><br></pre></td></tr></table></figure><h5 id="59、滚动条-Scrollbar-和滚动面板-JScrollPane-有什么区别？"><a href="#59、滚动条-Scrollbar-和滚动面板-JScrollPane-有什么区别？" class="headerlink" title="59、滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？"></a>59、滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。</span><br></pre></td></tr></table></figure><h5 id="60、哪些Swing的方法是线程安全的？"><a href="#60、哪些Swing的方法是线程安全的？" class="headerlink" title="60、哪些Swing的方法是线程安全的？"></a>60、哪些Swing的方法是线程安全的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只有3个线程安全的方法：repaint(),revalidate(),andinvalidate()。</span><br></pre></td></tr></table></figure><h5 id="61、说出三种支持重绘-painting-的组件。"><a href="#61、说出三种支持重绘-painting-的组件。" class="headerlink" title="61、说出三种支持重绘(painting)的组件。"></a>61、说出三种支持重绘(painting)的组件。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Canvas,Frame,Panel,和Applet支持重绘。</span><br></pre></td></tr></table></figure><h5 id="62、什么是裁剪-clipping-？"><a href="#62、什么是裁剪-clipping-？" class="headerlink" title="62、什么是裁剪(clipping)？"></a>62、什么是裁剪(clipping)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">限制在一个给定的区域或者形状的绘图操作叫做裁剪。</span><br></pre></td></tr></table></figure><h5 id="63、MenuItem和CheckboxMenuItem的区别是什么？"><a href="#63、MenuItem和CheckboxMenuItem的区别是什么？" class="headerlink" title="63、MenuItem和CheckboxMenuItem的区别是什么？"></a>63、MenuItem和CheckboxMenuItem的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。</span><br></pre></td></tr></table></figure><h5 id="64、边缘布局-BorderLayout-里面的元素是如何布局的？"><a href="#64、边缘布局-BorderLayout-里面的元素是如何布局的？" class="headerlink" title="64、边缘布局(BorderLayout)里面的元素是如何布局的？"></a>64、边缘布局(BorderLayout)里面的元素是如何布局的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BorderLayout里面的元素是按照容器的东西南北中进行布局的。</span><br></pre></td></tr></table></figure><h5 id="65、网格包布局-GridBagLayout-里面的元素是如何布局的？"><a href="#65、网格包布局-GridBagLayout-里面的元素是如何布局的？" class="headerlink" title="65、网格包布局(GridBagLayout)里面的元素是如何布局的？"></a>65、网格包布局(GridBagLayout)里面的元素是如何布局的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。</span><br></pre></td></tr></table></figure><h5 id="66、Window和Frame有什么区别？"><a href="#66、Window和Frame有什么区别？" class="headerlink" title="66、Window和Frame有什么区别？"></a>66、Window和Frame有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。</span><br></pre></td></tr></table></figure><h5 id="67、裁剪-clipping-和重绘-repainting-有什么联系？"><a href="#67、裁剪-clipping-和重绘-repainting-有什么联系？" class="headerlink" title="67、裁剪(clipping)和重绘(repainting)有什么联系？"></a>67、裁剪(clipping)和重绘(repainting)有什么联系？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。</span><br></pre></td></tr></table></figure><h5 id="68、事件监听器接口-event-listener-interface-和事件适配器-event-adapter-有什么关系？"><a href="#68、事件监听器接口-event-listener-interface-和事件适配器-event-adapter-有什么关系？" class="headerlink" title="68、事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？"></a>68、事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。</span><br></pre></td></tr></table></figure><h5 id="69、GUI组件如何来处理它自己的事件？"><a href="#69、GUI组件如何来处理它自己的事件？" class="headerlink" title="69、GUI组件如何来处理它自己的事件？"></a>69、GUI组件如何来处理它自己的事件？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。</span><br></pre></td></tr></table></figure><h5 id="70、Java的布局管理器比传统的窗口系统有哪些优势？"><a href="#70、Java的布局管理器比传统的窗口系统有哪些优势？" class="headerlink" title="70、Java的布局管理器比传统的窗口系统有哪些优势？"></a>70、Java的布局管理器比传统的窗口系统有哪些优势？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。</span><br></pre></td></tr></table></figure><h5 id="71、Java的Swing组件使用了哪种设计模式？"><a href="#71、Java的Swing组件使用了哪种设计模式？" class="headerlink" title="71、Java的Swing组件使用了哪种设计模式？"></a>71、Java的Swing组件使用了哪种设计模式？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的Swing组件使用了MVC（模型-视图-控制器)设计模式。</span><br></pre></td></tr></table></figure><h5 id="72、什么是JDBC？"><a href="#72、什么是JDBC？" class="headerlink" title="72、什么是JDBC？"></a>72、什么是JDBC？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。</span><br></pre></td></tr></table></figure><h5 id="73、解释下驱动-Driver-在JDBC中的角色。"><a href="#73、解释下驱动-Driver-在JDBC中的角色。" class="headerlink" title="73、解释下驱动(Driver)在JDBC中的角色。"></a>73、解释下驱动(Driver)在JDBC中的角色。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC驱动提供了特定厂商对JDBCAPI接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection,Statement,PreparedStatement,CallableStatement,ResultSet和Driver。</span><br></pre></td></tr></table></figure><h5 id="74、Class-forName-方法有什么作用？"><a href="#74、Class-forName-方法有什么作用？" class="headerlink" title="74、Class.forName()方法有什么作用？"></a>74、Class.forName()方法有什么作用？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化参数指定的类，并且返回此类对应的Class对象</span><br></pre></td></tr></table></figure><h5 id="75、PreparedStatement比Statement有什么优势？"><a href="#75、PreparedStatement比Statement有什么优势？" class="headerlink" title="75、PreparedStatement比Statement有什么优势？"></a>75、PreparedStatement比Statement有什么优势？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。</span><br></pre></td></tr></table></figure><h5 id="76、什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？"><a href="#76、什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？" class="headerlink" title="76、什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？"></a>76、什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：</span><br><span class="line">CallableStatementConnection.prepareCall();</span><br></pre></td></tr></table></figure><h5 id="77、数据库连接池是什么意思？"><a href="#77、数据库连接池是什么意思？" class="headerlink" title="77、数据库连接池是什么意思？"></a>77、数据库连接池是什么意思？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</span><br></pre></td></tr></table></figure><h5 id="78、什么是RMI？"><a href="#78、什么是RMI？" class="headerlink" title="78、什么是RMI？"></a>78、什么是RMI？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java远程方法调用(JavaRMI)是JavaAPI对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。</span><br></pre></td></tr></table></figure><h5 id="79、RMI体系结构的基本原则是什么？"><a href="#79、RMI体系结构的基本原则是什么？" class="headerlink" title="79、RMI体系结构的基本原则是什么？"></a>79、RMI体系结构的基本原则是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。</span><br></pre></td></tr></table></figure><h5 id="80、RMI体系结构分哪几层？"><a href="#80、RMI体系结构分哪几层？" class="headerlink" title="80、RMI体系结构分哪几层？"></a>80、RMI体系结构分哪几层？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMI体系结构分以下几层：</span><br><span class="line">存根和骨架层(StubandSkeletonlayer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。</span><br><span class="line">远程引用层(RemoteReferenceLayer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</span><br><span class="line">传输层(Transportlayer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</span><br></pre></td></tr></table></figure><h5 id="81、RMI中的远程接口-Remote-Interface-扮演了什么样的角色？"><a href="#81、RMI中的远程接口-Remote-Interface-扮演了什么样的角色？" class="headerlink" title="81、RMI中的远程接口(Remote Interface)扮演了什么样的角色？"></a>81、RMI中的远程接口(Remote Interface)扮演了什么样的角色？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</span><br></pre></td></tr></table></figure><h5 id="82、java-rmi-Naming类扮演了什么样的角色？"><a href="#82、java-rmi-Naming类扮演了什么样的角色？" class="headerlink" title="82、java.rmi.Naming类扮演了什么样的角色？"></a>82、java.rmi.Naming类扮演了什么样的角色？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。</span><br></pre></td></tr></table></figure><h5 id="83、RMI的绑定-Binding-是什么意思？"><a href="#83、RMI的绑定-Binding-是什么意思？" class="headerlink" title="83、RMI的绑定(Binding)是什么意思？"></a>83、RMI的绑定(Binding)是什么意思？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。</span><br></pre></td></tr></table></figure><h5 id="84、Naming类的bind-和rebind-方法有什么区别？"><a href="#84、Naming类的bind-和rebind-方法有什么区别？" class="headerlink" title="84、Naming类的bind()和rebind()方法有什么区别？"></a>84、Naming类的bind()和rebind()方法有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</span><br></pre></td></tr></table></figure><h5 id="85、让RMI程序能正确运行有哪些步骤？"><a href="#85、让RMI程序能正确运行有哪些步骤？" class="headerlink" title="85、让RMI程序能正确运行有哪些步骤？"></a>85、让RMI程序能正确运行有哪些步骤？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了让RMI程序能正确运行必须要包含以下几个步骤：</span><br><span class="line">编译所有的源文件。</span><br><span class="line">使用rmic生成stub。</span><br><span class="line">启动rmiregistry。</span><br><span class="line">启动RMI服务器。</span><br><span class="line">运行客户端程序。</span><br></pre></td></tr></table></figure><h5 id="86、RMI的stub扮演了什么样的角色？"><a href="#86、RMI的stub扮演了什么样的角色？" class="headerlink" title="86、RMI的stub扮演了什么样的角色？"></a>86、RMI的stub扮演了什么样的角色？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：</span><br><span class="line">初始化到包含了远程对象的JVM的连接。</span><br><span class="line">序列化参数到远程的JVM。</span><br><span class="line">等待方法调用和执行的结果。</span><br><span class="line">反序列化返回的值或者是方法没有执行成功情况下的异常。</span><br><span class="line">把值返回给调用者。</span><br></pre></td></tr></table></figure><h5 id="87、什么是分布式垃圾回收-DGC-？它是如何工作的？"><a href="#87、什么是分布式垃圾回收-DGC-？它是如何工作的？" class="headerlink" title="87、什么是分布式垃圾回收(DGC)？它是如何工作的？"></a>87、什么是分布式垃圾回收(DGC)？它是如何工作的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。</span><br></pre></td></tr></table></figure><h5 id="88、RMI中使用RMI安全管理器-RMISecurityManager-的目的是什么？"><a href="#88、RMI中使用RMI安全管理器-RMISecurityManager-的目的是什么？" class="headerlink" title="88、RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？"></a>88、RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。</span><br></pre></td></tr></table></figure><h5 id="89、解释下Marshalling和demarshalling。"><a href="#89、解释下Marshalling和demarshalling。" class="headerlink" title="89、解释下Marshalling和demarshalling。"></a>89、解释下Marshalling和demarshalling。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。</span><br></pre></td></tr></table></figure><h5 id="90、解释下Serialization和Deserialization。"><a href="#90、解释下Serialization和Deserialization。" class="headerlink" title="90、解释下Serialization和Deserialization。"></a>90、解释下Serialization和Deserialization。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</span><br><span class="line">Servlet</span><br></pre></td></tr></table></figure><h5 id="91、什么是Servlet？"><a href="#91、什么是Servlet？" class="headerlink" title="91、什么是Servlet？"></a>91、什么是Servlet？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</span><br></pre></td></tr></table></figure><h5 id="92、说一下Servlet的体系结构。"><a href="#92、说一下Servlet的体系结构。" class="headerlink" title="92、说一下Servlet的体系结构。"></a>92、说一下Servlet的体系结构。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</span><br></pre></td></tr></table></figure><h5 id="93、Applet和Servlet有什么区别？"><a href="#93、Applet和Servlet有什么区别？" class="headerlink" title="93、Applet和Servlet有什么区别？"></a>93、Applet和Servlet有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。</span><br></pre></td></tr></table></figure><h5 id="94、GenericServlet和HttpServlet有什么区别？"><a href="#94、GenericServlet和HttpServlet有什么区别？" class="headerlink" title="94、GenericServlet和HttpServlet有什么区别？"></a>94、GenericServlet和HttpServlet有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。</span><br><span class="line"></span><br><span class="line">HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理HTTP请求的应用灵活的方法。</span><br></pre></td></tr></table></figure><h5 id="95、解释下Servlet的生命周期。"><a href="#95、解释下Servlet的生命周期。" class="headerlink" title="95、解释下Servlet的生命周期。"></a>95、解释下Servlet的生命周期。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。</span><br></pre></td></tr></table></figure><h5 id="96、doGet-方法和doPost-方法有什么区别？"><a href="#96、doGet-方法和doPost-方法有什么区别？" class="headerlink" title="96、doGet()方法和doPost()方法有什么区别？"></a>96、doGet()方法和doPost()方法有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</span><br><span class="line">doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</span><br></pre></td></tr></table></figure><h5 id="97、什么是Web应用程序？"><a href="#97、什么是Web应用程序？" class="headerlink" title="97、什么是Web应用程序？"></a>97、什么是Web应用程序？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。</span><br></pre></td></tr></table></figure><h5 id="98、什么是服务端包含-Server-Side-Include-？"><a href="#98、什么是服务端包含-Server-Side-Include-？" class="headerlink" title="98、什么是服务端包含(Server Side Include)？"></a>98、什么是服务端包含(Server Side Include)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。</span><br></pre></td></tr></table></figure><h5 id="99、什么是Servlet链-Servlet-Chaining-？"><a href="#99、什么是Servlet链-Servlet-Chaining-？" class="headerlink" title="99、什么是Servlet链(Servlet Chaining)？"></a>99、什么是Servlet链(Servlet Chaining)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。</span><br></pre></td></tr></table></figure><h5 id="100、如何知道是哪一个客户端的机器正在请求你的Servlet？"><a href="#100、如何知道是哪一个客户端的机器正在请求你的Servlet？" class="headerlink" title="100、如何知道是哪一个客户端的机器正在请求你的Servlet？"></a>100、如何知道是哪一个客户端的机器正在请求你的Servlet？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。</span><br></pre></td></tr></table></figure><h5 id="101、HTTP响应的结构是怎么样的？"><a href="#101、HTTP响应的结构是怎么样的？" class="headerlink" title="101、HTTP响应的结构是怎么样的？"></a>101、HTTP响应的结构是怎么样的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP响应由三个部分组成：</span><br><span class="line">状态码(StatusCode)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。</span><br><span class="line">HTTP头部(HTTPHeader)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。</span><br><span class="line">主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</span><br></pre></td></tr></table></figure><h5 id="102、什么是cookie？session和cookie有什么区别？"><a href="#102、什么是cookie？session和cookie有什么区别？" class="headerlink" title="102、什么是cookie？session和cookie有什么区别？"></a>102、什么是cookie？session和cookie有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：</span><br><span class="line">无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。</span><br><span class="line">在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。</span><br></pre></td></tr></table></figure><h5 id="103、浏览器和Servlet通信使用的是什么协议？"><a href="#103、浏览器和Servlet通信使用的是什么协议？" class="headerlink" title="103、浏览器和Servlet通信使用的是什么协议？"></a>103、浏览器和Servlet通信使用的是什么协议？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器和Servlet通信使用的是HTTP协议。</span><br></pre></td></tr></table></figure><h5 id="104、什么是HTTP隧道？"><a href="#104、什么是HTTP隧道？" class="headerlink" title="104、什么是HTTP隧道？"></a>104、什么是HTTP隧道？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。</span><br></pre></td></tr></table></figure><h5 id="105、sendRedirect-和forward-方法有什么区别？"><a href="#105、sendRedirect-和forward-方法有什么区别？" class="headerlink" title="105、sendRedirect()和forward()方法有什么区别？"></a>105、sendRedirect()和forward()方法有什么区别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。</span><br></pre></td></tr></table></figure><h5 id="106、什么是URL编码和URL解码？"><a href="#106、什么是URL编码和URL解码？" class="headerlink" title="106、什么是URL编码和URL解码？"></a>106、什么是URL编码和URL解码？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</span><br></pre></td></tr></table></figure><h5 id="107、什么是JSP页面？"><a href="#107、什么是JSP页面？" class="headerlink" title="107、什么是JSP页面？"></a>107、什么是JSP页面？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。</span><br></pre></td></tr></table></figure><h5 id="108、JSP请求是如何被处理的？"><a href="#108、JSP请求是如何被处理的？" class="headerlink" title="108、JSP请求是如何被处理的？"></a>108、JSP请求是如何被处理的？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。</span><br></pre></td></tr></table></figure><h5 id="109、JSP有什么优点？"><a href="#109、JSP有什么优点？" class="headerlink" title="109、JSP有什么优点？"></a>109、JSP有什么优点？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面列出了使用JSP的优点：</span><br><span class="line">JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。</span><br><span class="line">JSP页面可以被预编译。</span><br><span class="line">JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。</span><br><span class="line">开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。</span><br><span class="line">开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</span><br></pre></td></tr></table></figure><h5 id="110、什么是JSP指令-Directive-？JSP中有哪些不同类型的指令？"><a href="#110、什么是JSP指令-Directive-？JSP中有哪些不同类型的指令？" class="headerlink" title="110、什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？"></a>110、什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在之间的。下面列出了不同类型的Directive：</span><br><span class="line">包含指令(Includedirective)：用来包含文件和合并文件内容到当前的页面。</span><br><span class="line">页面指令(Pagedirective)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。</span><br><span class="line">Taglib指令：用来声明页面中使用的自定义的标签库。</span><br></pre></td></tr></table></figure><h5 id="111、什么是JSP动作-JSP-action-？"><a href="#111、什么是JSP动作-JSP-action-？" class="headerlink" title="111、什么是JSP动作(JSP action)？"></a>111、什么是JSP动作(JSP action)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：</span><br><span class="line">jsp:include-当JSP页面被请求的时候包含一个文件。</span><br><span class="line">jsp:useBean-找出或者是初始化Javabean。</span><br><span class="line">jsp:setProperty-设置JavaBean的属性。</span><br><span class="line">jsp:getProperty-获取JavaBean的属性。</span><br><span class="line">jsp:forward-把请求转发到新的页面。</span><br><span class="line">jsp:plugin-产生特定浏览器的代码。</span><br></pre></td></tr></table></figure><h5 id="112、什么是Scriptlets？"><a href="#112、什么是Scriptlets？" class="headerlink" title="112、什么是Scriptlets？"></a>112、什么是Scriptlets？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。</span><br></pre></td></tr></table></figure><h5 id="113、声明-Decalaration-在哪里？"><a href="#113、声明-Decalaration-在哪里？" class="headerlink" title="113、声明(Decalaration)在哪里？"></a>113、声明(Decalaration)在哪里？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。</span><br></pre></td></tr></table></figure><h5 id="114、什么是表达式-Expression-？"><a href="#114、什么是表达式-Expression-？" class="headerlink" title="114、什么是表达式(Expression)？"></a>114、什么是表达式(Expression)？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【列表很长，可以分上、中、下发布】</span><br><span class="line">JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在这两个标签之间定义的。</span><br></pre></td></tr></table></figure><h5 id="115、隐含对象是什么意思？有哪些隐含对象？"><a href="#115、隐含对象是什么意思？有哪些隐含对象？" class="headerlink" title="115、隐含对象是什么意思？有哪些隐含对象？"></a>115、隐含对象是什么意思？有哪些隐含对象？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：</span><br><span class="line">application</span><br><span class="line">page</span><br><span class="line">request</span><br><span class="line">response</span><br><span class="line">session</span><br><span class="line">exception</span><br><span class="line">out</span><br><span class="line">config</span><br><span class="line">pageContext</span><br></pre></td></tr></table></figure><h5 id="116、面向对象软件开发的优点有哪些？"><a href="#116、面向对象软件开发的优点有哪些？" class="headerlink" title="116、面向对象软件开发的优点有哪些？"></a>116、面向对象软件开发的优点有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码开发模块化，更易维护和修改。</span><br><span class="line">代码复用。</span><br><span class="line">增强代码的可靠性和灵活性。</span><br><span class="line">增加代码的可理解性。</span><br><span class="line">面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。</span><br></pre></td></tr></table></figure><h5 id="117、封装的定义和好处有哪些？"><a href="#117、封装的定义和好处有哪些？" class="headerlink" title="117、封装的定义和好处有哪些？"></a>117、封装的定义和好处有哪些？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</span><br><span class="line">下面列出了使用封装的一些好处：</span><br><span class="line">通过隐藏对象的属性来保护对象内部的状态。</span><br><span class="line">提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</span><br><span class="line">禁止对象之间的不良交互提高模块化。</span><br><span class="line"></span><br><span class="line">参考这个文档获取更多关于封装的细节和示例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一是用private把类的细节与外界隔离起来，从而实现数据项和方法的隐藏，而要访问这些数据项和方法唯一的途径就是通过类本身，类才有资格调用它所拥有的资源（方法，数据项属性等等）。所以第一个好处就是数据的安全性提高了。二是通过隐藏隔离，只允许外部对类做有限的访问，开发者可以自由的改变类的内部实现，而无需修改使用该类的那些程序。只要那些在类外部就能被调用的方法保持其外部特征不变，内部代码就可以自由改变，各取所需，利于分工。</span><br><span class="line">三就是提高了代码的重用性，封装成工具类以后能够减少很多繁琐的步骤。</span><br></pre></td></tr></table></figure><h5 id="118、多态的定义？"><a href="#118、多态的定义？" class="headerlink" title="118、多态的定义？"></a>118、多态的定义？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</span><br></pre></td></tr></table></figure><h5 id="119、继承的定义？"><a href="#119、继承的定义？" class="headerlink" title="119、继承的定义？"></a>119、继承的定义？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。</span><br></pre></td></tr></table></figure><h5 id="120、抽象的定义？抽象和封装的不同点？"><a href="#120、抽象的定义？抽象和封装的不同点？" class="headerlink" title="120、抽象的定义？抽象和封装的不同点？"></a>120、抽象的定义？抽象和封装的不同点？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</span><br><span class="line">抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</span><br></pre></td></tr></table></figure><h5 id="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？-1"><a href="#1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？-1" class="headerlink" title="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</span><br><span class="line">Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span><br></pre></td></tr></table></figure><h5 id="2、JDK和JRE的区别是什么？-1"><a href="#2、JDK和JRE的区别是什么？-1" class="headerlink" title="2、JDK和JRE的区别是什么？"></a>2、JDK和JRE的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）--编译器、调试器和其他工具。</span><br><span class="line"></span><br><span class="line">Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</span><br></pre></td></tr></table></figure><h5 id="3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？-1"><a href="#3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？-1" class="headerlink" title="3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span><br><span class="line"></span><br><span class="line">Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</span><br><span class="line"></span><br><span class="line">java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</span><br></pre></td></tr></table></figure><h5 id="4、是否可以在static环境中访问非static变量？-1"><a href="#4、是否可以在static环境中访问非static变量？-1" class="headerlink" title="4、是否可以在static环境中访问非static变量？"></a>4、是否可以在static环境中访问非static变量？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span><br></pre></td></tr></table></figure><h5 id="5、Java支持的数据类型有哪些？什么是自动拆装箱？-1"><a href="#5、Java支持的数据类型有哪些？什么是自动拆装箱？-1" class="headerlink" title="5、Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5、Java支持的数据类型有哪些？什么是自动拆装箱？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br><span class="line"></span><br><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short,boolean,int,long,float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程</span><br></pre></td></tr></table></figure><h5 id="6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？-1"><a href="#6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？-1" class="headerlink" title="6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span><br></pre></td></tr></table></figure><h5 id="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？-1"><a href="#7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？-1" class="headerlink" title="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。</span><br><span class="line">Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</span><br><span class="line">Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</span><br></pre></td></tr></table></figure><h5 id="8、Java支持多继承么？-1"><a href="#8、Java支持多继承么？-1" class="headerlink" title="8、Java支持多继承么？"></a>8、Java支持多继承么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</span><br></pre></td></tr></table></figure><h5 id="9、接口和抽象类的区别是什么？-1"><a href="#9、接口和抽象类的区别是什么？-1" class="headerlink" title="9、接口和抽象类的区别是什么？"></a>9、接口和抽象类的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span><br><span class="line">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</span><br><span class="line">类可以实现很多个接口，但是只能继承一个抽象类</span><br><span class="line">类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</span><br><span class="line">抽象类可以在不提供接口方法实现的情况下实现接口。</span><br><span class="line">Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</span><br><span class="line">Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</span><br><span class="line">接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</span><br><span class="line">也可以参考JDK8中抽象类和接口的区别</span><br></pre></td></tr></table></figure><h5 id="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？-2"><a href="#1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？-2" class="headerlink" title="1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</span><br><span class="line">Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span><br></pre></td></tr></table></figure><h5 id="2、JDK和JRE的区别是什么？-2"><a href="#2、JDK和JRE的区别是什么？-2" class="headerlink" title="2、JDK和JRE的区别是什么？"></a>2、JDK和JRE的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）--编译器、调试器和其他工具。</span><br><span class="line"></span><br><span class="line">Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</span><br></pre></td></tr></table></figure><h5 id="3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？-2"><a href="#3、”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？-2" class="headerlink" title="3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span><br><span class="line"></span><br><span class="line">Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</span><br><span class="line"></span><br><span class="line">java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</span><br></pre></td></tr></table></figure><h5 id="4、是否可以在static环境中访问非static变量？-2"><a href="#4、是否可以在static环境中访问非static变量？-2" class="headerlink" title="4、是否可以在static环境中访问非static变量？"></a>4、是否可以在static环境中访问非static变量？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span><br></pre></td></tr></table></figure><h5 id="5、Java支持的数据类型有哪些？什么是自动拆装箱？-2"><a href="#5、Java支持的数据类型有哪些？什么是自动拆装箱？-2" class="headerlink" title="5、Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5、Java支持的数据类型有哪些？什么是自动拆装箱？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java语言支持的8种基本数据类型是：</span><br><span class="line">byte</span><br><span class="line">short</span><br><span class="line">int</span><br><span class="line">long</span><br><span class="line">float</span><br><span class="line">double</span><br><span class="line">boolean</span><br><span class="line">char</span><br><span class="line"></span><br><span class="line">自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short,boolean,int,long,float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程</span><br></pre></td></tr></table></figure><h5 id="6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？-2"><a href="#6、Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？-2" class="headerlink" title="6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6、Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span><br></pre></td></tr></table></figure><h5 id="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？-2"><a href="#7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？-2" class="headerlink" title="7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。</span><br><span class="line">Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</span><br><span class="line">Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</span><br></pre></td></tr></table></figure><h5 id="8、Java支持多继承么？-2"><a href="#8、Java支持多继承么？-2" class="headerlink" title="8、Java支持多继承么？"></a>8、Java支持多继承么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</span><br></pre></td></tr></table></figure><h5 id="9、接口和抽象类的区别是什么？-2"><a href="#9、接口和抽象类的区别是什么？-2" class="headerlink" title="9、接口和抽象类的区别是什么？"></a>9、接口和抽象类的区别是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span><br><span class="line">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</span><br><span class="line">类可以实现很多个接口，但是只能继承一个抽象类</span><br><span class="line">类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</span><br><span class="line">抽象类可以在不提供接口方法实现的情况下实现接口。</span><br><span class="line">Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</span><br><span class="line">Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</span><br><span class="line">接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</span><br><span class="line">也可以参考JDK8中抽象类和接口的区别</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>课程设计结业说明</title>
    <url>/2019/06/28/%E5%90%B4%E4%BD%B3%E5%AE%B8%E3%80%81%E5%90%B4%E5%A5%87%E5%A5%87%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%BB%93%E4%B8%9A%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="吴佳宸、吴奇奇课程设计结业报告"><a href="#吴佳宸、吴奇奇课程设计结业报告" class="headerlink" title="吴佳宸、吴奇奇课程设计结业报告"></a>吴佳宸、吴奇奇课程设计结业报告</h3><blockquote><p>在老师的带领下深入学习</p></blockquote><h3 id="数据细节化处理"><a href="#数据细节化处理" class="headerlink" title="数据细节化处理"></a>数据细节化处理</h3><ul><li>转化为标准的json格式（有些同学键值外面还有list，数据没处理干净，是传输不了的）</li><li>正则表达式，转为为可读性好的MarkDowm文章</li></ul><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="反爬难点突破"><a href="#反爬难点突破" class="headerlink" title="反爬难点突破"></a>反爬难点突破</h3><ul><li>对拉勾网进行了尝试</li><li>关键点是POST请求，获取实时cookie,转换IP地址，User-Agent</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣Top250</title>
    <url>/2019/06/26/python-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3Top250/</url>
    <content><![CDATA[<h1 id="爬取豆瓣Top250"><a href="#爬取豆瓣Top250" class="headerlink" title="爬取豆瓣Top250"></a>爬取豆瓣Top250</h1><blockquote><p>语言：python<br>使用库：requests(http请求数据), json(字典与json转换), xlwt(json与excel),lxml(解析xml，xpath)<br>爬取内容：豆瓣电影，图书，音乐Top250</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><hr><h3 id="主要方法步骤"><a href="#主要方法步骤" class="headerlink" title="主要方法步骤"></a>主要方法步骤</h3><ul><li>使用requests请求网页url，然后使用lxml把网页html解析解析下来</li><li>获取信息区块列表</li><li>分别爬取区块想要的信息存入字典</li><li>写入文件保存</li></ul><h3 id="值得注意点"><a href="#值得注意点" class="headerlink" title="值得注意点"></a>值得注意点</h3><ul><li>在使用pip安装的时候,由于是国外资源,下载速度很慢,可以使用国内镜像, 在cdm中输入<figure class="highlight plain"><figcaption><span>install -i</span><a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">requests(填库名) ```</a></figcaption><table><tr><td class="code"><pre><span class="line">* 获取节点方法  </span><br><span class="line">1.使用XPath获取节点[XPath语法](http://www.w3school.com.cn/xpath/xpath_syntax.asp)  </span><br><span class="line">去chrome插件市场下载 XPath Helper(方便检查)  </span><br><span class="line">[CssSelector组件将CSS选择器转换为XPath表达式](https://symfony.com/css-selector)  </span><br><span class="line">&gt; **为什么要使用CSS选择器？**  </span><br><span class="line">&gt; 当您解析HTML或XML文档时，到目前为止最强大的方法是XPath。  </span><br><span class="line">&gt; XPath表达式非常灵活，因此几乎总有一个XPath表达式可以找到您需要的元素。不幸的是，它们也变得非常复杂，学习曲线也很陡峭。即使是常见的操作（例如查找具有特定类的元素）也可能需要冗长且难以处理的表达式。  </span><br><span class="line">&gt; 许多开发人员 - 尤其是Web开发人员 - 更习惯使用CSS选择器来查找元素。除了在样式表中工作之外，CSS选择器还在JavaScript中使用，querySelectorAll()并且在jQuery，Prototype和MooTools等流行的JavaScript库中使用。  </span><br><span class="line">&gt; CSS选择器的功能不如XPath，但更容易编写，阅读和理解。由于它们功能较弱，几乎所有的CSS选择器都可以转换为XPath等价物。然后，此XPath表达式可以与使用XPath查找文档中的元素的其他函数和类一起使用。</span><br><span class="line"></span><br><span class="line">2.学前端的我觉得beautifulsoup很好用，因为直接css选择器获取节点，十分方便  </span><br><span class="line">安装```$ pip install beautifulsoup4```  </span><br><span class="line">[beautifulsoup4中文文档](https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/)</span><br><span class="line"></span><br><span class="line">### 主要代码</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import requests, json, xlwt</span><br><span class="line">from lxml import html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TopMoviesSpider:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url_temp = &quot;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&quot;</span><br><span class="line">        # https://book.douban.com/top250?start=&#123;&#125; 爬取豆瓣图书Top250</span><br><span class="line">        # https://music.douban.com/top250?start=25 豆瓣音乐Top250 节点可能有些不同写不同的xpath</span><br><span class="line">        self.headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span><br><span class="line">         AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36&quot;&#125;</span><br><span class="line"></span><br><span class="line">    # 爬取数据返回json</span><br><span class="line">    def run(self):</span><br><span class="line">        etree = html.etree  # 引入lxml</span><br><span class="line">        url_list = []</span><br><span class="line">        content_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            url_list.append(self.url_temp.format(i*25))</span><br><span class="line">            #  lxml解析文章（http请求，把user-Agent浏览器代理写入http头,模拟用户操作防止被检测，</span><br><span class="line">            # decode（）将内容解码)</span><br><span class="line">            response = etree.HTML(requests.get(url_list[i], headers=self.headers).content.decode())</span><br><span class="line">            div_list = response.xpath(&apos;//div[@class=&quot;info&quot;]&apos;)  # 获取当前页节点列表</span><br><span class="line">            for div in div_list:  # 循环节点，分别在每个节点里面取内容</span><br><span class="line">                item = dict()</span><br><span class="line">                item[&apos;author&apos;] = div.xpath(&apos;.//div[@class=&quot;hd&quot;]/a/span[1]/text()&apos;)[0]  # 提取题目</span><br><span class="line">                item[&apos;start&apos;] = div.xpath(&apos;.//div[@class=&quot;bd&quot;]/div/span[@class=&quot;rating_num&quot;]/text()&apos;)[0]  # 评分</span><br><span class="line">                item[&apos;text&apos;] = div.xpath(&apos;.//div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span/text()&apos;)[0]  # 简介</span><br><span class="line">                item[&apos;url&apos;] = div.xpath(&apos;.//div[@class=&quot;hd&quot;]/a/@href&apos;)[0]  # 获取URL</span><br><span class="line">                content_list.append(item)  # 添加到json列表末尾</span><br><span class="line">        return content_list</span><br><span class="line"></span><br><span class="line">    # 写入文件夹，缩进2空格</span><br><span class="line">    def jsonToTxt(self):</span><br><span class="line">         jsonMovie = self.run()</span><br><span class="line">         with open(&quot;topmovies.json&quot;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:  # 也可以改成.txt文件</span><br><span class="line">            f.write(json.dumps(jsonMovie, ensure_ascii=False, indent=2))</span><br><span class="line"></span><br><span class="line">    # 写入excel</span><br><span class="line">    def jsonToexcel(self):</span><br><span class="line">        jsonMovie = self.run()</span><br><span class="line">        workbook = xlwt.Workbook()  # 引入wlwt,workbook模块</span><br><span class="line">        sheet1 = workbook.add_sheet(&apos;TopMovie&apos;)</span><br><span class="line">        execelhead = list(jsonMovie[0].keys())  # 获取键名写入标题</span><br><span class="line">        for i in range(len(execelhead)):  # 标题写入头</span><br><span class="line">            sheet1.write(0, i, execelhead[i])</span><br><span class="line">        for j in range(0, len(jsonMovie)):  # 循环写入</span><br><span class="line">            m = 0</span><br><span class="line">            ls = list(jsonMovie[j].values())</span><br><span class="line">            for k in ls:</span><br><span class="line">                sheet1.write(j + 1, m, k)</span><br><span class="line">                m += 1</span><br><span class="line">        workbook.save(&apos;topmovies.xls&apos;)  #保存</span><br><span class="line"></span><br><span class="line">TopMoviesSpider().jsonToTxt()</span><br><span class="line">#TopMoviesSpider().jsonToexcel()</span><br></pre></td></tr></table></figure></li></ul><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="/images/loading.png" data-original="https://github.com/2249038142/grapDoubanTop250/blob/master/image/excel.png" alt="excel图"><br><img src="/images/loading.png" data-original="https://github.com/2249038142/grapDoubanTop250/blob/master/image/json.png" alt="json图"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫练习</title>
    <url>/2019/06/26/python-%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="python-爬虫练习五个小练习"><a href="#python-爬虫练习五个小练习" class="headerlink" title="python 爬虫练习五个小练习"></a>python 爬虫练习五个小练习</h1><h3 id="值得注意的点"><a href="#值得注意的点" class="headerlink" title="值得注意的点"></a>值得注意的点</h3><ul><li><p>使用xpath爬取的是一个list要取list[0]得到字符串</p></li><li><p>一些格式，生数据处理，</p><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。  </span><br><span class="line"></span><br><span class="line">    **注意：**该方法只能删除开头或是结尾的字符，不能删除中间部分的字符</span><br><span class="line"></span><br><span class="line">* 使用正则删除多余字符</span><br><span class="line"></span><br><span class="line">    ```b = re.compile()``````b.findall()</span><br></pre></td></tr></table></figure><p></p><pre><code>python暂时只会这个正则方法，reg匹配所有编程语言都是通用的</code></pre></li><li><p>xpath(……/text())获取文本</p></li><li><p>有些地方爬取的内容为空，运行就会报错，用if 判断xpath内容是否为空，else写入空内容的通用值</p></li></ul><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>从控制台找到要爬取的信息，无非就是html内容，json内容，ajax请求内容,获取到节点，写入字典，导出json</p><p>跟老师不同的是，删除了一些函数，写在一个里，因为python本身就是脚本编程语言，一行语句写一个函数无疑加大了代码阅读难度。就一点内容，没那么多类，函数可写。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h3 id="爬取内容"><a href="#爬取内容" class="headerlink" title="爬取内容"></a>爬取内容</h3><p><strong>1.豆瓣音乐top250</strong><br>url：<a href="https://music.douban.com/top250" target="_blank" rel="noopener">https://music.douban.com/top250</a><br>爬取歌名，作者，评分</p><ul><li>跟豆瓣电影类似</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, json, xlwt, re, time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopMusicSpider</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url_temp = <span class="string">" https://music.douban.com/top250?start=&#123;&#125;"</span></span><br><span class="line">        self.headers = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span></span><br><span class="line"><span class="string">         AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取数据返回json</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        etree = html.etree  <span class="comment"># 引入lxml</span></span><br><span class="line">        url_list = []</span><br><span class="line">        content_list = []</span><br><span class="line">        b = re.compile(<span class="string">'^(.*?)/'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            url_list.append(self.url_temp.format(i*<span class="number">25</span>))</span><br><span class="line">            <span class="comment">#  lxml解析文章（http请求，把user-Agent浏览器代理写入http头,模拟用户操作防止被检测，</span></span><br><span class="line">            <span class="comment"># decode（）将内容解码)</span></span><br><span class="line">            response = etree.HTML(requests.get(url_list[i], headers=self.headers).content.decode())</span><br><span class="line">            div_list = response.xpath(<span class="string">'//div[@class="pl2"]'</span>)  <span class="comment"># 获取当前页节点列表</span></span><br><span class="line">            <span class="keyword">for</span> div <span class="keyword">in</span> div_list:  <span class="comment"># 循环节点，分别在每个节点里面取内容</span></span><br><span class="line">                item = dict()</span><br><span class="line">                item[<span class="string">'title'</span>] = div.xpath(<span class="string">'./a[1]/text()'</span>)[<span class="number">0</span>].strip() <span class="comment"># 提取题目</span></span><br><span class="line">                item[<span class="string">'author'</span>]= b.findall(div.xpath(<span class="string">'./p/text()'</span>)[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                item[<span class="string">'start'</span>] = div.xpath(<span class="string">'./div/span[@class="rating_nums"]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">                content_list.append(item)</span><br><span class="line">            print(<span class="string">"已爬取&#123;&#125;页"</span>.format(i+<span class="number">1</span>))</span><br><span class="line">            <span class="comment">#time.sleep(1)</span></span><br><span class="line">        print(content_list)</span><br><span class="line">        <span class="keyword">return</span> content_list</span><br><span class="line">    <span class="comment"># 写入文件夹，缩进2空格</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jsonToTxt</span><span class="params">(self)</span>:</span></span><br><span class="line">        jsonmusic = self.run()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"topmusic.json"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:  <span class="comment"># 也可以改成.txt文件</span></span><br><span class="line">            f.write(json.dumps(jsonmusic, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TopMusicSpider().jsonToTxt()</span><br></pre></td></tr></table></figure><p><strong>2.理论文选</strong><br>url：<a href="http://www.qstheory.cn/qszq/llwx/index.htm" target="_blank" rel="noopener">http://www.qstheory.cn/qszq/llwx/index.htm</a><br>爬取标题，作者，来源，日期</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, json, xlwt, re, time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">truethSpider</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url = <span class="string">"http://www.qstheory.cn/qszq/llwx/index.htm"</span></span><br><span class="line">        self.headers = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span></span><br><span class="line"><span class="string">         AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取数据返回json</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        etree = html.etree  <span class="comment"># 引入lxml</span></span><br><span class="line">        content_list = []</span><br><span class="line">            <span class="comment">#  lxml解析文章（http请求，把user-Agent浏览器代理写入http头,模拟用户操作防止被检测，</span></span><br><span class="line">            <span class="comment"># decode（）将内容解码)</span></span><br><span class="line">        response = etree.HTML(requests.get(self.url, headers=self.headers).content.decode())</span><br><span class="line">        div_list = response.xpath(<span class="string">'//div[@class="list-style1 row"]/ul/li'</span>)  <span class="comment"># 获取当前页节点列表</span></span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> div_list:  <span class="comment"># 循环节点，分别在每个节点里面取内容</span></span><br><span class="line">            item = dict()</span><br><span class="line">            item[<span class="string">'title'</span>] = div.xpath(<span class="string">'./a/text()'</span>)[<span class="number">0</span>]  <span class="comment"># 提取题目</span></span><br><span class="line">            <span class="keyword">if</span> div.xpath(<span class="string">'./div/span[1]/text()'</span>) :</span><br><span class="line">                item[<span class="string">'author'</span>] = div.xpath(<span class="string">'./div/span[1]/text()'</span>)[<span class="number">0</span>]  <span class="comment"># 作者</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                item[<span class="string">'author'</span>]=<span class="string">'匿名'</span></span><br><span class="line">            item[<span class="string">'from'</span>] = div.xpath(<span class="string">'./div/span[2]/text()'</span>)[<span class="number">0</span>].lstrip(<span class="string">'来源-'</span>)  <span class="comment"># 来源</span></span><br><span class="line">            item[<span class="string">'date'</span>] = div.xpath(<span class="string">'./div/span[3]/text()'</span>)[<span class="number">0</span>]  <span class="comment"># 日期</span></span><br><span class="line">            content_list.append(item)</span><br><span class="line">        print(content_list)</span><br><span class="line">        <span class="keyword">return</span> content_list</span><br><span class="line">    <span class="comment"># 写入文件夹，缩进2空格</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jsonToTxt</span><span class="params">(self)</span>:</span></span><br><span class="line">        jsonNet = self.run()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"truethNet.json"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:  <span class="comment"># 也可以改成.txt文件</span></span><br><span class="line">            f.write(json.dumps(jsonNet, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">truethSpider().jsonToTxt()</span><br></pre></td></tr></table></figure><p><strong>3.金程考研</strong><br>url：<a href="http://www.51dx.org/review/index.shtml" target="_blank" rel="noopener">http://www.51dx.org/review/index.shtml</a><br>爬取标题，文本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, json, xlwt, re, time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">kaoyanSpider</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url_temp = <span class="string">"http://www.51dx.org/review/index&#123;&#125;&#123;&#125;.shtml"</span></span><br><span class="line">        self.headers = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span></span><br><span class="line"><span class="string">         AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取数据返回json</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        etree = html.etree  <span class="comment"># 引入lxml</span></span><br><span class="line">        url_list = []</span><br><span class="line">        content_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">199</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">1</span>:</span><br><span class="line">                url_list.append(self.url_temp.format(<span class="string">''</span>, <span class="string">''</span>))</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                url_list.append(self.url_temp.format(<span class="string">'_'</span>, i+<span class="number">1</span>))</span><br><span class="line">             <span class="comment">#  lxml解析文章（http请求，把user-Agent浏览器代理写入http头,模拟用户操作防止被检测，</span></span><br><span class="line">            <span class="comment"># decode（）将内容解码)</span></span><br><span class="line">            response = etree.HTML(requests.get(url_list[i], headers=self.headers).content.decode())</span><br><span class="line">            div_list = response.xpath(<span class="string">'//div[@class="listSingle"]/div[@class="text"]'</span>)  <span class="comment"># 获取当前页节点列表</span></span><br><span class="line">            <span class="keyword">for</span> div <span class="keyword">in</span> div_list:  <span class="comment"># 循环节点，分别在每个节点里面取内容</span></span><br><span class="line">                item = dict()</span><br><span class="line">                item[<span class="string">'title'</span>] = div.xpath(<span class="string">'./div/a/@title'</span>)[<span class="number">0</span>] <span class="comment"># 提取题目</span></span><br><span class="line">                <span class="keyword">if</span> div.xpath(<span class="string">'./h3/text()'</span>):</span><br><span class="line">                    item[<span class="string">'intro'</span>] = div.xpath(<span class="string">'./h3/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    item[<span class="string">'intro'</span>] = <span class="string">' '</span></span><br><span class="line">                content_list.append(item)</span><br><span class="line">            print(<span class="string">"已爬取&#123;&#125;页"</span>.format(i+<span class="number">1</span>))</span><br><span class="line">            <span class="comment">#time.sleep(1)</span></span><br><span class="line">        <span class="comment">#print(content_list)</span></span><br><span class="line">        <span class="keyword">return</span> content_list</span><br><span class="line">    <span class="comment"># 写入文件夹，缩进2空格</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jsonToTxt</span><span class="params">(self)</span>:</span></span><br><span class="line">        jsonNet = self.run()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"kaoyan.json"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:  <span class="comment"># 也可以改成.txt文件</span></span><br><span class="line">            f.write(json.dumps(jsonNet, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kaoyanSpider().jsonToTxt()</span><br><span class="line"><span class="comment">#kaoyanSpider().run()</span></span><br></pre></td></tr></table></figure><p><strong>4.携程酒店</strong><br>url：<a href="https://hotels.ctrip.com/hotel/changde201#ctm_ref=hod_hp_sb_lst" target="_blank" rel="noopener">https://hotels.ctrip.com/hotel/changde201#ctm_ref=hod_hp_sb_lst</a><br>爬取常德酒店名，地址，评分</p><ul><li>携程最开始用<strong>Selenium</strong>库但是爬到第二页，内容获取报错，很奇怪。有时候下一页按钮也获取不到，这个库没学什么，试了多次所以放弃了，用回了requests</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">import</span> time, re,requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">temp_url=(<span class="string">'https://hotels.ctrip.com/hotel/changde201/p&#123;&#125;'</span>)</span><br><span class="line">headers = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span></span><br><span class="line"><span class="string">         AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36"</span>&#125;</span><br><span class="line">stripD = re.compile(<span class="string">'[^\d*]'</span>)</span><br><span class="line">etree = html.etree  <span class="comment"># 引入lxml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">15</span>):</span><br><span class="line">        response = etree.HTML(requests.get(temp_url.format(i+<span class="number">1</span>), headers=headers).content.decode())</span><br><span class="line">        li_list = response.xpath(<span class="string">'//ul[@class="hotel_item"]'</span>)</span><br><span class="line">        content_list = []</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            item = dict()</span><br><span class="line">            <span class="comment"># 使用正则把左边数字去掉，然后join合并成string</span></span><br><span class="line">            item[<span class="string">'hotel_name'</span>] = <span class="string">""</span>.join(stripD.findall(li.xpath(<span class="string">'./li/h2/a/text()'</span>)[<span class="number">0</span>]))</span><br><span class="line">            <span class="comment"># 把左右的垃圾信息去掉</span></span><br><span class="line">            item[<span class="string">'hotel_address'</span>] = <span class="string">""</span>.join(li.xpath(<span class="string">'./li/p[@class="hotel_item_htladdress"]/text()'</span>)).lstrip(<span class="string">"【 】"</span>).rstrip(<span class="string">"。 "</span>)</span><br><span class="line">            <span class="comment"># 判断有无评分</span></span><br><span class="line">            <span class="keyword">if</span> li.xpath(<span class="string">'./li/div[@class="hotelitem_judge_box"]/a/span[@class="hotel_value"]/text()'</span>):</span><br><span class="line">                item[<span class="string">'start'</span>] = li.xpath(<span class="string">'./li/div[@class="hotelitem_judge_box"]/a/span[@class="hotel_value"]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item[<span class="string">'start'</span>]=<span class="string">"暂无评分"</span></span><br><span class="line">            print(item)</span><br><span class="line">            content_list.append(item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'cstrip.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(json.dumps(content_list, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br><span class="line">        print(<span class="string">"爬了&#123;&#125;页"</span>.format(i+<span class="number">1</span>))</span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p><strong>5.斗鱼直播</strong><br>爬取房间信息</p><ul><li>直接找到开发者工具Network里的json文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求json数据的url</span></span><br><span class="line">url_temp = <span class="string">"https://www.douyu.com/gapi/rkc/directory/0_0/&#123;&#125;"</span></span><br><span class="line">header = &#123;</span><br><span class="line">     <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#发送请求获取响应</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        url=url_temp.format(i)</span><br><span class="line">    <span class="comment">#2.遍历，发送请求获取响应</span></span><br><span class="line">        response = requests.get(url, headers=header).content.decode()</span><br><span class="line">        <span class="comment">#3.提取数据</span></span><br><span class="line">        dict = json.loads(response)</span><br><span class="line">        <span class="comment"># 取到data的值</span></span><br><span class="line">        data = dict[<span class="string">'data'</span>]</span><br><span class="line">        <span class="comment"># 取到rl的值(注意，rl的值是一个列表，里面有120个字典元素，每个字典表示一个房间信息)</span></span><br><span class="line">        rl = data[<span class="string">'rl'</span>]</span><br><span class="line">        content_list = []</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> rl:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            <span class="comment"># 房间</span></span><br><span class="line">            item[<span class="string">'room_name'</span>] = li[<span class="string">'rn'</span>]</span><br><span class="line">            item[<span class="string">'author_name'</span>] = li[<span class="string">'nn'</span>]</span><br><span class="line">            item[<span class="string">'room_cate'</span>] = li[<span class="string">'c2name'</span>]</span><br><span class="line">            print(item)</span><br><span class="line">            content_list.append(item)</span><br><span class="line">        <span class="comment">#4.保存</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'douyu.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> content <span class="keyword">in</span> content_list:</span><br><span class="line">                f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br><span class="line">run()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>写给学弟学妹的学习小程序经验总结</title>
    <url>/2019/06/18/%E5%86%99%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="写给学弟学妹的学习小程序经验总结"><a href="#写给学弟学妹的学习小程序经验总结" class="headerlink" title="写给学弟学妹的学习小程序经验总结"></a>写给学弟学妹的学习小程序经验总结</h1><blockquote><p>此篇文章面向前端入门以及小程序新手，入门爬坑可以观看</p></blockquote><p>我个人跟着教程写过一个电影小程序，然后就直接开始写比赛的小程序了，对小程序有一定认识，但理解还是比较浅的，如有错误欢迎批评指正。</p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="学习小程序的前置知识"><a href="#学习小程序的前置知识" class="headerlink" title="学习小程序的前置知识"></a>学习小程序的前置知识</h3><ul><li><p>前端使用的是微信自定义的一套规范<code>wxml</code>+<code>wxss</code>+<code>json</code>+<code>js</code>,其本质还是<code>html</code>+<code>css</code>+<code>javascript</code>.打好基础才能快速学好框架。</p></li><li><p>编译器推荐：VS Code,有非常多的插件，代码补全，格式修正，颜色高亮，版本控制</p></li><li><p>推荐网站：<a href="https://developer.mozilla.org/" target="_blank" rel="noopener">MDN</a>有标准语法文档方法函数忘记了可以去这个网站查，<a href="https://www.freecodecamp.cn/" target="_blank" rel="noopener">freecodecamp</a>编程闯关、完成挑战</p></li><li><p>第一阶段：html，css，推荐书籍：<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25752357%2F&query=html&cat_id=1001&type=search&pos=0" target="_blank" rel="noopener">Head First HTML与CSS（第2版）</a><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25786074%2F&query=html&cat_id=1001&type=search&pos=6" target="_blank" rel="noopener">HTML5权威指南 </a><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26745943%2F&query=css&cat_id=1001&type=search&pos=4" target="_blank" rel="noopener">CSS揭秘 </a><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27615777%2F&query=css&cat_id=1001&type=search&pos=19" target="_blank" rel="noopener">CSS世界</a>可以边看书或者视频边写代码。快速熟悉网页框架结构。</p></li><li><p>第二阶段：JavaScript,http这一阶段基础一定要打牢，前端的绝大部分都是以javascript为基本的。推荐书籍：<a href="http://book.douban.com/subject/6038371/" target="_blank" rel="noopener">JavaScript DOM编程艺术 （第2版）</a><a href="http://book.douban.com/subject/10546125/" target="_blank" rel="noopener">JavaScript高级程序设计（第3版）</a><a href="http://book.douban.com/subject/3590768/" target="_blank" rel="noopener">JavaScript语言精粹</a><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27127030%2F&query=es6&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">ES6标准入门（第3版）</a><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27072230%2F&query=es6&cat_id=1001&type=search&pos=0" target="_blank" rel="noopener">深入理解ES6</a>如果觉得难可以先看视频，再看书，中间跟着写一些小demo，学完后做一个完整的网页（学习所有知识都可以按照此路径，视频：快速了解 &gt; 书籍：深入探究 &gt; 实践：理解巩固）。</p></li><li><p>扩展知识：学一点点linux和git对合作开发有更高的效率。</p></li><li><p>先学会了一些框架（vue，react）可以更快地上手小程序。</p></li></ul><h3 id="小程序的学习"><a href="#小程序的学习" class="headerlink" title="小程序的学习"></a>小程序的学习</h3><ul><li><p>官方学习视频<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+2018032801X+2018_T1/about" target="_blank" rel="noopener">《学做小程序》</a></p></li><li><p>官方学习文档<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/" target="_blank" rel="noopener">《小程序微信官方文档》</a></p></li><li><p>通过看文档和教学视频学习小程序</p><hr></li></ul><h3 id="入门指导"><a href="#入门指导" class="headerlink" title="入门指导"></a>入门指导</h3><h4 id="1-申请账号"><a href="#1-申请账号" class="headerlink" title="1.申请账号"></a>1.申请账号</h4><p>进入<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">小程序注册页</a><br>可以在小程序后台，依次点击「<strong>设置</strong>」-&gt;「<strong>开发设置</strong>」获取到这个「<strong>AppID</strong>」自己保存：AppID相当于小程序平台的身份证</p><h4 id="2-安装开发工具"><a href="#2-安装开发工具" class="headerlink" title="2.安装开发工具"></a>2.安装开发工具</h4><p>前往 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">开发者工具下载页面</a></p><p>稳定版 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="noopener">Stable Build</a> (1.02.1904090)</p><p><a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=x64&from=mpwiki&download_version=1021904090&version_type=1" target="_blank" rel="noopener">Windows 64</a> 、 <a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=ia32&from=mpwiki&download_version=1021904090&version_type=1" target="_blank" rel="noopener">Windows 32</a> 、 <a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=darwin&from=mpwiki&download_version=1021904090&version_type=1" target="_blank" rel="noopener">macOS</a></p><p>根据不同操作系统下载相应版本</p><h4 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3.创建项目"></a>3.创建项目</h4><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/MSleep1.png" alt="1560426511329"></p><h4 id="4-在VS-Code中编写代码，在小程序开发者工具里调试"><a href="#4-在VS-Code中编写代码，在小程序开发者工具里调试" class="headerlink" title="4.在VS Code中编写代码，在小程序开发者工具里调试"></a>4.在VS Code中编写代码，在小程序开发者工具里调试</h4><p>VS Code官网下载：<a href="https://link.juejin.im/?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" rel="noopener">code.visualstudio.com/</a></p><p>点击「<strong>扩展</strong>」，安装小程序插件推荐「<strong>minapp</strong>」「<strong>wxml</strong>」「<strong>wechat-snippet</strong>」,其他插件自行选择</p><p><img src="/images/loading.png" data-original="https://github.com/2249038142/picture/raw/master/MSleep1.png" alt="1560427053684"></p><hr><h4 id="文件构成"><a href="#文件构成" class="headerlink" title="文件构成"></a>文件构成</h4><p>小程序一般由下面四类文件组成：</p><ul><li><p><strong>json</strong>：<strong>配置文件</strong></p><p><strong>小程序全局配置</strong>：「<code>app.json</code>」</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//配置页面路径</span></span><br><span class="line">"pages": [</span><br><span class="line">​    "pages/index/index",</span><br><span class="line">​    "pages/logs/logs"</span><br><span class="line">  ],</span><br><span class="line"><span class="comment">//配置窗体样式</span></span><br><span class="line">  "window": &#123;</span><br><span class="line">​    "backgroundTextStyle": "light",</span><br><span class="line">      <span class="comment">//顶部导航样式</span></span><br><span class="line">​    "navigationBarBackgroundColor": "#fff",</span><br><span class="line">​    "navigationBarTitleText": "WeChat",</span><br><span class="line">​    "navigationBarTextStyle": "black"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>开发工具配置</strong>：「<code>project.config.json</code>」</p><p>开发者工具的统一配置，界面设置以及云函数相关</p><p><strong>单页面配置</strong>：「<code>page.json</code>」</p><p>对本页面的窗口表现进行配置，会覆盖app.json的window中相同的配置项</p></li></ul><ul><li><p><strong>wxml</strong>：<strong>模板文件</strong>，AS:HTML</p><p>1.跟html很像，类比<code>&lt;div&gt;</code>=<code>&lt;view&gt;</code>,<code>&lt;p&gt;</code>=<code>&lt;text&gt;</code>,<code>&lt;a&gt;</code>=<code>&lt;navigator&gt;</code>等</p><p>2.与html不同的是，可以在标签中加判断或循环语句<code>wx:if、else/wx:for</code>还可以使用三元运算符等</p><p>3.在标签里使用<code></code>可以读取当前页面JS文件<code>data:{motto:&#39;hello World&#39;}</code>data对象中的数据</p><p>4.在标签中通过<code>bindtap/catch=&quot;functionName&quot;</code>冒泡/捕获绑定事件</p></li><li><p><strong>wxss</strong>：<strong>样式文件</strong>，AS:CSS</p><p>1.<code>2rpx</code>=<code>1px</code>小程序根据不同屏幕大小，底层来换算像素单位</p><p>2.flex布局：推荐阮一峰老师的博客<a href="https://www.baidu.com/link?url=4VrMDpw1nzyqCaGnK_mukwLBT83ykwtFxsLpZbW761lChQO8RPPf7KI4YedgAhLe09m00mpVsJI4d2TrUyyZ2DxMSTwvMEbW1vLjItopifq&wd=&eqid=84902dac000fec12000000025d024590" target="_blank" rel="noopener"><em>Flex</em> 布局教程:语法篇 </a><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实战篇</a></p></li><li><p><strong>js</strong>：<strong>脚本逻辑文件</strong></p><p><strong>1.页面生命周期**</strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/life.js 页面初始化时，小程序自动给我们创立了生命周期函数</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据,可以使用this.setData(&#123; msg: "Hello World" &#125;)传入data对象wxml可以从中获取数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onReady: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onHide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onUnload: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onPullDownRefresh: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onReachBottom: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户点击右上角分享</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onShareAppMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很多人说<code>this.setData（）</code>传不进数据，有人回答在函数里先申明个<code>var that=this</code>,这种回答很敷衍，提问人还是不会懂，治标不治本。推荐不懂的同学去了解一下this指向原理：<strong>this 永远指向最后调用它的那个对象</strong>，多看几篇技术文章<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener"><em>this</em>、apply、call、bind</a>、<a href="https://juejin.im/entry/584939baac502e006c59448e" target="_blank" rel="noopener">Javascript 深入浅出 <em>this</em></a></p><p><strong>2.发起http请求</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅为示例</span></span><br><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">'http://test.php'</span>, </span><br><span class="line">  data: &#123;</span><br><span class="line">    x: <span class="string">''</span>,</span><br><span class="line">    y: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">     method:<span class="string">'GET'</span>\<span class="string">'POST'</span>,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过请求后台接口，发送获取数据</p><p><strong>3.用户登陆</strong></p><p>基本每个小程序都少不了登陆流程</p><p><a href="https://juejin.im/post/5bda7bfb6fb9a02228233f45" target="_blank" rel="noopener">彻底搞懂小程序登陆流程</a></p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/11/1/166cd7445ba24957?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><hr><h3 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h3><p>之前喜欢计算机，但是摸不到门路，大约一年前加入工作室，因为比较喜欢写完代码就看到界面交互的效果，确立了学习方向：前端。上学期入门了html,CSS ,JavaScript期间写了几个网页，巩固了一下基础.这学期写完工作室官网，刚学完ES6就开始小程序大赛了。</p><p>我们工作室是独立非学校、非盈利的计算机学习组织主要学习互联网开发，前端后端，设计，三个方向，每周30小时学习打卡，一次学习经验分享会，让我们互相学习监督，共同成长。感谢前辈创业，学长引路，让我从单喜欢计算机到有了专业方向。</p><p>前辈传给我们，我们再教学弟学妹，这种传承的精神源自于我们有共同理想，共同爱好，并为之付出努力。我记得王小波在维也纳看三个青年在街头演奏的一席话：<strong>青年的动人之处，就在于勇气，和他们的远大前程。</strong></p><p>希望能给学弟学妹们，前端刚入门者一些指导。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>面向新手</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>python 课程设计 Day1</title>
    <url>/2019/06/17/python%20%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20Day1/</url>
    <content><![CDATA[<h1 id="python-课程设计-Day1"><a href="#python-课程设计-Day1" class="headerlink" title="python 课程设计 Day1"></a>python 课程设计 Day1</h1><blockquote><p>大一的时候自学过Python，在慕课上看过两个课程，跟着课程写过个豆瓣爬虫，到现在都忘得差不多了，正好课程设计复习一下，还可以了解一下Django后台框架👍</p></blockquote><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>求s=a+aa+aaa+aaaa+aa…a的值求s=a+aa+aaa+aaaa+aa…a的值</strong></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = int(input(<span class="string">'请输入a（1-9）:'</span>))</span><br><span class="line">n = int(input(<span class="string">'请输入要加几次:'</span>))</span><br><span class="line">sum=<span class="number">0</span></span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment">#通过for循环</span></span><br><span class="line">    s += a * (<span class="number">10</span>**i) <span class="comment">#从个位加到最高位得出最后一个a</span></span><br><span class="line">    sum +=s <span class="comment">#每次得到的结果累加</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="C:%5CUsers%5C%E5%90%B4%E4%BD%B3%E5%AE%B8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1560772284334.png" alt="1560772284334"></p><p>计算器验证得：</p><p><img src="/images/loading.png" data-original="C:%5CUsers%5C%E5%90%B4%E4%BD%B3%E5%AE%B8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1560772352981.png" alt="1560772352981"></p><h3 id="课堂习题（笔记）"><a href="#课堂习题（笔记）" class="headerlink" title="课堂习题（笔记）"></a>课堂习题（笔记）</h3><ol><li><p><strong>青蛙爬井的问题</strong></p><p>思路：当白天爬的高度大于深度之后就跳出循环</p></li></ol><figure class="highlight plain"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line">h = int(input(&apos;请输入深度&apos;))</span><br><span class="line">m = int(input(&apos;请输入爬多少米&apos;))</span><br><span class="line">n = int(input(&apos;请输入掉多少米&apos;))</span><br><span class="line">day = 1</span><br><span class="line">deep = 0</span><br><span class="line">while deep &lt; h:</span><br><span class="line">    deep += m</span><br><span class="line">    if deep &gt;= h:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        deep -= n</span><br><span class="line">        day += 1</span><br><span class="line">print(&quot;爬了&#123;0&#125;天&quot;.format(day))</span><br></pre></td></tr></table></figure><p>2.<strong>打印100以内的所有质数</strong></p><p>​ 思路：立flag除与等于零，说明能被某数整除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">        <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>3.<strong>打印100~999之间的水仙花数</strong></p><p>水仙花数：水仙花数是指一个3 位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>​ 思路：通过除整除余取数每个十百位</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">999</span>:</span><br><span class="line">    hundred = n // <span class="number">100</span></span><br><span class="line">    ten = n // <span class="number">10</span> % <span class="number">10</span></span><br><span class="line">    unit = n % <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> hundred ** <span class="number">3</span> + ten ** <span class="number">3</span> + unit ** <span class="number">3</span> == n:</span><br><span class="line">        print(n)</span><br><span class="line">    n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>4.<strong>闰年的判断</strong></p><p>普通闰年:能被4整除但不能被100整除的年份为普通闰年。（如2004年就是闰年，1900年不是闰年）</p><p>世纪闰年:能被400整除的为世纪闰年。（如2000年是世纪闰年，1900年不是世纪闰年）</p><p>​ 思路：根据题意做几个条件判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">year = int(input(&quot;please enter year: &quot;))</span><br><span class="line">if (year % 400) == 0:</span><br><span class="line">    print(&quot;世纪闰年&quot;)</span><br><span class="line">elif (year % 4) == 0 and (year % 100) != 0:</span><br><span class="line">    print(&quot;是普通闰年&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不是闰年&quot;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序 &#39;冥想歇息&#39; 介绍文档</title>
    <url>/2019/06/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%20&#39;%E5%86%A5%E6%83%B3%E6%AD%87%E6%81%AF&#39;%20%E4%BB%8B%E7%BB%8D%E6%96%87%E6%A1%A3%20/</url>
    <content><![CDATA[<h1 id="小程序-‘冥想歇息’-介绍文档"><a href="#小程序-‘冥想歇息’-介绍文档" class="headerlink" title="小程序 ‘冥想歇息’ 介绍文档"></a>小程序 ‘冥想歇息’ 介绍文档</h1><p>—宸薇敏团队</p><p>简介：本程序想推广，用短暂休息和冥想来补充精神和提升学习工作效率。</p><h3 id="1-产品定位"><a href="#1-产品定位" class="headerlink" title="1.产品定位"></a>1.产品定位</h3><p>​ <strong>（1）需求分析</strong></p><a id="more"></a><!-- build time:Mon Dec 23 2019 10:16:02 GMT+0800 (GMT+08:00) --><p>​ 人们在工作学习过程中，往往忽视了休息，大部分人只关注当时的任务。长时间的工作后会感到疲惫，如果闷头继续，往往会使效率下降，产生厌倦感。</p><p>​ 通过网络调查问卷调查发现，有工作和学习任务的人中80%的没有有意识地休息。心理学研究人们无法集中精力太长时间，平均全神关注一个事物15分钟，普通工作两小时，效率就会直线下降。</p><p>​ 所以，我们想设计一个小程序，来改善工作学习效率，提高生活质量。当工作累了，打开小程序，完成短暂休息，继续工作，事半功倍。</p><p>​ <strong>（2）产品方案</strong></p><p>​ 有了目标我们就要努力，但是那些好胜心强的人看起来似乎一点也不快乐。如果用一个小时或一个半小时的时间来专注做一件事，然后用15分钟左右来放松，恢复，可以是冥想也可以听音乐，健身。将时间分割成小块，我们也更容易获得成就感。维持生活的灵活性。聚焦工作，聚焦修整。</p><p>哈弗幸福公开课中，TalBen Shahar说到了保持高效工作与幸福生活最好地方法，其中注意到两点：</p><p>​ 1.冥想</p><p>​ 冥想跟自控力有着千丝万缕的联系。通过冥想提升自控力，也可以通过平时对自控力的训练提升冥想的效率。冥想是管理我们思维的一种方法，当我们在做冥想练习时，看似什么也没做，其实我们大脑的某些构造已经因为冥想而产生了变化，我们思维模式，觉知及感受也相应的产生了变化。</p><p>​ 冥想在美国已经被广泛运用到心理治疗中，特别是针对由创伤所引发的心理健康疾病，其中包括最为大家所熟悉的创伤后应激障碍（PTSD)。同时，冥想在治疗焦虑，抑郁，成瘾，强迫及冲动控制领域也有显著疗效。美国老兵协会近年来开始在老兵创伤治疗中加入冥想练习，多项研究结果显示冥想起到了大大减少创伤后应激障的多项相关病征。美国一些大型的创伤治疗研究中心也开始为心理治疗师开设针对创伤的冥想培训项目，以便为患者带来更多选择 (Steinberg &amp; Eisner, 2015）</p><p>​ Bruce Perry指出对这部分的神经系统提供重复性和有节奏的活动，都可以治疗和加强其功能。一些重复的，有节奏的体感活动包或舞蹈，呼吸，冥想，瑜伽等。这些活动可以大大减少焦虑，冲动，和其他由创伤带来的症状(Waechter, &amp; Wekerle 2014)。</p><p>​ 此外，有研究证明，连续8周练习冥想的正常人，其杏仁核的脑细胞体积明显变小，从而恐惧，压力，焦虑等也大大减缓；其海马体皮层厚度会增加，从而学习能力，记忆，创造力也相应增加 (Holzel, Carmody, Vangel, Congleton, Yerramsetti, Gard,&amp; Lazar,2011)</p><p>​ 2.短暂睡眠</p><p>​ 休息可以分很多形式，其中睡眠是最重要的投资。人们对于尚未处理完的事情，比已处理完的事情印象更加深刻。而睡眠是一个固化记忆的过程，往往思路不清的问题，大脑会在睡眠中处理。</p><p>​ 既然冥想和短时睡眠好处这么多，我们决定通过计时，记录来做这主要的两个功能。</p><p>​ 1.计时可以让用户感受时间流逝，延长心理时间，让用户专注于休息，而不是靠看碎片化信息，没有休息好，又消耗了时间。</p><p>​ 2.记录可以让用户了解最近休息情况，多次的休息记录让用户产生成就感。</p><p>​ 通过小程序即开即用的形式，当用户感到疲劳，即可使用冥想歇息，专注休息。调查问卷中，72%的用户休息是无意识的而且是玩手机刷抖音，微博。这样子使他们休息是无效的，而且大脑充斥大量无用刺激信息，进而影响接下来的专心工作学习。时间充裕的人往往能获得更多幸福感。请闭起眼睛，可以全神贯注地听喜欢的音乐，可以专注深呼吸。有时候，休息过程中会突现惊人的创造力。化学家门捷列夫试图寻找元素间的规律和统一，苦苦思寻，找不到答案，他在梦中梦见自己还在继续工作，仿佛自己梦见了元素周期表，醒来画下来这张表居然是完美的。</p><p>​ 心理学研究，物理时间是有限的，当专注于感受当下后，心理时间可以无限延长。歇息和冥想是一种很好的感受当下的方式。当代，手机与信息充斥着我们的脑子，很多人没有静下心来感受自己，放松休息了。所以我们仅仅是一个小程序，而是想推广一种健康，效率的生活方式。</p><h3 id="2-交互设计"><a href="#2-交互设计" class="headerlink" title="2.交互设计"></a>2.交互设计</h3><p>我们团队这一次小程序的整体色调选择的是粉色到灰色的渐变。因为我们小程序的主题是关于睡眠与冥想，这种渐变的颜色是让人心情放松，安抚情绪。粉色也是女性最喜欢的颜色。在粉红色的环境中小睡一会儿，能使人感到肌肉软弱 无力 ，而在蓝色中停留几秒钟，即可恢复。有人提出粉红色影响心理和生理的作用机制是：粉红色光刺激通过眼睛—大脑皮层—下丘脑—松果腺和脑垂体—肾上腺，使肾上腺髓质分泌 肾上腺素 减少，使得 心脏 活动舒缩变慢，肌肉放松。</p><p>利用渐变色椭圆层叠，位移制造出层次感，分离上下两块层区域。</p><p><img src="/images/loading.png" data-original="C:%5CUsers%5C%E5%90%B4%E4%BD%B3%E5%AE%B8%5CAppData%5CRoaming%5CTypora%5CdraftsRecover%5CbackTop.png" alt="backTop"></p><p>其图标我裁剪植物类型然后染出渐变主题色，植物也能让人心情舒适平静。图案非常简洁，简单与文艺风格，整体色调是蓝紫渐变色图标与上方背景相呼应。![img](file:///C:\Users\吴佳宸\Documents\Tencent Files\2249038142\Image\Group\Image14\JZHJ943{XGT767_RC~Y6K58.jpg)</p><p>简约风格，音乐背景图片可以左右滑动切换，当睡眠倒数时间开始后，圆周随时间变化蓝色呼吸灯缓慢缩放，使用户跟随呼吸灯的节奏，平静深呼吸。![img](file:///C:\Users\吴佳宸\Documents\Tencent Files\2249038142\Image\Group\Image14\AETBF1]RZX3CSO%{[S}4M`Q.jpg)</p><p>睡眠记录，冥想使用了![Green think](C:\Users\吴佳宸\AppData\Roaming\Typora\draftsRecover\Green think.png)灯泡图标表示思考到了什么，而睡眠部分使用的床左边灰色记录日期，右边黑色大字体记录时间。</p><p><img src="/images/loading.png" data-original="C:%5CUsers%5C%E5%90%B4%E4%BD%B3%E5%AE%B8%5CAppData%5CRoaming%5CTypora%5CdraftsRecover%5C1559064901953.png" alt="1559064901953"></p><h3 id="3-技术方案"><a href="#3-技术方案" class="headerlink" title="3.技术方案"></a>3.技术方案</h3><p>​ <strong>（1）程序框架图</strong></p><p><img src="/images/loading.png" data-original="C:%5CUsers%5C%E5%90%B4%E4%BD%B3%E5%AE%B8%5CAppData%5CRoaming%5CTypora%5CdraftsRecover%5C1559047200524.png" alt="1559047200524"></p><p>说明:总体为两个功能，冥想和睡眠 。其中的主要组件，计时组件。</p><p>​ <strong>（2）前端技术方案</strong></p><ul><li><p>技术选型：采用原生WXML,WXSS，JavaScript。</p></li><li><p>开发环境：使用微信原生框架，微信开发者工具，VS Code编辑器。</p></li><li><p>开发重难点：</p><p><strong><code>计时器组件</code></strong>：</p><ol><li><p>当时才学完es6还不了解设计模式，从小程序中了解到MVVM的一些思想，其核心是一个响应的数据绑定系统。整个系统分为两块：视图层(View) 和 逻辑层(App Service)。<br>这种模式可以让数据与视图保持同步非常简单。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。当睡眠时采用正计时，冥想时使用倒计时，两个页面复用一个组件。需要通过数据绑定的方式，页面传入逻辑层实现正倒计时。睡眠计时器从首页直接传入四个不同的时间。后台统计算的时间，也实时传入视图层。我们设了4个不同的睡眠时间，首页点击直接开始，减少用户操作步骤，操作的简单性，使用户快速进入休息状态，即开即用。</p></li><li><p>环形进度框，计时组件睡眠，团队讨论其时间大于一分钟时把秒数隐去，这样使用户专心于睡眠而不是看时间，为此我们加入了环形进度条来查看睡眠进度。</p><p>而普通的CSS没有圆形进度条，最后我想出一个解决办法，设俩个半圆，另一半遮住，这样当JS控制其旋转时，多余部分旋转隐藏，当总设定小于一半时间时，左边角度设为135度全部遮住，右边部分开始旋转。</p></li><li><p>滑动时会有不同的背景和音乐，调用滑动函数，音乐的url地址变换从而切换背景音乐，当时理所当然用了wx.BackgroundAudioManager()接口，而他的属性<strong>tring src</strong>：默认为空字符串，<strong>当设置了新的 src 时，会自动开始播放</strong>。当时为了解决自动播放的问题，让他获取到url后立即暂停pause()方法，可这个方法在滑动swiper时pause()方法不奏效，冥思苦想后，再看官方文档 wx.createInnerAudioContext()接口完美地解决了这个问题。</p></li><li><p>在睡眠倒计时中，如果用户没睡到设定的时间，会有一个确认弹窗，如果点返回会继续睡眠，自动调用开始函数。可这个函数的数据还是初始数据，这时候需要把数据重新覆盖，覆盖之后出现了问题，时间与圆形倒进度开始紊乱，逐一排查发现进度条是按重新覆盖的数据来减的，我们设减的刻度是360/总的时间，导入函数的总时间被覆盖，所以我在pageLifetimes: show函数中，赋一个变量把初始时间存放其中，这样原始数据不会被新数据干扰。</p><p><strong>（3）后端技术方案</strong></p><p>本次我们小组开发的是一个小歇息的小程序，因为主要以控制时间、良好睡眠为主。这次小程序的后台开发环境用的是PHP，用的是thinkphp框架设计的api，搭配的是MySQL数据库，为了保证良好的性能，服务器选择的是Nginx。</p><p>本次技术设计的首页设置了定位获取用户的天气预报。获取了百度天气的api接口，由经历前台传输用户的经纬度信息，传递给服务器端，获取用户的当地天气的信息，在传递给客户端，使客户端完成对前端首页的渲染。</p><p>其中对用户的一些基本信息也存储在数据库中，用户的信息主要用过调用微信的接口，通过微信为个人用户设计的code码，让小程序端传递code码来获取用户独有的openid。在后台为了保证用户的个人信息安全和用户体验，后台对用户的openid进行了加密和封装，使用户生成了一个唯一对应的token令牌，并把token令牌存储在数据库中，而不存储openid，保证了用户信息的安全。同时为了用户的加载体验，后台把用户的token和一些不涉及用户安全的信息存储在缓存中，以此来加快用户的二次访问速度。</p><p>小程序的首页的四个一键小睡和冥想，是由用户点击使用之后，由客户端实现对用户冥想和睡眠记录的收集，当用户结束冥想和结束小睡的时候，客户端会收集到用户冥想和小睡的时间。当获取到用户的小睡和冥想的时间后，客户端通过POST请求把用户的冥想和歇息的时间发给服务端，服务器再把用户的时间存储在服务器的MySQL中，完成对用户冥想和小睡时间的收集。同时在用户的信息页中，有冥想日志和睡眠日志，在冥想日志和睡眠日志中，小程序端通过用户的缓存来的token，通过POST请求来请求服务端，服务端获取用户在体验过小程序过后存储在数据库的冥想和小睡的数据，再反馈给小程序端，小程序端再完成对冥想日志和小睡日志的渲染。</p></li></ol></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>产品介绍</tag>
        <tag>小程序大赛</tag>
        <tag>精华</tag>
      </tags>
  </entry>
</search>
