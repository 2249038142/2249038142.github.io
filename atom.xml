<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  <subtitle>佳宸学习和分享笔记的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-07T00:57:17.910Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴佳宸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-2021 对自己的多一点期许</title>
    <link href="http://yoursite.com/2021/01/03/2020-2021%20%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%9A%E4%B8%80%E7%82%B9%E6%9C%9F%E8%AE%B8/"/>
    <id>http://yoursite.com/2021/01/03/2020-2021%20%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%9A%E4%B8%80%E7%82%B9%E6%9C%9F%E8%AE%B8/</id>
    <published>2021-01-02T16:00:00.000Z</published>
    <updated>2021-03-07T00:57:17.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-2021-对自己的多一点期许"><a href="#2020-2021-对自己的多一点期许" class="headerlink" title="2020-2021 对自己的多一点期许"></a>2020-2021 对自己的多一点期许</h1><blockquote><p>2020 年对很多人来说，都很难。</p><p>我也一样。</p><p>好消息是，我去年立的小目标基本实现了。</p></blockquote><h2 id="2020上半年"><a href="#2020上半年" class="headerlink" title="2020上半年"></a>2020上半年</h2><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>2020上半年主情绪是紧张焦虑的，包括疫情下的春招，一次次的面试，过与挂都在极度的喜与悲中，每天都像在坐过山车。尤其是第一次面tx的时候，4面到GM，等结果睡不着，结果一周没回复备胎了，又看到同学一个个的拿到各种offer，怀疑人生，官网灰了，心灰意冷。</p><p>好在tx给了我多次机会，刷力扣，整理系统的知识，4月初的时候终于通过了。</p><p>有时候<strong>你觉得这个事一定能成的时候</strong>，梦到能成，潜意识能，<strong>它自然就会成</strong>。不要迟疑，不要犹豫，专心干到 胸有成竹。</p><p>也包括夏天的实习，留用考核。每周的周报，一次次的ppt修改，导师看完，组长看，组长看完总监看，反反复复会让人心烦，但是必须要改的。好不容易争取到的东西真的害怕瞬间一无所有，连周末都慌慌张张。</p><p>关于上半年总结一句话: <strong>做最坏的打算，争取最好的结果</strong>。</p><h2 id="2020下半年"><a href="#2020下半年" class="headerlink" title="2020下半年"></a>2020下半年</h2><p>留用后半年是心态规正，工作不再是全部，开始恢复规律健身，每周末跟朋友出去爬山or在外面逛一逛，感受当下，感受生活的美，心态好很多</p><blockquote><p>其实中间也有心态崩掉的时候，那时候项目快上线了，我们写代码的也在疯狂做模板。我心急没做好，被老板在群里骂了，说你就是个炸队友的地雷等一堆话，我瞬间就哭了，我真的有在努力。哭完了第二天还是好好跟老板说话，老板也有好好教我，他的标准。好好认真做好每件事。</p></blockquote><p>关于下半年，用刚看完的《心灵奇旅》做启发: <strong>我们不是平庸的在活着，我们从出生的那一刻起就有了意义，那个意义就是骑行时看到的天空，是游玩飘落的下花瓣，是专注忘我的时候，用心去感受。珍惜当下的每一刻！</strong></p><h2 id="工作中的一些方法论"><a href="#工作中的一些方法论" class="headerlink" title="工作中的一些方法论"></a>工作中的一些方法论</h2><blockquote><p>佳宸日常工作中总结出来的一些方法论。总结源自带我的导师的日常工作方法，以身作责，衷心感谢。《程序员工作法》这本书也学到了很多关于程序员的软能力。</p></blockquote><h3 id="思考框架"><a href="#思考框架" class="headerlink" title="思考框架"></a>思考框架</h3><p>面对问题时，用思考框架问自己: <strong>问题</strong>的现状、要实现的<strong>目标</strong>、实现<strong>路径</strong>。<br>如果把这个思考框架运用在你的职业发展规划上，你会如何回答这三个问题?</p><ul><li>我现在是个什么水平?</li><li>我想达到一个什么水平?</li><li>我将怎样到达那个目标?</li></ul><p><img src="/images/loading.png" data-original="/Users/jasonjcwu/Documents/markdownImage/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_bb13b3b8-d176-4321-b8f0-52a2bb7cbd85.png" alt="企业微信截图_bb13b3b8-d176-4321-b8f0-52a2bb7cbd85"></p><p>目标相对清晰的同学，才会进入到第三个问题，而茫然的同学，则完全无从下手。<br>如果你对未来没有定位，是茫然的，尽管你也知道要努力，但劲儿该往哪里使呢? <strong>如果使劲的方向不<br>对，那么你越使劲儿，可能会在错误的路上跑得越远。</strong><br>（这点我深有体会，工作中如果需求不明确，你会无从下手，生活也是，目标不明确，就会犹豫，原地转圈）</p><p><img src="/images/loading.png" data-original="/Users/jasonjcwu/Documents/markdownImage/image-20201218185751237.png" alt="image-20201218185751237"></p><h3 id="反推思维"><a href="#反推思维" class="headerlink" title="反推思维"></a>反推思维</h3><blockquote><p>“以终为始”是一种反直觉的思维方式，是大多数人不具备的。所以，日常生活中，我们看到很多有趣的现象。</p></blockquote><p>比如，大学毕业时，有很多人想考研，如果你问他为什么要考研，得到的理由通常是为了找个好工作。但考研真的能帮他找个好工作吗? 不一定，因为找工作和考研根本就不是同一棵技能树。</p><p>如果真的想找一份好工作，那你就应该了解<strong>工作的要求是什么，怎样才能掌握工作要求的技能</strong>。</p><p>从后面这个角度出发，你会发现考研只是通往工作 诸多路径中的一条，其他的路径也是可以到达的。比如，你应该找个实习的地方锻炼一下职业技能。这才是“以终为始”思考问题的方式。</p><h3 id="DoD-完成的定义"><a href="#DoD-完成的定义" class="headerlink" title="DoD(完成的定义)"></a>DoD(完成的定义)</h3><blockquote><p><strong>在做任何事之前，先定义完成的标准。</strong></p></blockquote><p>人与人之间的协作，总会有这样或那样的理解差异，开始协作之前，我们最好先同步一下彼此的理解，确保之后不会因为理解不一致，而让协作方措手不及。</p><p><img src="/images/loading.png" data-original="/Users/jasonjcwu/Documents/markdownImage/image-20201218191007473.png" alt="image-20201218191007473"></p><p>张三会说，我又不是李四肚子里的蛔虫，怎么才能和他达成一致呢? 答案很简单，既然双方的理解有差异，那就把这个差异弥合上，后面的问题便也不是问题了。</p><p>DoD 是一个的思维模式，是一种尽可能消除不确定性，达成共识的方式。</p><h3 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h3><p>只有能把任务拆分得非常小，你才能对自己的执行能力有一个更清楚地认识，真正的高手都是有很强的分解能力。这个差别就相当于，同样观察一个物品，你用的是眼睛，而高手用的是显微镜。</p><h3 id="最小代价"><a href="#最小代价" class="headerlink" title="最小代价"></a>最小代价</h3><p>即便我们不是在做一个新产品，我们依然可以运用这个“最小代价”的理念在日常工作中做事。比如，怎么来衡量产品经理的产品设计是不是好的。我会问，<strong>这个功能不做，用户会怎么样?有没有什么替代方案</strong>等等。以此来帮助产品经理想清楚自己的产品设计是否真的有价值。</p><h3 id="提前暴露问题"><a href="#提前暴露问题" class="headerlink" title="提前暴露问题"></a>提前暴露问题</h3><blockquote><p>事情往前做，有问题尽早暴露</p></blockquote><p>克服心理障碍：在工作中暴露自己的问题，却是很大的挑战，因为这里还面临着一个心理问题:会不会让别人觉得自己不行。自己可能搞不定任务的时候，如果的选择是继续闷头做，而不是把问题暴露出来，寻求帮助，那问题就出在你自身了，别人对你的评价只会更加糟糕。</p><p>遇到问题，最好的解决方案是尽早把问题暴露出来。</p><h2 id="2021的期许"><a href="#2021的期许" class="headerlink" title="2021的期许"></a>2021的期许</h2><p>以下是给自己2021的多一点期许</p><h4 id="反信息流"><a href="#反信息流" class="headerlink" title="反信息流"></a>反信息流</h4><p>顺应人性，博人眼球的短内容在不断挤占我们的自由意识，看着爽，实则无营养无脑子的消遣。希望自己，多做一些反人性的长效收益的事，少刷一点儿信息流。多看长内容，不管是书籍文字还是视频，最好是经典名著。</p><h4 id="佛系运动"><a href="#佛系运动" class="headerlink" title="佛系运动"></a>佛系运动</h4><p>上半年面试，在家又是疫情运动得比较少，9月份自己快到79kg了还没涨肌肉，后面意识到了肉眼可见的脸上肥肉，自己的肚皮😢。人开始清醒了，不能变油腻啊。然后坚持每周2次，减到76-77kg了。<br>未来一年希望自己保持体脂不上升的前提下，增重到80kg。每周两次运动，稍微走出舒适区到2-3次，周三练腿。</p><h4 id="专业学习"><a href="#专业学习" class="headerlink" title="专业学习"></a>专业学习</h4><p>我们不单单只是写写页面的前端，团队有很多方向，每个人都有自己的专长，有后端全栈方向，有AI.机器学习方向，有图文编辑器，视频编辑器、解析方向，有3D可视化方向。这大半年在跟导师基本上走全栈(全干)，广度有了挺多提升，左手curd接口、数据库，右手交互设计、前端界面，前端除了vue也学会了react全家桶，做创意研发也会了很多动画，后端也有了真正的实践，sails框架，mongo数据库，英文文档能力也有所增强，(有些冷门技术国内根本就没文章，不硬看没法写代码🤣）</p><h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><p>想往可视化方向深入。 Webgl，tree.js 3d啥的，因为不管3d模型编辑器还是3d视频渲染，应该是团队也是前端未来技术发展趋势。<strong>努力是为了拥有更多的选择，而选择是为了让自己的努力更有价值！</strong></p><h5 id="2021给自己两个小小的要求："><a href="#2021给自己两个小小的要求：" class="headerlink" title="2021给自己两个小小的要求："></a>2021给自己两个小小的要求：</h5><ol><li>一周一道力扣算法题</li><li>英语一周一篇技术文章or单词</li></ol><p>内容不多也不慢，坚持才是最难的。</p><h4 id="关于理财"><a href="#关于理财" class="headerlink" title="关于理财"></a>关于理财</h4><p>从去年的去深信服实习开始不再要家里的生活费，到如今开始有工资结余了，有了些积蓄，看了一些定投价值投资的书籍，市盈率市净率啥的，当初双学位会计没白学哈哈哈，算是小白入门吧。还好没亏，赚了点奶茶钱，因为开始意识到的时候，牛市已经在横盘了。投资也是件反人性的时候，越是下跌越是机会。比如说2-3月的美股熔断全都恐慌的时候，就是绝佳入场好机会。</p><p>等明年下半年毕业正式工资，余钱更多，就更需要理财知识了，抓紧多看几本大佬的书吧。</p><h4 id="关于感情"><a href="#关于感情" class="headerlink" title="关于感情"></a>关于感情</h4><p>今年算是彻底的单身了，男人要有断臂的决心，孤独是人生的常态，《千与千寻》里有段话是这样说的：“人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完，当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。”</p><p><strong>保持真诚，懂得感恩，珍惜眼前人。</strong></p><h4 id="关于情商"><a href="#关于情商" class="headerlink" title="关于情商"></a>关于情商</h4><p>多跟同事沟通，多换位思考，多夸夸人，水果奶茶什么的不要吝啬，有时候一点小温暖就可以收买人心，有舍才有得。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p><strong>2020年实属不易，2021牛转乾坤，热爱生活，多看书、多思考，向长远看。</strong></p><h5 id="最后许两个愿"><a href="#最后许两个愿" class="headerlink" title="最后许两个愿:"></a>最后许两个愿:</h5><ol><li>心里藏着一个三年目标，希望2023能实现。🙏</li><li>家人身体健康！</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2020-2021-对自己的多一点期许&quot;&gt;&lt;a href=&quot;#2020-2021-对自己的多一点期许&quot; class=&quot;headerlink&quot; title=&quot;2020-2021 对自己的多一点期许&quot;&gt;&lt;/a&gt;2020-2021 对自己的多一点期许&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;2020 年对很多人来说，都很难。&lt;/p&gt;&lt;p&gt;我也一样。&lt;/p&gt;&lt;p&gt;好消息是，我去年立的小目标基本实现了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;2020上半年&quot;&gt;&lt;a href=&quot;#2020上半年&quot; class=&quot;headerlink&quot; title=&quot;2020上半年&quot;&gt;&lt;/a&gt;2020上半年&lt;/h2&gt;
    
    </summary>
    
    
      <category term="年总结" scheme="http://yoursite.com/categories/%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>h5开发经验总结</title>
    <link href="http://yoursite.com/2020/08/03/h5%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/03/h5%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-03T14:49:35.676Z</published>
    <updated>2021-03-07T00:43:06.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="h5开发总结"><a href="#h5开发总结" class="headerlink" title="h5开发总结"></a>h5开发总结</h1><p>做了两个月的创意h5，其中遇到了一些坑与兼容适配方面的问题，做个记录总结，基于vue开发</p><h2 id="1-布局"><a href="#1-布局" class="headerlink" title="1. 布局"></a>1. 布局</h2><h3 id="1-1-元素的长宽"><a href="#1-1-元素的长宽" class="headerlink" title="1.1 元素的长宽"></a>1.1 元素的长宽</h3><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>通常用rem来设置宽高，<code>rem: 相对于根元素html的字体大小的单位</code></p><p>把标准@x2设计稿750宽的根元素的字体大小设为50px,就可以直接按设计稿的长宽/100来直接定义元素的宽高了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="built_in">calc</span>(100vw / 15);&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-底部菜单栏的高度兼容"><a href="#1-2-底部菜单栏的高度兼容" class="headerlink" title="1.2 底部菜单栏的高度兼容"></a>1.2 底部菜单栏的高度兼容</h3><p>这个问题包括了浏览器端底部菜单，还有ios端的微信第一次进入，会有底部状态栏</p><p>qq浏览器把底部菜单栏，当作了body的一部分，相当于是一个固定在底部的菜单栏，但是层级是最高的，所以当使用绝对定位，<code>bottom：0</code>放元素在底部的时候，元素是会被覆盖掉的。或者高度设为100%或者100vh底下的元素也会被覆盖掉</p><h4 id="纠正最大长度"><a href="#纠正最大长度" class="headerlink" title="纠正最大长度"></a>纠正最大长度</h4><p>通过global变量监听获取当前视口的高度<code>window.innerHeight</code>。并随时更新。然后在在CSS中自定义变量<code>--vh</code>。动态改变它的高度，第一次知道<code>setProperty</code> 可以让js设置css的变量，js与css通信</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听它的高度变化，写在项目初始化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">  vh = <span class="built_in">window</span>.innerHeight * <span class="number">0.01</span>;</span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">'--vh'</span>, <span class="string">`<span class="subst">$&#123;vh&#125;</span>px`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// css </span></span><br><span class="line">.topic1 &#123;</span><br><span class="line">  width: <span class="number">100</span>vw;</span><br><span class="line">  height: calc(<span class="keyword">var</span>(--vh, <span class="number">1</span>vh) * <span class="number">100</span>);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://i2.wp.com/css-tricks.com/wp-content/uploads/2018/07/viewport-units-mobile-crop.jpg?ssl=1" alt="img"></p><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/17EZQtKj9Luq8fo.png" alt="jobstopic1.png"></p><h3 id="1-3-需要适配到的宽高比"><a href="#1-3-需要适配到的宽高比" class="headerlink" title="1.3 需要适配到的宽高比"></a>1.3 需要适配到的宽高比</h3><p>短屏适配需要做到9/13的宽高比例才能完全在浏览器有底部栏出现的情况下显示正常，最好要向设计师提前说明不要将元素撑的太满，做一部分的长度适应</p><p>不然设计师以iphonex为设计原型，又不留白，页面实现就会超出可视区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 屏幕宽高比9比13</span><br><span class="line">@<span class="keyword">media</span> (min-aspect-ratio: <span class="number">9</span>/<span class="number">13</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-滚动条问题"><a href="#1-4-滚动条问题" class="headerlink" title="1.4 滚动条问题"></a>1.4 滚动条问题</h3><p>一般设置绝对定位元素会超出屏幕，这时会出现滚动条</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在每个页面夫元素设置可视宽高，然后超出部分隐藏</span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页面只在一屏展示，禁止可上下滑动，页面体验效果更好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手指按住屏幕下拉，屏幕顶部会多出一块白色区域。用了以上的禁止<code>touchmove</code>事件就不会出现下滑效果，体验更像原生程序</p><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/yLrgS9jexU2J4Bd.png" alt="image-20200725151901785.png"></p><h2 id="2-动画"><a href="#2-动画" class="headerlink" title="2. 动画"></a>2. 动画</h2><h3 id="2-1-序列帧动画的实现"><a href="#2-1-序列帧动画的实现" class="headerlink" title="2.1 序列帧动画的实现"></a>2.1 序列帧动画的实现</h3><h4 id="为什么不用GIF图"><a href="#为什么不用GIF图" class="headerlink" title="为什么不用GIF图"></a>为什么不用GIF图</h4><ol><li>gif 支持颜色少(最大256色)、Alpha 透明度支持差，图像锯齿毛边比较严重；</li><li>不能直接控制开始、停止、动画时间，灵活性差；</li><li>gif 会引起页面周期性的<strong>绘画</strong>，性能较差。</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>原理：把雪碧图的第一帧设为初始背景，短边设为显示宽高，通过CSS3 animation动画位移雪碧图的 <code>background-position</code> ，模拟动画效果</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sprite</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">bubbleImg</span><span class="selector-class">.png</span>);</span><br><span class="line">    <span class="selector-tag">animation</span>: <span class="selector-tag">clickBubble</span> 333<span class="selector-tag">ms</span> <span class="selector-tag">steps</span>(7) <span class="selector-tag">both</span> <span class="selector-tag">infinite</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">@<span class="keyword">keyframes</span> clickBubble&#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">20.72rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>animation</code>动画：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener"><code>animation-name</code></a>：动画keyframes 名称，可以用百分比表示时间节点，也可以用from-to,表示0%-100%</p></li><li><p><code>animation-fill-mode: both;</code>应用目标时立即应用第一个关键帧中定义的值,并且保留由执行期间遇到的最后一个<a href="https://developer.mozilla.org/en-US/docs/CSS/@keyframes" target="_blank" rel="noopener">关键帧</a>计算值</p></li><li><p><code>animation-iteration-count</code>动画运行的次数 infinite 无限循环</p></li><li><p><code>animation-timing-function: steps();</code></p><blockquote><p>steps 函数指定了一个阶跃函数，它接受两个参数。</p><p>第一个参数接受一个整数值，表示两个关键帧之间分几步完成。</p><p>第二个参数有两个值&lt; start &gt; or &lt; end &gt;。默认值为&lt; end &gt; 。</p><p>step-start 等同于 step(1, start)。step-end 等同于 step(1, end)。</p></blockquote><p>steps(7)就是关键帧分7步跳跃。把单个png图的宽或高*7设为最终背景移动位置</p></li></ul><h3 id="2-2-解决动画帧抖动问题"><a href="#2-2-解决动画帧抖动问题" class="headerlink" title="2.2 解决动画帧抖动问题"></a>2.2 解决动画帧抖动问题</h3><p>帧动画在部分机型出现了抖动或着位移的问题，发现是rem转为px存在小数点，除不尽误差的问题，误差就会导致有些机型有抖动或者位移现象。</p><p>既然我们通常是根据屏幕的尺寸，计算并设置根元素的font-size，从而影响rem的基准值。那不同的尺寸之间肯定是没有一个公约数的，也就是说我们没办法设定一个基准值来保证不同的屏幕尺寸下，rem值在换算成px值的时候是整数。</p><blockquote><p>当320px的屏幕基准像素为12px时，iphone8（375px）下<code>html</code>的font-size 就是14.0625px，iphone8p下font-size就是15.525px。</p></blockquote><p>浏览器在计算像素精度时，并不是直接全部取整或者取余的，这点其实你稍微想想一下就能得到结论。那我们上文这样在109rem的宽度下取16帧的时候，自然也就会出现多1px或者少1px的误差。这也就导致了我们逐帧动画出现了抖动！</p><p>解决：</p><ol><li>可以使用<code>transform: scale()</code>将其放大，然后rem除余成px的时候误差会减小</li><li>使用svg设置外层尺寸（rem），再使用实际的大小设置内容的尺寸（px），我们保留rem自适应屏幕宽度特性的同时，也确保内部内容的大小计算不会出现精度问题（因为设定的都是整数的px）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0, 0, 536, 652"</span> <span class="attr">class</span>=<span class="string">"tiger-tail"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">foreignObject</span> <span class="attr">class</span>=<span class="string">"inner-html"</span> <span class="attr">width</span>=<span class="string">"536"</span> <span class="attr">height</span>=<span class="string">"652"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rainbow-wave"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreignObject</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 外层svg包rem</span><br><span class="line"><span class="selector-class">.tiger-tail</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5.36rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">6.52rem</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  // 里层用用雪碧图原图加animation</span><br><span class="line">  <span class="selector-class">.inner-html</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">536px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">652px</span>;</span><br><span class="line">    .rainbow-wave &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 26800<span class="selector-tag">px</span>;</span><br><span class="line">      <span class="selector-tag">height</span>: 652<span class="selector-tag">px</span>;</span><br><span class="line">      background-image: url("../img/topic5/sprites.png");</span><br><span class="line">...</span><br><span class="line">      <span class="selector-tag">animation-timing-function</span>: <span class="selector-tag">steps</span>(50);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> keyframes-rainbow-wave &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: -<span class="number">26800px</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h4><ul><li><p>建议不要使用太长或者太宽的雪碧图，使用矩形的雪碧图，cdn存图的时候会把过长的图片给裁剪掉</p><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/huRdbLtsNm2Bxik.png" alt="image-20200719203741766.png"></p></li><li><p>ios下帧率最好不要太高，不然会导致不断刷新的问题，每秒50帧的时候会无限刷新，设置25帧就不会出现这个问题了</p></li><li><p>推荐一个帧动画生成工具<a href="https://gka.js.org/#/" target="_blank" rel="noopener">https://gka.js.org/#/</a></p></li></ul><h3 id="2-3-CSS-星轨运动实现"><a href="#2-3-CSS-星轨运动实现" class="headerlink" title="2.3 CSS 星轨运动实现"></a>2.3 CSS 星轨运动实现</h3><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/S7hdnWMXJ4Eyack.png" alt="image-20200619151431465.png"></p><p>因为星星轨迹是椭圆且有角度的，而且是椭圆轨迹</p><p>之前看到篇文章 <a href="https://tobiasahlin.com/blog/curved-path-animations-in-css/" target="_blank" rel="noopener">分层动画在CSS中沿弯曲路径移动</a>，所以感觉可以通过X轴加上Y轴的分层动画融合，加上速度不同步，实现对角线曲线运动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.dot</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: xAxis <span class="number">2.5s</span> infinite ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dot</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: yAxis <span class="number">2.5s</span> infinite ease-out;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> xAxis &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100px);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> yAxis &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-out;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-100px);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现它的曲率主要靠，速度不同步，比如y轴速度大于x轴，运动曲线就会是一个上拱的抛物线<br>调节特定的曲率 ease-in,out,linear就远远不够了，需要用到<a href="https://cubic-bezier.com/#" target="_blank" rel="noopener">赛贝尔曲线</a>来调节<br><code>animation-timing-function: cubic-bezier(0.3, 0.27, 0.07, 1.64);</code><br>可是即使有可视化的曲线调节，但是结合xy轴相乘就非常难控制了，与线条轨迹不能重合。所以只能另谋出路了</p><h5 id="正圆的旋转实现"><a href="#正圆的旋转实现" class="headerlink" title="正圆的旋转实现"></a>正圆的旋转实现</h5><p>使用传统的圆周转，实现绕圈旋转的<code>animation</code>，一个周期旋转一周。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> spin &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn); <span class="comment">/* 旋转一周 */</span>&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear; </span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">150px</span>; <span class="comment">/* 150px = 旋转半径 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是物体在绕圆形路径旋转时，发现自身也颠倒了</p><p><img src="/images/loading.png" data-original="https://www.w3cplus.com/sites/default/files/blogs/2015/1507/css-secrets-8-35.png" alt="css-secrets-8-35"></p><p>解决方法：时利用两个元素在向不同方向旋转时旋转角度互相抵消的原理，实现图像沿环形路径旋转同时保持自身角度的不变。外层旋转 ，里面物体反旋转抵消被旋转效果，就是有环形轨迹运动物体不颠倒的效果了，然而这样子就需要一个相反的动画，使用<code>animation-direction: reverse;</code>可以得到一个反向原动画，不需要创建第二个动画</p><p>再优化：每个<code>transform-origin</code>可以模拟两次<code>translate()</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以200px,300px 为圆心旋转30度</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(30<span class="selector-tag">deg</span>); </span><br><span class="line"><span class="selector-tag">transform-origin</span>: 200<span class="selector-tag">px</span> 300<span class="selector-tag">px</span>;</span><br><span class="line">// 通过顺序位移达到同样的效果</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(200<span class="selector-tag">px</span>, 300<span class="selector-tag">px</span>)</span><br><span class="line"><span class="selector-tag">rotate</span>(30<span class="selector-tag">deg</span>) </span><br><span class="line"><span class="selector-tag">translate</span>(<span class="selector-tag">-200px</span>, <span class="selector-tag">-300px</span>);</span><br></pre></td></tr></table></figure><p>通过translate的抵消，出来了一串简介的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> spin&#123;</span><br><span class="line">  <span class="selector-tag">from</span>&#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0turn) <span class="built_in">translateY</span>(-150px) <span class="built_in">translateY</span>(50%) <span class="built_in">rotate</span>(1turn); &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(1turn) <span class="built_in">translateY</span>(-150px) <span class="built_in">translateY</span>(50%) <span class="built_in">rotate</span>(0turn); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.avatar</span> &#123; <span class="attribute">animation</span>: spin <span class="number">3s</span> infinite linear; &#125;</span><br></pre></td></tr></table></figure><p>学习的文章：<a href="https://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html</a></p><p>正圆实现了，如何实现椭圆呢，之前找的分层动画也没有白费，在元素里加一个y轴的上下移动，融合入正圆，就可以画出椭圆效果来</p><p>再在大div里加入一个角度，在animation里再旋转棱形块，旋转了运动轨迹，行星又是水平的效果，达到设计图的要求</p><h3 id="2-4-如何实现3d开门效果"><a href="#2-4-如何实现3d开门效果" class="headerlink" title="2.4 如何实现3d开门效果"></a>2.4 如何实现3d开门效果</h3><p>实现方法：两个div叠加，外层div进行旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> flip-to-left &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(0); &#125;    </span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-180deg); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.paper</span><span class="selector-attr">[data-right]</span> &#123;    </span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;    </span><br><span class="line">  <span class="attribute">animation</span>: flip-to-left <span class="number">2s</span> ease-in-out; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样只是一个平面的效果，只能看到一个窄的和宽的矩形，看不到立体的效果。然后找到一个属性添加景深<code>transform-perspective:1000px</code>，有了立体的感觉</p><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/3AkyLdwVn6PD1zM.png" alt="image-20200617200128728.png"></p><p>又发现一个问题：虽然有深度，当还是平视效果，与设计图不符合</p><p>需要有一个摄像机视角在这个门的上方，从上往下看的视角，打开的门类似于平行四边形才能与设计意图相符合</p><p><img src="/images/loading.png" data-original="https://i.loli.net/2020/07/31/I9iDpadBTonLKQY.png" alt="image-20200619160759187.png"></p><p>找到一个冷门属性，<code>transform-style: preserve-3d</code>元素的子元素们是放置在 3D 空间中</p><p><code>transform: rotateX(15deg)</code>就有了俯视的视角 ,还可以实现这种立体的效果</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/3/25/169b4788857d320e?imageslim" alt="雨伞"></p><h2 id="3-业务通用组件"><a href="#3-业务通用组件" class="headerlink" title="3. 业务通用组件"></a>3. 业务通用组件</h2><h3 id="3-1-背景音乐自动播放多端兼容"><a href="#3-1-背景音乐自动播放多端兼容" class="headerlink" title="3.1 背景音乐自动播放多端兼容"></a>3.1 背景音乐自动播放多端兼容</h3><p>音频组件适应各端，ios ，安卓，微信，qq<br>iOS 端 safari 浏览器或者部分安卓手机的浏览器不支持 autoplay 属性。<br>解决方法：还是<strong>引导用户手动触发播放操作</strong>。<br>比如绑定 touchstart 事件进行 audio.play() 操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">touchInteract () &#123;</span><br><span class="line">  <span class="keyword">let</span> getTouch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.bgm.play();</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">'touchstart'</span>, getTouch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果不能播放用户触屏 开始播放音乐</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$refs.bgm &amp;&amp; <span class="keyword">this</span>.$refs.bgm.currentTime === <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.$refs.bgm.paused) &#123;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, getTouch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 微信特有的预播放</span></span><br><span class="line">wxPreloadPlay () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WeixinJSBridge) &#123;</span><br><span class="line">    WeixinJSBridge.invoke(<span class="string">'getNetworkType'</span>, &#123;&#125;, (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.bgm.play();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wxPlay = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      WeixinJSBridge.invoke(<span class="string">'getNetworkType'</span>, &#123;&#125;, (e) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.bgm.play();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'WeixinJSBridgeReady'</span>, wxPlay);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'WeixinJSBridgeReady'</span>, wxPlay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 切换webview音效，比如缩小窗口，停止播放</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 切换or最小化窗口画面,音效停止</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$refs.bgm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.bgm.pause();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.bgm.play();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-敏感数字过滤"><a href="#3-2-敏感数字过滤" class="headerlink" title="3.2 敏感数字过滤"></a>3.2 敏感数字过滤</h3><p>敏感数据存放在Set集合里面，如果命中，就加一显示，set时间复杂度O(1)，比数组查找每次遍历O(n)性能更优</p><p>通过filter管道过滤<code>likeRankData.like | filterSensitive</code>，实现敏感数字自动加一显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sensitiveSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">6489</span>, <span class="number">8964</span>, <span class="number">53589</span>, <span class="number">89535</span>, <span class="number">198964</span>, <span class="number">641989</span>, <span class="number">1989535</span>, <span class="number">5351989</span>]);</span><br><span class="line">filters: &#123;</span><br><span class="line">    <span class="comment">// 敏感数字过滤</span></span><br><span class="line">    filterSensitive: <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> number = <span class="built_in">Number</span>(num)</span><br><span class="line">      <span class="keyword">return</span> sensitiveSet.has(number) ? number + <span class="number">1</span> : number;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="3-3-组件间的过渡"><a href="#3-3-组件间的过渡" class="headerlink" title="3.3 组件间的过渡"></a>3.3 组件间的过渡</h3><p>所有题目的流程过渡都有渐入渐出的一个效果，为了避免每个组件都写重复的场景过渡，打算自己写一个方法，结果在vue文档找到了一个官方的过渡方法，<code>:is=&quot;组件名&quot;</code>，动态写入组件名，监听到data中的‘quesStep’改变后就会执行过渡转到下一个组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">components</span> <span class="attr">:is</span>=<span class="string">"quesStep"</span> <span class="attr">:quesData</span>=<span class="string">"testQues"</span>&gt;</span><span class="tag">&lt;/<span class="name">components</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有场景的延迟显示细节也都可以使用transition过渡，适合流程类的需要渐入渐出场景页面</p><h2 id="4-总结复盘"><a href="#4-总结复盘" class="headerlink" title="4. 总结复盘"></a>4. 总结复盘</h2><ol><li>项目开始之前，确定哪些组件是可复用的，项目复用级，全局复用级 eg: 全局的背景音乐，动效等</li><li>可以把 vue 拆开 ，避免一个文件过大 难维护</li><li>有些布局，老操作系统不兼容，写之前，多考虑兼容，不然测试出来不兼容，再修改麻烦</li><li>对于一些点击响应需要低延迟的使用<code>touchstart</code>，<code>click</code>事件可能会有延迟</li><li>项目完成计划在前一周就给设计体验，测试提测，避免在上线前来不及修改</li><li>列bug优先级，先解决逻辑体验上bug，再解决样式小问题</li><li>解决bug方面的能力有待加强，怎么解决：<ul><li>列bug优先级，先解决逻辑体验上bug,在解决样式小问题</li><li>精准定位，是否可复现，找到bug原型机</li><li>打断点看哪里数据出错了，是什么类型的问题</li></ul></li><li>移动端不推荐用img标签，长按会触发保存，所以要创一个节点，然后使用背景嵌入图片background</li><li>不要把所有页面的图片加载都放在最前面的loading页，等待时间长用户会流失，在每一页动态调用下一页的图片的动态预加载函数</li><li>使用replace跳转路由，push路由会导致底部出现底部状态栏</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;h5开发总结&quot;&gt;&lt;a href=&quot;#h5开发总结&quot; class=&quot;headerlink&quot; title=&quot;h5开发总结&quot;&gt;&lt;/a&gt;h5开发总结&lt;/h1&gt;&lt;p&gt;做了两个月的创意h5，其中遇到了一些坑与兼容适配方面的问题，做个记录总结，基于vue开发&lt;/p&gt;&lt;h2 id=&quot;1-布局&quot;&gt;&lt;a href=&quot;#1-布局&quot; class=&quot;headerlink&quot; title=&quot;1. 布局&quot;&gt;&lt;/a&gt;1. 布局&lt;/h2&gt;&lt;h3 id=&quot;1-1-元素的长宽&quot;&gt;&lt;a href=&quot;#1-1-元素的长宽&quot; class=&quot;headerlink&quot; title=&quot;1.1 元素的长宽&quot;&gt;&lt;/a&gt;1.1 元素的长宽&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>canvas学习笔记</title>
    <link href="http://yoursite.com/2020/04/04/canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/04/canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-04T01:20:09.560Z</published>
    <updated>2020-04-04T01:24:38.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><h3 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h3><h4 id="绘制弧-曲线"><a href="#绘制弧-曲线" class="headerlink" title="绘制弧/曲线"></a>绘制弧/曲线</h4><p><code>arc()</code> 方法创建弧/曲线（用于创建圆或部分圆）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arc(x,y,r,sAngle,eAngle,counterclockwise);</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><ul><li>x：圆心的 x 坐标</li><li>y：圆心的 y 坐标</li><li>r：圆的半径</li><li>sAngle：起始角，以弧度计（弧的圆形的三点钟位置是 0 度）</li><li>eAngle：结束角，以弧度计</li><li>counterclockwise：可选。规定应该逆时针还是顺时针绘图。false 为顺时针，true 为逆时针</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/11/21/15fdf0929fbe015f?imageslim" alt="图片来自 w3cschool"></p><h4 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h4><p><code>drawImage()</code> 向画布上绘制图像、画布或视频</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);</span><br></pre></td></tr></table></figure><ul><li><code>img</code>：规定要使用的图像、画布或视频</li><li><code>sx</code>：可选。开始剪切的 x 坐标位置</li><li><code>sy</code>：可选。开始剪切的 y 坐标位置</li><li><code>swidth</code>：可选。被剪切图像的宽度</li><li><code>sheight</code>：可选。被剪切图像的高度</li><li><code>x</code>：在画布上放置图像的 x 坐标位置</li><li><code>y</code>：在画布上放置图像的 y 坐标位置</li><li><code>width</code>：可选。要使用的图像的宽度（伸展或缩小图像）</li><li><code>height</code>：可选。要使用的图像的高度（伸展或缩小图像）</li></ul><h4 id="基础方法练习"><a href="#基础方法练习" class="headerlink" title="基础方法练习"></a>基础方法练习</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/canvas/image-20200330144638329.png" alt="image-20200330144638329"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        .canvas &#123;</span></span><br><span class="line"><span class="regexp">            background: #000;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="draw"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;canvas class="canvas"&gt;&lt;/</span>canvas&gt;</span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    let canvas = document.querySelectorAll("canvas");</span></span><br><span class="line"><span class="regexp">    console.log(canvas)</span></span><br><span class="line"><span class="regexp">    let context0 = canvas[0].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context1 = canvas[1].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context2 = canvas[2].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context3 = canvas[3].getContext("2d");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 画布长宽 默认宽300 高150</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ var cx = canvas.width = 400;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ var cy = canvas.height = 400;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画一个圆里面填满</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context0.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 坐标（100，75），半径，起始角3点钟方向，转Math.PI(180)度 ，false逆时针 ,true顺时针</span></span><br><span class="line"><span class="regexp">    context0.arc(100, 75, 50, 0, Math.PI * 2, false);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 填充颜色</span></span><br><span class="line"><span class="regexp">    context0.fillStyle = 'rgb(255,255,255)';</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 设置阴影模糊级别</span></span><br><span class="line"><span class="regexp">    context0.shadowBlur = 50;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 阴影颜色</span></span><br><span class="line"><span class="regexp">    context0.shadowColor = 'red';</span></span><br><span class="line"><span class="regexp">    context0.fill();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画一个<span class="number">1</span>/<span class="number">4</span>圆，连线闭合</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context1.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 坐标（100，75），半径，起始角3点钟方向，顺时针到 Math.PI(180)度结束这个位置 ，画线 false逆时针 ,true顺时针</span></span><br><span class="line"><span class="regexp">    context1.arc(100, 75, 50, 0, Math.PI* 1.5, true);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 形成闭合路径</span></span><br><span class="line"><span class="regexp">    context1.closePath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 描边 </span></span><br><span class="line"><span class="regexp">    context1.strokeStyle="white";</span></span><br><span class="line"><span class="regexp">    context1.stroke();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画几条连续线</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context2.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 把路径移动到画布中的指定点，不创建线条</span></span><br><span class="line"><span class="regexp">    context2.moveTo(50,50);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 添加一个新点，然后在画布中创建从该点到最后指定点的线条</span></span><br><span class="line"><span class="regexp">    context2.lineTo(100,100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 不用moveTo 连续用lineTo也可</span></span><br><span class="line"><span class="regexp">    context2.lineTo(200, 100);</span></span><br><span class="line"><span class="regexp">    context2.lineTo(100,50);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 线条宽度</span></span><br><span class="line"><span class="regexp">    context2.lineWidth = 10;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 起始和终点线圆角</span></span><br><span class="line"><span class="regexp">    context2.lineCap = 'round'</span></span><br><span class="line"><span class="regexp">    context2.strokeStyle = '#fff';</span></span><br><span class="line"><span class="regexp">    context2.stroke();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画矩形</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context3.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 设置渐变 （开始x, 开始y, 结束x， 结束y）</span></span><br><span class="line"><span class="regexp">    let grd = context3.createLinearGradient(20,10,100,100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ grd.addColorStop(0,'pink');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ grd.addColorStop(1,'white');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 初始位置0， 结束位置1</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0,'rgb(255, 0, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.2,'rgb(255, 165, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.3,'rgb(255, 255, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.5,'rgb(0, 255, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.7,'rgb(0, 127, 255)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.9,'rgb(0, 0, 255)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(1,'rgb(139, 0, 255)');</span></span><br><span class="line"><span class="regexp">    context3.fillStyle = grd;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 实心矩形 参数：左上的角位置(x, y, 宽， 高)</span></span><br><span class="line"><span class="regexp">    context3.fillRect(20, 10, 100, 100);</span></span><br><span class="line"><span class="regexp">    context3.strokeStyle = '#fff';</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 空心矩形</span></span><br><span class="line"><span class="regexp">    context3.strokeRect(130, 10, 100, 100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 旋转轴心在 画布的 左上角</span></span><br><span class="line"><span class="regexp">    context3.rotate(5*Math.PI/</span><span class="number">180</span>);</span><br><span class="line">    context3.strokeRect(<span class="number">130</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 线条的长宽 和坐标的位置都被放大了</span></span><br><span class="line">    context3.scale(<span class="number">1.2</span>,<span class="number">1.2</span>);</span><br><span class="line">    context3.strokeRect(<span class="number">130</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><hr><p>好看渐变色网站 <a href="https://uigradients.com/#MangoPulp" target="_blank" rel="noopener">uigradients</a>用来做背景</p><h3 id="canvas随机粒子移动-鼠标移动效果"><a href="#canvas随机粒子移动-鼠标移动效果" class="headerlink" title="canvas随机粒子移动+鼠标移动效果"></a>canvas随机粒子移动+鼠标移动效果</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/canvas/particle.gif" alt="particle"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html, body &#123;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">            overflow: hidden;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">            height: 100%;</span></span><br><span class="line"><span class="regexp">            cursor: none;</span></span><br><span class="line"><span class="regexp">            background: black;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;canvas id="canvas"&gt;&lt;/</span>canvas&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>),</span><br><span class="line">        content = ctx.getContext(<span class="string">'2d'</span>),</span><br><span class="line">        round = [],</span><br><span class="line">        WIDTH = <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">        HEIGHT = <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">        <span class="comment">// 粒子个数</span></span><br><span class="line">        initRoundPopulation = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">let</span>  round_arr = [],</span><br><span class="line">        para = &#123;</span><br><span class="line">            num: <span class="number">100</span>,</span><br><span class="line">            color: <span class="literal">false</span>,    <span class="comment">//  颜色  如果是false 则是随机渐变颜色</span></span><br><span class="line">            r: <span class="number">0.9</span>,</span><br><span class="line">            o: <span class="number">0.09</span>,         <span class="comment">//  判断圆消失的条件，数值越大，消失的越快</span></span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        color,</span><br><span class="line">        color2</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 满屏</span></span><br><span class="line">    ctx.width = WIDTH;</span><br><span class="line">    ctx.height = HEIGHT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断参数中是否设置了 color，如果设置了 color，就使用该值、</span></span><br><span class="line">    <span class="comment">// 如果参数中的 color 为 false，那么就使用随机的颜色</span></span><br><span class="line">    <span class="keyword">if</span> (para.color) &#123;</span><br><span class="line">        color2 = para.color;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="built_in">Math</span>.random() * <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        mouseX = event.clientX;</span><br><span class="line">        mouseY = event.clientY;</span><br><span class="line"></span><br><span class="line">        round_arr.push(&#123;</span><br><span class="line">            mouseX: mouseX,</span><br><span class="line">            mouseY: mouseY,</span><br><span class="line">            r: para.r,</span><br><span class="line">            o: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 随机圆的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Round_item</span>(<span class="params">index, x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="comment">// 1-3的随机半径</span></span><br><span class="line">        <span class="keyword">this</span>.r = <span class="built_in">Math</span>.random() * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 随机透明度 0.05-0.55</span></span><br><span class="line">        <span class="keyword">var</span> alpha = (<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>) / <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"rgba(255,255,255,"</span> + alpha + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Round_item.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        content.shadowBlur = <span class="keyword">this</span>.r * <span class="number">2</span>;</span><br><span class="line">        content.beginPath();</span><br><span class="line">        content.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">        content.closePath();</span><br><span class="line">        content.fill();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.clearRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> round) &#123;</span><br><span class="line">            round[i].move();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        requestAnimationFrame(animate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动粒子的y坐标，向上运动</span></span><br><span class="line">    Round_item.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y -= <span class="number">0.15</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.y &lt;= <span class="number">-10</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.y = HEIGHT + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; initRoundPopulation; i++) &#123;</span><br><span class="line">            round[i] = <span class="keyword">new</span> Round_item(i, <span class="built_in">Math</span>.random() * WIDTH, <span class="built_in">Math</span>.random() * HEIGHT);</span><br><span class="line">            round[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">        animate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;canvas&quot;&gt;&lt;a href=&quot;#canvas&quot; class=&quot;headerlink&quot; title=&quot;canvas&quot;&gt;&lt;/a&gt;canvas&lt;/h1&gt;&lt;h3 id=&quot;基础方法&quot;&gt;&lt;a href=&quot;#基础方法&quot; class=&quot;headerlink&quot; title=&quot;基础方法&quot;&gt;&lt;/a&gt;基础方法&lt;/h3&gt;&lt;h4 id=&quot;绘制弧-曲线&quot;&gt;&lt;a href=&quot;#绘制弧-曲线&quot; class=&quot;headerlink&quot; title=&quot;绘制弧/曲线&quot;&gt;&lt;/a&gt;绘制弧/曲线&lt;/h4&gt;&lt;p&gt;&lt;code&gt;arc()&lt;/code&gt; 方法创建弧/曲线（用于创建圆或部分圆）。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;context.arc(x,y,r,sAngle,eAngle,counterclockwise);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>设计问题，数学 leetcode</title>
    <link href="http://yoursite.com/2020/03/27/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-leetcode/"/>
    <id>http://yoursite.com/2020/03/27/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-leetcode/</id>
    <published>2020-03-27T04:25:56.090Z</published>
    <updated>2021-03-07T00:43:46.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="随机数组"><a href="#随机数组" class="headerlink" title="随机数组"></a>随机数组</h3><h4 id="Shuffle-an-Array"><a href="#Shuffle-an-Array" class="headerlink" title="Shuffle an Array"></a>Shuffle an Array</h4><p>打乱一个没有重复元素的数组。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 以数字集合 1, 2 和 3 初始化数组。</span><br><span class="line">int[] nums = &#123;1,2,3&#125;;</span><br><span class="line">Solution solution = new Solution(nums);</span><br><span class="line"></span><br><span class="line">// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。</span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line">// 重设数组到它的初始状态[1,2,3]。</span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line">// 随机返回数组[1,2,3]打乱后的结果。</span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Solution = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the array to its original configuration and return it.</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Solution.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nums</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random shuffling of the array.</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Solution.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 并不是真正随机,sort小于10个是插入排序，大于是快速排序</span></span><br><span class="line">    <span class="comment">// nums.sort(()=&gt;Math.random() - 0.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展运算符 深拷贝 ，直接赋值是赋引用地址，会把原数组改变</span></span><br><span class="line">    <span class="keyword">let</span> arr = [...this.nums]</span><br><span class="line">    <span class="keyword">let</span> len = <span class="keyword">this</span>.nums.length</span><br><span class="line">    <span class="keyword">let</span> j ,x</span><br><span class="line">    <span class="comment">// 取得随机位置，与当前位置交换</span></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len--))</span><br><span class="line">        <span class="comment">// [arr[i], arr[random]] = [arr[random], arr[i]]  </span></span><br><span class="line">        <span class="comment">// 结构赋值leetcode用不了有点奇怪</span></span><br><span class="line">        t = arr[len]</span><br><span class="line">        arr[len] = arr[j]</span><br><span class="line">        arr[j] = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new Solution(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.reset()</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.shuffle()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a>Fizz Buzz</h3><p>写一个程序，输出从 1 到 <em>n</em> 数字的字符串表示。</p><ol><li><p>如果 <em>n</em> 是3的倍数，输出“Fizz”；</p></li><li><p>如果 <em>n</em> 是5的倍数，输出“Buzz”；</p></li><li><p>如果 <em>n</em> 同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><p>解：除余数，然后字符串拼接，如果不是就直接加数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fizzBuzz = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="string">''</span></span><br><span class="line">        x += i % <span class="number">3</span> ? <span class="string">''</span> : <span class="string">'Fizz'</span></span><br><span class="line">        x += i % <span class="number">5</span> ? <span class="string">''</span> : <span class="string">'Buzz'</span></span><br><span class="line">        <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">            x += i</span><br><span class="line">        &#125;</span><br><span class="line">        str.push(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h3><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p>解：厄拉多塞筛法，把当前循环数的倍数全都标记，没有标记的就是质数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr[i]) &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 从两倍开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i * <span class="number">2</span>; j &lt; n; j += i) &#123;</span><br><span class="line">                arr[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3的幂"><a href="#3的幂" class="headerlink" title="3的幂"></a>3的幂</h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><p>解：可以使用3进制转换</p><ul><li>n = 1 时 ==&gt; 转3进制数为 1</li><li>n = 3 时 ==&gt; 转3进制数为 10</li><li>n = 9 时 ==&gt; 转3进制数为 100</li><li>n = 27 时 ==&gt; 转3进制数为 1000</li></ul><p>得出结论，3的幂次方的3进制都是1开头的，后面都是0</p><p>进制转换：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toString" target="_blank" rel="noopener">Number.prototype.toString()</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfThree = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配1开头的 0有0个或以上 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^10*$/</span>.test(n.toString(<span class="number">3</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>解：先把罗马对应的数值存map，然后与后一个比较，如果小于后一个就是减，大于就是加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> romaMap = &#123;</span><br><span class="line">        <span class="string">"I"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"V"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"X"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">"L"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">"C"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">"D"</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">"M"</span>: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        romaMap[s[i]] &lt; romaMap[s[i+<span class="number">1</span>]] ? sum -= romaMap[s[i]] : sum += romaMap[s[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;随机数组&quot;&gt;&lt;a href=&quot;#随机数组&quot; class=&quot;headerlink&quot; title=&quot;随机数组&quot;&gt;&lt;/a&gt;随机数组&lt;/h3&gt;&lt;h4 id=&quot;Shuffle-an-Array&quot;&gt;&lt;a href=&quot;#Shuffle-an-Array&quot; class=&quot;headerlink&quot; title=&quot;Shuffle an Array&quot;&gt;&lt;/a&gt;Shuffle an Array&lt;/h4&gt;&lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 以数字集合 1, 2 和 3 初始化数组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int[] nums = &amp;#123;1,2,3&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Solution solution = new Solution(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.shuffle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 重设数组到它的初始状态[1,2,3]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.reset();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 随机返回数组[1,2,3]打乱后的结果。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.shuffle();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划leetcode</title>
    <link href="http://yoursite.com/2020/03/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-16T02:19:31.912Z</published>
    <updated>2020-03-16T02:19:39.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过递推，得到爬楼梯是个斐波那契数列</span></span><br><span class="line"><span class="comment">// 所以使用迭代</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fibo = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fibo [i] = fibo[i<span class="number">-1</span>] + fibo[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibo[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最大利润差</span></span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 最小价格</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minPrice&gt;prices[i]) &#123;</span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前价格-最小价格 比较最大利润差</span></span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, prices[i]-minPrice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="comment">// 如果之前加的和大于0 则把当前值加进来</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就把之前的丢弃，把当前值赋进来</span></span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把最大的比出来，也可以防止后面数是负数</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p>解：这种题最好拿纸比划比划，光脑子想，头有点裂开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 前一个最大值</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 当前最大值 </span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur</span><br><span class="line">        <span class="comment">// 当前最大值 和 前一个最大值+遍历值做比较</span></span><br><span class="line">        cur = <span class="built_in">Math</span>.max(cur, pre+item)</span><br><span class="line">        pre = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。&lt;/p&gt;&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS中的正则</title>
    <link href="http://yoursite.com/2020/03/01/%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2020/03/01/%E6%AD%A3%E5%88%99/</id>
    <published>2020-03-01T09:31:21.211Z</published>
    <updated>2020-03-16T04:11:11.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>RegExp.prototype.exec</td><td>一个在字符串中执行查找匹配的RegExp方法，它返回一个<strong>数组</strong>（未匹配到则返回 null）。</td></tr><tr><td>RegExp.prototype.test</td><td>一个在字符串中测试是否匹配的RegExp方法，它<strong>返回 true 或 false</strong>。</td></tr><tr><td>String.prototype.match</td><td>一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td>String.prototype.matchAll</td><td>一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td>String.prototype.search</td><td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td>String.prototype.replace</td><td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td>String.prototype.split</td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><h3 id="符号表格"><a href="#符号表格" class="headerlink" title="符号表格"></a>符号表格</h3><table><thead><tr><th>特殊字符</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>换行符</td><td>\n</td><td><strong>n</strong>ew line</td></tr><tr><td>换页符</td><td>\f</td><td><strong>f</strong>orm feed</td></tr><tr><td>回车符</td><td>\r</td><td><strong>r</strong>eturn</td></tr><tr><td>空白符</td><td>\s</td><td><strong>s</strong>pace</td></tr><tr><td>非空白符</td><td>\S</td><td></td></tr><tr><td>制表符</td><td>\t</td><td><strong>t</strong>ab</td></tr><tr><td>垂直制表符</td><td>\v</td><td><strong>v</strong>ertical tab</td></tr><tr><td>单词边界</td><td>\b</td><td><strong>b</strong>oundary</td></tr><tr><td>非单词边界</td><td>\B</td><td></td></tr><tr><td>回退符</td><td>[\b]</td><td><strong>b</strong>ackspace,之所以使用[]符号是避免和\b重复</td></tr><tr><td>除了换行符之外的任何字符</td><td>.</td><td>句号,除了句子结束符</td></tr><tr><td>单个数字, [0-9]</td><td>\d</td><td><strong>d</strong>igit</td></tr><tr><td>除了[0-9]</td><td>\D</td><td><strong>not</strong> <strong>d</strong>igit</td></tr><tr><td>包括下划线在内的单个字符，[A-Za-z0-9_]</td><td>\w</td><td><strong>w</strong>ord</td></tr><tr><td>非单字字符</td><td>\W</td><td><strong>not</strong> <strong>w</strong>ord</td></tr><tr><td>0 或1个字符，惰性匹配</td><td>?</td><td>有无？</td></tr><tr><td>大于0个字符</td><td>*</td><td></td></tr><tr><td>大于1个字符</td><td>+</td><td>+1</td></tr><tr><td>分组</td><td>()</td><td></td></tr><tr><td>匹配区间集合</td><td>[ ]</td><td>[0-9] , [a-z]</td></tr><tr><td>匹配重复次数</td><td>{ }</td><td></td></tr></tbody></table><blockquote><ul><li>{x}: x次</li></ul><ul><li>{min, max}： 介于min次到max次之间</li><li>{min, }: 至少min次</li><li>{0, max}： 至多max次</li></ul></blockquote><table><thead><tr><th>边界和标志</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>字符串开头</td><td>^</td><td></td></tr><tr><td>字符串结尾</td><td>$</td><td></td></tr><tr><td>多行模式</td><td>m标志</td><td><strong>m</strong>ultiple of lines</td></tr><tr><td>忽略大小写</td><td>i标志</td><td><strong>i</strong>gnore case, case-<strong>i</strong>nsensitive</td></tr><tr><td>全局模式</td><td>g标志</td><td><strong>g</strong>lobal</td></tr></tbody></table><h3 id="p-和-p-的理解"><a href="#p-和-p-的理解" class="headerlink" title="(?=p)和(?!p)的理解"></a><strong>(?=p)和(?!p)的理解</strong></h3><p><code>(?=p)</code>，其中<code>p</code>是一个子模式，即<code>p</code>前面的<strong>位置</strong>。</p><p>比如<code>(?=l)</code>，表示’l’字符前面的位置，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配l前面的位置</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">'#'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); </span><br><span class="line"><span class="comment">// =&gt; "he#l#lo"</span></span><br></pre></td></tr></table></figure><p>而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?!l)/g</span>, <span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); </span><br><span class="line"><span class="comment">// =&gt; "#h#ell#o#"</span></span><br></pre></td></tr></table></figure><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意里面的<code>\1</code>，表示的引用之前小括号的那个分组<code>(-|\/|\.)</code>。</p><p><code>\2</code>和<code>\3</code>即分别指代第二个和第三个分组。</p><p><strong>括号嵌套</strong>以左括号为准</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><p>更复杂的正则 参考推荐老姚写的正则迷你书：<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5965943ff265da6c30653879#heading-5</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;RegExp.prototype.exec&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的RegExp方法，它返回一个&lt;strong&gt;数组&lt;/strong&gt;（未匹配到则返回 null）。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RegExp.prototype.test&lt;/td&gt;&lt;td&gt;一个在字符串中测试是否匹配的RegExp方法，它&lt;strong&gt;返回 true 或 false&lt;/strong&gt;。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.match&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.matchAll&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.search&lt;/td&gt;&lt;td&gt;一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.replace&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.split&lt;/td&gt;&lt;td&gt;一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 &lt;code&gt;String&lt;/code&gt; 方法。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网络基础 复习</title>
    <link href="http://yoursite.com/2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%20180414/"/>
    <id>http://yoursite.com/2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%20180414/</id>
    <published>2020-02-28T02:01:32.889Z</published>
    <updated>2020-02-28T02:01:32.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 协议是<strong>面向无连接</strong>的，正式传递数据之前<strong>不需要先连接</strong>起双方（不可靠性）。不会对数据报文进行任何拆分和拼接操作（高效）。</p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>UDP支持一对多，多对多，多对一的方式。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 建立连接断开连接都需要先需要进行握手。</p><h4 id="建立连接3次握手"><a href="#建立连接3次握手" class="headerlink" title="建立连接3次握手"></a>建立连接3次握手</h4><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1631bf1e79b3cd42" alt="img"></p><h4 id="断开连接四次握手"><a href="#断开连接四次握手" class="headerlink" title="断开连接四次握手"></a>断开连接四次握手</h4><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1631fb807f2c6c1b" alt="img"></p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get post 区别"></a>get post 区别</h3><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点，因为Get 请求都包含在 URL 里（当然你想写到 <code>body</code> 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。</li><li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li></ul><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p><strong>2XX 成功</strong></p><ul><li><p>！！200 OK，表示从客户端发来的请求在服务器端被正确处理</p></li><li><p>204 No content，表示请求成功，但响应报文不含实体的主体部分（请求成功但是没有资源返回）</p></li><li><p>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</p></li><li><p>206 Partial Content，进行范围请求</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efb76d2b65f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li></ul><p><strong>3XX 重定向</strong></p><ul><li><p>！！<strong>301 moved permanently，永久性重定向</strong>，表示资源已被分配了新的 URL</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efa6a4ba749?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！<strong>302 found，临时性重定向</strong>，表示资源临时被分配了新的 URL</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efba78b2b7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>303 see other，表示资源存在着另一个 URL，应使用 <strong>GET</strong> 方法获取资源</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efbc1b5cfce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！<strong>304 not modified</strong>，表示服务器允许访问资源，但因发生请求未满足条件的情况（304 虽 然被划分在 3XX 类别中，但是和重定向没有关系。）</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaa07f726e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>307 temporary redirect，临时重定向，和302含义类似，尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。</p><p>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况</p></li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><p>！！400 bad request，请求<strong>报文存在语法错误</strong></p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaa064bdb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！401 unauthorized，表示发送的请求需要有通过 <strong>HTTP 认证</strong>的认证信息</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efacc2e6a4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！403 forbidden，表示对请求资源的访问<strong>被服务器拒绝</strong></p></li><li><p>！！404 not found，表示在服务器上<strong>没有找到</strong>请求的<strong>资源</strong></p></li><li><p>405 Method Not Allowed， 客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法（GET 和 HEAD 方法，服务器应该总是允许客户端进行访问）</p><blockquote><p>客户端可以通过 OPTIONS 方法来查看服务器允许的访问方法, 如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><p>！！500 internal sever error，表示服务器端在执行请求时发生了错误</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efae2420839?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</p></li><li><p>502 Bad Gateway，表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。（通常不是客户端能够修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复）</p></li><li><p>！！503 service unavailable，表明服务器暂时处于<strong>超负载或正在停机维护</strong>，无法处理请求</p></li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaf01b284a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><p><strong>对称加密</strong>：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p><strong>非对称加密</strong>：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>流程：首先<strong>服务端</strong>将<strong>公钥公布</strong>出去，那么客户端也就知道公钥了。接下来<strong>客户端</strong>创建一个<strong>秘钥</strong>，然后<strong>通过公钥加密</strong>并发送给<strong>服务端</strong>，<strong>服务端接收</strong>到密文以后通过<strong>私钥解密出正确的秘钥</strong>，这时候两端就都知道秘钥是什么了。</p><h3 id="ssl握手过程"><a href="#ssl握手过程" class="headerlink" title="ssl握手过程"></a>ssl握手过程</h3><ol><li>首先，<strong>客户端</strong> 访问 <strong>服务端</strong> 。这时候<strong>客户端 会生成一个随机数</strong>1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务端。</li><li><strong>服务器</strong> 收到这些信息后，然后确认一下双方的加密算法，然后服务端也生成一个随机数 2 ，并<strong>将随机数 2 和 CA 颁发给自己的证书一同返回</strong>给客户端 A 。</li><li><strong>客户端</strong> 得到 CA 证书后，会去校验该 CA 证书的有效性，校验通过后，客户端生成一个随机数 3 ，然后<strong>用证书中的公钥加密随机数 3</strong> 并传输给服务端 。</li><li><strong>服务端</strong> 得到加密后的<strong>随机数 3</strong>，然后利用<strong>私钥进行解密</strong>，得到真正的随机数3。</li><li>最后，客户端 和 服务端 都有随机数1、随机数2、随机数3，然后双方利用这<strong>三个随机数生成一个对话密钥</strong>。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。</li><li>客户端 通知 服务端 ，指明后面的通讯用对话密钥来完成，同时通知 服务端 握手过程结束。</li><li>服务端 通知 客户端 ，指明后面的通讯用对话密钥来完成，同时通知客户端 握手过程结束。</li><li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 和服务端 开始使用相同的对话密钥进行数据通讯。</li></ol><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><p>在 HTTP/2 中引入了<strong>多路复用</strong>的技术（就是在<strong>一个 TCP</strong> 连接中可以存在<strong>多条流</strong>，对端可以通过<strong>帧中的标识</strong>知道属于哪个请求）。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，可以避免 HTTP 旧版本中的队头阻塞问题，更容易实现全速传输。</p><blockquote><p><strong>帧</strong>代表着<strong>最小的数据单位</strong>，每个帧会标识出该帧属于哪个流，<strong>流</strong>也就是<strong>多个帧组成</strong>的数据流。</p></blockquote><p>在之前的 HTTP 版本中，我们是通过<strong>文本</strong>的方式传输数据。在 HTTP/2 中所有传输的数据都会被分割，并采用<strong>二进制格式编码</strong>。</p><p>在 HTTP /2 中，使用了 HPACK <strong>压缩</strong>格式对传输的 header 进行编码，减少了 <strong>header</strong> 的大小。并在两端维护了<strong>索引表</strong>，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的<strong>键名</strong>，对端收到数据后就可以通过<strong>键名找到对应的值</strong>。</p><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了，导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能</p><p><strong>多路复用</strong></p><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p><p>并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p><p><strong>纠错机制</strong></p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</p><p>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</p><p><strong>0-RTT</strong></p><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p><h3 id="输入-URL-到页面渲染的整个流程"><a href="#输入-URL-到页面渲染的整个流程" class="headerlink" title="输入 URL 到页面渲染的整个流程"></a>输入 URL 到页面渲染的整个流程</h3><h4 id="dns查询"><a href="#dns查询" class="headerlink" title="dns查询"></a>dns查询</h4><ol><li>操作系统会首先在<strong>本地缓存</strong>中查询 IP</li><li>没有的话会去<strong>系统配置</strong>的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 <strong>DNS 根服务器查询</strong>，这一步查询会找出负责 <code>com</code> 这个一级域名的服务器</li><li>然后去该服务器查询 <code>google</code> 这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 <code>www</code> 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ol><p>接下来是 TCP 握手，应用层会下发数据给传输层，这里 <strong>TCP 协议</strong>会指明两端的<strong>端口</strong>号，然后下发给网络层。<strong>网络层</strong>中的 <strong>IP 协议</strong>会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。</p><p>TLS 的握手情况以及两种加密方式：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p><p>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上。这时假设服务端会响应一个 HTML 文件。</p><p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</p><p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。</p><p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p><p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; title=&quot;网络基础&quot;&gt;&lt;/a&gt;网络基础&lt;/h1&gt;&lt;h3 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h3&gt;&lt;p&gt;UDP 协议是&lt;strong&gt;面向无连接&lt;/strong&gt;的，正式传递数据之前&lt;strong&gt;不需要先连接&lt;/strong&gt;起双方（不可靠性）。不会对数据报文进行任何拆分和拼接操作（高效）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode树 算法基础</title>
    <link href="http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-27T05:02:30.073Z</published>
    <updated>2020-02-29T04:21:21.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode树-算法基础"><a href="#leetcode树-算法基础" class="headerlink" title="leetcode树 算法基础"></a>leetcode树 算法基础</h1><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>解：</strong>递归遍历左右子树，每层+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left)</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>解答：</strong>之前理解错了，不是当前节点满足就行，子节点的所有祖先节点都要满足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, pre = null, next = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 先序遍历 以及哪些上下限进行了比较</span></span><br><span class="line">  <span class="comment">// sole.log(root &amp;&amp; root.val, pre &amp;&amp; pre.val, next &amp;&amp; next.val);</span></span><br><span class="line">  <span class="keyword">if</span> (pre &amp;&amp; pre.val &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (next &amp;&amp; next.val &lt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 逻辑判断 递归 如果左边true就是遍历倒底了 则返回右边</span></span><br><span class="line">  <span class="comment">// ！关键递归 如果是左子节点把当前节点作为下限 右子节点把当前节点作为上限 </span></span><br><span class="line">  <span class="keyword">return</span> isValidBST(root.left, pre, root) &amp;&amp; isValidBST(root.right, root, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>解答：还是递归，左右镜像判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空树直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMirror</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两子都为空，返回真</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 有一边为空，则不对称</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> || right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 条件判断 左边的子左边与右边的子右边相等 </span></span><br><span class="line">    <span class="keyword">return</span> left.val === right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解答： 打印root树仔细查看它的结构，迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="comment">// 每层的子节点数</span></span><br><span class="line">        <span class="keyword">let</span> level = queue.length</span><br><span class="line">        <span class="keyword">let</span> current = []</span><br><span class="line">        <span class="keyword">while</span>(level--) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            current.push(node.val)</span><br><span class="line">            <span class="keyword">if</span> (node.left) queue.push(node.left)</span><br><span class="line">            <span class="keyword">if</span> (node.right) queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>解答：要明确两个点，1.二叉搜索树左子树小右子树大，高度要平衡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> middleL = nums.length &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment">// 每次取到中间数</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(nums[middleL])</span><br><span class="line">    <span class="comment">// 递归，左边左树，右边右数</span></span><br><span class="line">    node.left = sortedArrayToBST(nums.slice(<span class="number">0</span>, middleL))</span><br><span class="line">    node.right = sortedArrayToBST(nums.slice(middleL + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>希望能步入学习正轨，看同届前端群的好几位大哥进腾讯阿里提前批就上岸了。自己不能越差越远啊</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode树-算法基础&quot;&gt;&lt;a href=&quot;#leetcode树-算法基础&quot; class=&quot;headerlink&quot; title=&quot;leetcode树 算法基础&quot;&gt;&lt;/a&gt;leetcode树 算法基础&lt;/h1&gt;&lt;h3 id=&quot;二叉树的最大深度&quot;&gt;&lt;a href=&quot;#二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度&quot;&gt;&lt;/a&gt;二叉树的最大深度&lt;/h3&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基础排序算法JS实现</title>
    <link href="http://yoursite.com/2020/02/23/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/"/>
    <id>http://yoursite.com/2020/02/23/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/</id>
    <published>2020-02-23T10:12:38.689Z</published>
    <updated>2020-02-23T11:16:14.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法JS实现"><a href="#基础排序算法JS实现" class="headerlink" title="基础排序算法JS实现"></a>基础排序算法JS实现</h1><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1</p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>先定义一个交换位置函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr 传入数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; a 要交换的数组下标index</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; b index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[a]</span><br><span class="line">  arr[a] = arr[b]</span><br><span class="line">  arr[b] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与有序的数组进行比较，<strong>比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="comment">// 从第二个开始，把第一个设为初有序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="comment">// 取出当前遍历数组的数</span></span><br><span class="line">    <span class="keyword">let</span> tNum = arr.splice(i, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 从有序数组末尾开始比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">// 比最小的小，直接插入队头</span></span><br><span class="line">      <span class="keyword">if</span>(tNum &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        arr.unshift(tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到个合适的位置插入</span></span><br><span class="line">      <span class="keyword">if</span> (tNum &gt; arr[j]) &#123;</span><br><span class="line">        arr.splice(j+<span class="number">1</span>, <span class="number">0</span>, tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到数组中最大的元素，与数组未排序最后一位元素交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有一个数时就不要排序了 -1趟</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">        max = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把最大的放到最后面</span></span><br><span class="line">    swap(arr, max, arr.length<span class="number">-1</span>-i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>选择一个中间节点，小的放左边，大的放右边，不断递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取数组中间下标值</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.splice(arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = [],</span><br><span class="line">    right = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] &lt; middle ? left.push(arr[i]) : right.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quick(left).concat(middle,quick(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分而治之加递归，先把数组递归二分，然后比较合并</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="merge-sort-example.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="comment">// 如果数组长度小于二直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取到中间值 同等于 Math.floor(arr.length/2)</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.length &gt;&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 切出左右两边 （start,end断掉下标前一位)</span></span><br><span class="line">    left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle)</span><br><span class="line">  <span class="comment">// 递归拆分，然后比较，合并比较，这里理解难点，可以动手画一画程序流程</span></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="comment">// 两边数组头项 比较大小</span></span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">// 如果左边小，就把左边数组头项取出，推入新结果</span></span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果左边有右边没有情况下直接推入</span></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift())</span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><a href="https://www.bilibili.com/video/av47196993?from=search&seid=3195181450169677356" target="_blank" rel="noopener">堆排序视频讲解C语言实现</a></p><p>用数组可以表示一个完全二叉树，左子节点<code>2i+1</code>，右子节点<code>2i+2</code></p><blockquote><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从最后一个含有子节点的父节点开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i, arr.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 堆完成后，每次把对顶最大的数放到末尾</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    <span class="comment">// 交换之后，再规范堆的位置</span></span><br><span class="line">    heapify(arr, <span class="number">0</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arr 数组(堆)</span></span><br><span class="line"><span class="comment"> * i 数组(堆)下标</span></span><br><span class="line"><span class="comment"> * length 数组(堆)长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 完全二叉树,堆函数顺序化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span> (<span class="params">arr, i, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = arr[i]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">    parent = arr[i]</span><br><span class="line">    <span class="comment">// 找到两子节点中较大的一个，再与父节点比较</span></span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent &lt; arr[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点大于子节点:交换；否则跳出</span></span><br><span class="line">      swap(arr, i, j)</span><br><span class="line">      <span class="comment">// 交换后，parent 的值下标变为交换的子节点</span></span><br><span class="line">      i = j</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在家这么久效率有些低，这篇排序还做了这么久，之前数据结构课程也都复习过，疫情快快过去把，想去图书馆里了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法JS实现&quot;&gt;&lt;a href=&quot;#基础排序算法JS实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法JS实现&quot;&gt;&lt;/a&gt;基础排序算法JS实现&lt;/h1&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-02-15T11:20:10.147Z</published>
    <updated>2020-02-23T10:11:58.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &lt;&lt; 1 // -&gt; 20</span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &gt;&gt; 1 // -&gt; 5</span><br></pre></td></tr></table></figure><p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 <code>a / (2 ^ b)</code></p><h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p><strong>按位与</strong></p><p>每一位都为 1，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 &amp; 7 // -&gt; 0</span><br><span class="line">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>按位或</strong></p><p>其中一位为 1，结果就是 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 | 7 // -&gt; 15</span><br><span class="line">// 1000 | 0111 -&gt; 1111 -&gt; 15</span><br></pre></td></tr></table></figure><p><strong>按位异或</strong></p><p>每一位都不同，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8 ^ 7 // -&gt; 15</span><br><span class="line">8 ^ 8 // -&gt; 0</span><br><span class="line">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span><br><span class="line">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><h3 id="两个数不使用四则运算得出和"><a href="#两个数不使用四则运算得出和" class="headerlink" title="两个数不使用四则运算得出和"></a>两个数不使用四则运算得出和</h3><p>通过迭代的方式模拟加法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">    <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;h3 id=&quot;左移-lt-lt&quot;&gt;&lt;a href=&quot;#左移-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移 &amp;lt;&amp;lt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10 &amp;lt;&amp;lt; 1 // -&amp;gt; 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;左移就是将二进制全部往左移动，&lt;code&gt;10&lt;/code&gt; 在二进制中表示为 &lt;code&gt;1010&lt;/code&gt; ，左移一位后变成 &lt;code&gt;10100&lt;/code&gt; ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 &lt;code&gt;a * (2 ^ b)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS的类型转换</title>
    <link href="http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-02-09T10:23:15.266Z</published>
    <updated>2020-02-10T07:44:53.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h1><p>除去 Object 和 Symbol，有如下几种原始类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li></ul><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>在 JavaScript 进行<strong>对比</strong>或者<strong>各种运算</strong>的时候会把对象转换成这些类型，从而进行后续的操作</p><h3 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h3><ol><li><p><strong>对象</strong>转为<strong>布尔</strong>都为 true</p></li><li><p><strong>对象</strong>转为<strong>字符串</strong>，先<code>toString()</code>方法，如果<strong>未</strong>返回原始类型，再<code>valueOf()</code>方法，再不行就报错</p></li><li><p><strong>对象</strong>转为<strong>数字</strong>，先<code>valueOf()</code>方法，如果<strong>未</strong>返回原始类型，再<code>toString()</code>方法，再不行就报错，反过来的</p></li></ol><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><h4 id="运算规则"><a href="#运算规则" class="headerlink" title="==运算规则"></a>==运算规则</h4><ul><li><p>如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较。</p></li><li><p>如果一个值是<strong>对象</strong>，另一个值是<strong>数字或字符串</strong>，则将<strong>对象转换为原始值</strong>再进行比较。对象通过toString()方法或valueOf()方法转换为原始值。JavaScript语言核心的内置类首<strong>先尝试使用valueOf()，在尝试使用toString()</strong>，除了日期类，日期类只使用toString()方法，那些不是JavaScript语言核心中的对象则通过各自实现中定义的方法转换为原始值。</p></li></ul><h4 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h4><ul><li>toString</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d44d25a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>valueOf</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d85b808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>转为boolean类型</li></ul><p>所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true</p><h3 id="运算符类型转化"><a href="#运算符类型转化" class="headerlink" title="+运算符类型转化"></a>+运算符类型转化</h3><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d0924e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! + [] + [] + ![]</span><br></pre></td></tr></table></figure><ol><li><p>先运算一元运算符， <code>+[]</code>转为Number类型 ，返回0，<code>![]</code>转为Boolean类型 ，!true 返回false.<code>!0+[]+false</code></p></li><li><p><code>true+[]+false</code></p></li><li><p><code>true+&quot;&quot;+false</code>返回<code>&quot;truefalse&quot;</code></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS的类型转换&quot;&gt;&lt;a href=&quot;#JS的类型转换&quot; class=&quot;headerlink&quot; title=&quot;JS的类型转换&quot;&gt;&lt;/a&gt;JS的类型转换&lt;/h1&gt;&lt;p&gt;除去 Object 和 Symbol，有如下几种原始类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Number&lt;/li&gt;&lt;li&gt;String&lt;/li&gt;&lt;li&gt;Boolean&lt;/li&gt;&lt;li&gt;Undefined&lt;/li&gt;&lt;li&gt;Null&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器跨域问题</title>
    <link href="http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-08T03:46:27.582Z</published>
    <updated>2020-02-08T14:10:46.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h1><blockquote><p>处于安全考虑 如果<strong>协议、域名或者端口</strong>有一个不同就是跨域，Ajax 请求会失败。</p></blockquote><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><blockquote><p>利用<code>&lt;script&gt;</code>标签<strong>没有 跨域限制</strong>，<strong>指向</strong>一个需要<strong>访问的地址</strong>并提供一个<strong>回调</strong>函数来<strong>接收数据</strong>。只限于 <code>get</code> 请求。</p></blockquote><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>实现jsonp封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="comment">// 约定一个callback字段名，来传递函数名，前端通过该函数来拿到数据</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><blockquote><p>它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。</p></blockquote><p>在服务端增加一些<strong>头部属性</strong>就行，客户端浏览器会自动添加origin字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入http库</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="comment">// 字段</span></span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">      <span class="comment">// 允许请求的地址</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">      <span class="comment">// 请求方法</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET, POST, PUT'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    response.end(<span class="string">'request success!!!'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浏览器跨域问题&quot;&gt;&lt;a href=&quot;#浏览器跨域问题&quot; class=&quot;headerlink&quot; title=&quot;浏览器跨域问题&quot;&gt;&lt;/a&gt;浏览器跨域问题&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;处于安全考虑 如果&lt;strong&gt;协议、域名或者端口&lt;/strong&gt;有一个不同就是跨域，Ajax 请求会失败。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;jsonp&quot;&gt;&lt;a href=&quot;#jsonp&quot; class=&quot;headerlink&quot; title=&quot;jsonp&quot;&gt;&lt;/a&gt;jsonp&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;利用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;strong&gt;没有 跨域限制&lt;/strong&gt;，&lt;strong&gt;指向&lt;/strong&gt;一个需要&lt;strong&gt;访问的地址&lt;/strong&gt;并提供一个&lt;strong&gt;回调&lt;/strong&gt;函数来&lt;strong&gt;接收数据&lt;/strong&gt;。只限于 &lt;code&gt;get&lt;/code&gt; 请求。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>new 和 instanceof</title>
    <link href="http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/"/>
    <id>http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/</id>
    <published>2020-02-06T07:06:57.491Z</published>
    <updated>2020-02-06T12:25:35.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-和-instanceof"><a href="#new-和-instanceof" class="headerlink" title="new 和 instanceof"></a>new 和 instanceof</h1><h3 id="new模拟实现"><a href="#new模拟实现" class="headerlink" title="new模拟实现"></a>new模拟实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 取第一个参数构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 把把新对象的原型链 链到 构造函数的原型对象</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定this 实现继承 ， obj可以访问到构造函数的属性</span></span><br><span class="line">  Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 到链的顶端 null 还没找到，就说明没有继承关系 </span></span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 右边的原型对象 等于左边的_PROTO_ 就说明是继承关系</span></span><br><span class="line">    <span class="keyword">if</span> (right.prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 原型链深入</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;new-和-instanceof&quot;&gt;&lt;a href=&quot;#new-和-instanceof&quot; class=&quot;headerlink&quot; title=&quot;new 和 instanceof&quot;&gt;&lt;/a&gt;new 和 instanceof&lt;/h1&gt;&lt;h3 id=&quot;new模拟实现&quot;&gt;&lt;a href=&quot;#new模拟实现&quot; class=&quot;headerlink&quot; title=&quot;new模拟实现&quot;&gt;&lt;/a&gt;new模拟实现&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myNew&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 创建一个空对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 取第一个参数构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; Con = [].shift.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 把把新对象的原型链 链到 构造函数的原型对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  obj.__proto__ = Con.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 绑定this 实现继承 ， obj可以访问到构造函数的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Con.apply(obj, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小程序云开发学习入门</title>
    <link href="http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-04T07:07:48.754Z</published>
    <updated>2020-02-06T12:43:28.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序云开发学习"><a href="#小程序云开发学习" class="headerlink" title="小程序云开发学习"></a>小程序云开发学习</h1><blockquote><p>朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己</p></blockquote><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><h3 id="开始创建"><a href="#开始创建" class="headerlink" title="开始创建"></a>开始创建</h3><p>使用小程序开发者工具，创建新项目，点击云开发</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202214400410.png" alt="image-20200202214400410"></p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>右击创建login函数</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202215513556.png" alt="image-20200202215513556"></p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>点击上传图片，在云开发控制台，可以看到</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202220032800.png" alt="image-20200202220032800"></p><h3 id="前端操作数据库"><a href="#前端操作数据库" class="headerlink" title="前端操作数据库"></a>前端操作数据库</h3><p>先在云开发里创建一个集合，然后找到databaseGuide文件，取消onAdd函数的注释，</p><p>点击左侧新增记录，就会有显示，<strong>注意数据库名称要跟函数对的上</strong></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221042328.png" alt="image-20200202221042328"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221321531.png" alt="image-20200202221321531"></p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>最后还是没有参加此次黑客马拉松，第一云开发才刚刚有做了解，并没有相关经验，并且在群里组队失败。没有队友。自己一个人两天肯定无法完成任务，所以放弃了。😵</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小程序云开发学习&quot;&gt;&lt;a href=&quot;#小程序云开发学习&quot; class=&quot;headerlink&quot; title=&quot;小程序云开发学习&quot;&gt;&lt;/a&gt;小程序云开发学习&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现call,apply,bind函数</title>
    <link href="http://yoursite.com/2020/01/23/%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/"/>
    <id>http://yoursite.com/2020/01/23/%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/</id>
    <published>2020-01-23T08:55:50.382Z</published>
    <updated>2020-01-30T04:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现call-apply-bind函数"><a href="#实现call-apply-bind函数" class="headerlink" title="实现call,apply,bind函数"></a>实现call,apply,bind函数</h1><ul><li>如果第一个参数为null ，则指向window</li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><h3 id="复习this指向"><a href="#复习this指向" class="headerlink" title="复习this指向"></a>复习this指向</h3><p><strong>this永远指向最后一个调用这个方法的对象</strong></p><p>回顾<strong>隐式绑定</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'Jason'</span>,</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Jason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure><p>记住这个用法，他们用这个实现</p><h3 id="实现call-apply"><a href="#实现call-apply" class="headerlink" title="实现call,apply"></a>实现call,apply</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (context) this指向的对象 (...args) 扩展运算 传入参数， (args)就是apply </span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变this指向如果不传的话默认上下文为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  args = args ? args : []</span><br><span class="line">  <span class="comment">// 定义一个唯一值</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">  <span class="comment">// 把这个函数的this 写到call 对象的一个属性里</span></span><br><span class="line">  context[key] = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 通过“对象.方法（参数）”，可以把this指向对象</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">  <span class="comment">// 删除对象添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> context[key]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h3><p>bind返回一个绑定好的函数，不会立即执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">    args = args ? args : []</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是new的就返回new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> fn(...args, ...newFnArgs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个apply方法</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, [...args,...newFnArgs])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现call-apply-bind函数&quot;&gt;&lt;a href=&quot;#实现call-apply-bind函数&quot; class=&quot;headerlink&quot; title=&quot;实现call,apply,bind函数&quot;&gt;&lt;/a&gt;实现call,apply,bind函数&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;如果第一个参数为null ，则指向window&lt;/li&gt;&lt;li&gt;改变了 &lt;code&gt;this&lt;/code&gt; 指向，让新的对象可以执行该函数，并能接受参数&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现promise A+</title>
    <link href="http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/"/>
    <id>http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/</id>
    <published>2020-01-20T03:56:40.251Z</published>
    <updated>2020-01-20T04:05:06.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现promise-A"><a href="#实现promise-A" class="headerlink" title="实现promise A+"></a>实现promise A+</h1><blockquote><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">promiseA+规范</a>，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释</p></blockquote><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise的三个状态，pending =&gt; resolved or =&gt; reject, 不可逆</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个fn执行器,在try中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止this变向</span></span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 设开始状态为pending</span></span><br><span class="line">  that.state = PENDING</span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 reject 中传入参数的值</span></span><br><span class="line">  that.value = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 保存then中的回调</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  <span class="comment">// 失败的回调</span></span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入的值是否为 Promise 类型</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证异步执行顺序</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 改pending状态为 resolve</span></span><br><span class="line">        that.state = RESOLVED</span><br><span class="line">        <span class="comment">// 将传入的值赋值给 value</span></span><br><span class="line">        that.value = value</span><br><span class="line">        <span class="comment">// 遍历回调执行数组</span></span><br><span class="line">        that.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同resolve</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        that.state = REJECTED</span><br><span class="line">        that.value = value</span><br><span class="line">        that.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  <span class="comment">// 解决没有传值的问题，当参数不是函数类型时，需要创建一个函数赋值给对应的参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 返回一个新的 promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 往回调数组中 push 函数</span></span><br><span class="line">      that.resolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行函数中可能 报错 ，try catch 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      that.rejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//因为穿透值的缘故，在默认的跑出一个error后，不能再用下一个的reject来接受，只能通过try，catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          <span class="comment">//递归 判断他们是否为promise对象</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    <span class="comment">// onRejected(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是null ，是 对象 或 函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="comment">// called用于判断是否已经调用过函数</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> x.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数 x 作为this指向</span></span><br><span class="line">        x.then.call(</span><br><span class="line">          x,</span><br><span class="line">          success =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果调用过 就直接返回了</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 递归调用 .then 中是否还有子 promise</span></span><br><span class="line">            resolutionProcedure(promise2, success, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 错误直接返回</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象或函数将 x 传入resolve</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现promise-A&quot;&gt;&lt;a href=&quot;#实现promise-A&quot; class=&quot;headerlink&quot; title=&quot;实现promise A+&quot;&gt;&lt;/a&gt;实现promise A+&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;promiseA+规范&lt;/a&gt;，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数组方法整理</title>
    <link href="http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-01-18T04:00:08.392Z</published>
    <updated>2020-01-19T08:15:41.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组方法整理"><a href="#数组方法整理" class="headerlink" title="数组方法整理"></a>数组方法整理</h1><blockquote><p>要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下</p></blockquote><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><blockquote><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">mdn</a></p></blockquote><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p><strong>不会返回执行结果</strong>，返回的是<code>undefined</code>，也就是说，<code>forEach()</code><strong>会修改原来的数组</strong>，中途<strong>不能</strong>用常规操作<strong>跳出循环</strong>，不支持<strong>链式</strong>操作，forEach之前可以链式</p><p>当数组中元素是<strong>值</strong>类型，forEach<strong>不会改变</strong>数组；当是<strong>引用</strong>类型，则<strong>可以改变</strong>数组</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote><p><code>map()</code> 方法创建一个<strong>新数组</strong>，其结果是该数组中的每个元素都调用一个提供的函数后<strong>返回的结果</strong>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">mdn</a></p></blockquote><p><code>map()</code>方法会得到一个<strong>新的数组</strong>并返回。速度更快，必须要有return。</p><hr><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote><p><code>filter()</code> 方法创建一个<strong>新数组</strong>，其包含<strong>通过</strong>所提供函数实现的<strong>测试</strong>的所有元素。</p></blockquote><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><blockquote><p><code>sort()</code> 方法用<a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">原地算法</a>对数组的元素进行排序，并返回数组。默认按Unicode升序</p></blockquote><p><strong>它直接改变原始数组</strong></p><p>要比较数字而非字符串，比较函数可以简单的以 <strong>a 减 b</strong>，如下的函数将会将数组<strong>升序</strong>排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]; </span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><blockquote><p><code>some()</code> 方法测试数组中是不是至少有<strong>1个元素通过</strong>了被提供的函数测试。它返回的是一个Boolean类型的值。</p></blockquote><p>只要有一个满足即返回true，之后的不再执行</p><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><blockquote><p><code>every()</code> 方法测试一个数组内的所有元素是否<strong>都</strong>能通过某个指定函数的测试。它返回一个布尔值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'cecilia'</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;</span><br><span class="line">].every(<span class="function"><span class="params">item</span> =&gt;</span> item.age &gt; <span class="number">19</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><blockquote><p><code>find()</code> 方法返回数组中<strong>满足提供的测试函数</strong>的<strong>第一个</strong>元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p></blockquote><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的<strong>第一个</strong>元素的<strong>索引</strong>。否则返回-1。</p><hr><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><blockquote><p>对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p></blockquote><ul><li>accumulator 累计器</li><li>currentValue 当前值</li><li>currentIndex 当前索引(可选)</li><li>array 数组（可选）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr );</span><br></pre></td></tr></table></figure><p>如果你打算提供一个初始值作为<code>reduce()</code>方法的第二个参数，以下是运行过程及结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue; &#125;, 10 );</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><code>callback</code></th><th align="left"><code>accumulator</code></th><th align="left"><code>currentValue</code></th><th align="left"><code>currentIndex</code></th><th align="left"><code>array</code></th><th align="left">return value</th></tr></thead><tbody><tr><td align="left">first call</td><td align="left"><code>10</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>10</code></td></tr><tr><td align="left">second call</td><td align="left"><code>10</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>11</code></td></tr><tr><td align="left">third call</td><td align="left"><code>11</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>13</code></td></tr><tr><td align="left">fourth call</td><td align="left"><code>13</code></td><td align="left"><code>3</code></td><td align="left"><code>3</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>16</code></td></tr><tr><td align="left">fifth call</td><td align="left"><code>16</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>20</code></td></tr></tbody></table><p>这种情况下<code>reduce()</code>返回的值是<code>20</code>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组方法整理&quot;&gt;&lt;a href=&quot;#数组方法整理&quot; class=&quot;headerlink&quot; title=&quot;数组方法整理&quot;&gt;&lt;/a&gt;数组方法整理&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;forEach&quot;&gt;&lt;a href=&quot;#forEach&quot; class=&quot;headerlink&quot; title=&quot;forEach()&quot;&gt;&lt;/a&gt;forEach()&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;forEach()&lt;/code&gt; 方法对数组的每个元素执行一次提供的函数。&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mdn&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何实现JS继承</title>
    <link href="http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/</id>
    <published>2020-01-16T08:45:25.951Z</published>
    <updated>2020-01-17T00:39:27.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现JS继承"><a href="#如何实现JS继承" class="headerlink" title="如何实现JS继承"></a>如何实现JS继承</h1><blockquote><p>JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。</p></blockquote><p>es6之前是不支持接口直接继承的，所以就需要手动实现继承</p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>通过这个图先熟悉一下JS内部，constructor和prototype和实例的关系</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200115231115613.png" alt="image-20200115231115613"></p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure><p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p><p>问题二: 在创建子类型(例如创建Child的实例)时,不能向父类型(例如Parent)的构造函数中传递参数.</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题一：父类中定义的方法,对子类型而言也是不可见的</p><p>问题二：方法都在构造函数中定义, 因此函数复用也就不可用了</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用<strong>原型链</strong>实现对原型<strong>属性和方法</strong>的继承,通过借用<strong>构造函数</strong>来实现对<strong>实例属性</strong>的继承.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>缺点：调用了两次父类构造函数, 造成了不必要的消耗</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p><strong><code>Object.create()</code></strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.creat(Parent.prototype)</span><br><span class="line"><span class="comment">// 将子原型对象的构造函数指回来</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>如果你希望能继承到多个对象，则可以使用混入的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="ES6-class继承"><a href="#ES6-class继承" class="headerlink" title="ES6 class继承"></a>ES6 class继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  extends 表明继承自哪个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何实现JS继承&quot;&gt;&lt;a href=&quot;#如何实现JS继承&quot; class=&quot;headerlink&quot; title=&quot;如何实现JS继承&quot;&gt;&lt;/a&gt;如何实现JS继承&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;es6之前是不支持接口直接继承的，所以就需要手动实现继承&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖节流手写</title>
    <link href="http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-01-15T13:26:06.434Z</published>
    <updated>2020-03-05T09:15:31.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><blockquote><p>这两个应用场景很多，自己手写一下，可以解决服务器压力</p></blockquote><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</strong></p><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><p>场景：用户输入停止一段时间过后再去获取数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"debounce"</span>&gt;</span>防抖按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>)</span></span><br><span class="line"><span class="actionscript">      myDebounce.addEventListener(<span class="string">'click'</span>, debounce(sayDebounce, <span class="number">1000</span>))</span></span><br><span class="line">    </span><br><span class="line">      /**</span><br><span class="line">       * 防抖功能函数</span><br><span class="line">       * fn 要防抖的功能函数</span><br><span class="line">       * delay 延迟多久，毫秒</span><br><span class="line">       **/</span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> <span class="params">(fn, delay, immediate)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包，创建一个标记用来存放定时器的返回值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeout = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 触发事件回调时执行这个 teturn function</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 每次当用户点击/输入的时候，把前一个定时器清除</span></span></span><br><span class="line">          if(timeout) clearTimeout(timeout)</span><br><span class="line">           </span><br><span class="line"><span class="actionscript">          <span class="comment">// immediate true 首次触发执行</span></span></span><br><span class="line">          if(immediate) &#123;</span><br><span class="line"><span class="actionscript">              immediate = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">              fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line"><span class="actionscript">          <span class="comment">// 创建一个新的 setTimeout，</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 这样就能保证点击按钮后的间隔内,如果用户还点击了的话，就不会执行 fn 函数</span></span></span><br><span class="line"><span class="javascript">          timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 以防需要防抖的事件this指向被改变 绑定一下this指向</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 需要防抖的事件 形参 用argument 绑进来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 定时器结束后传入 fn函数 </span></span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要防抖的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'防抖成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>减少一段时间内触发的频率。</strong></p><ul><li>方法一：设置flag 执行前flag flase 在定时器内节流时间执行后 设回 true</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"throttle"</span>&gt;</span>点击节流<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">'throttle'</span>)</span></span><br><span class="line"><span class="actionscript">      myThrottle.addEventListener(<span class="string">'click'</span>, throttle(sayThrottle, <span class="number">1000</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 节流函数体</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> <span class="params">(fn, delay)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包保存一个标记</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// flag为false 说明还在节流时间中 退出函数</span></span></span><br><span class="line">          if (!flag) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span></span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 将 flag 设置为 false，防止执行之前再被执行</span></span></span><br><span class="line"><span class="actionscript">          flag = <span class="literal">false</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="javascript">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span></span></span><br><span class="line"><span class="actionscript">            flag = <span class="literal">true</span></span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要节流的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'节流成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方法二：时间戳来判断是否已到执行时间。与上次函数执行的时间比较，大于节流时间就放行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用闭包保存，上一次执行 fn 的时间 </span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">        <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            previous = now</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖加节流"><a href="#防抖加节流" class="headerlink" title="防抖加节流"></a>防抖加节流</h3><p>节流里面包防抖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要节流处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// previous 是上一次执行 fn 的时间</span></span><br><span class="line">  <span class="comment">// timer 是定时器</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ 新增部分 start ------ </span></span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &lt; wait) &#123;</span><br><span class="line">     <span class="comment">// 如果小于，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       <span class="comment">// 定时器时间结束后执行函数 fn </span></span><br><span class="line">       <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          previous = now</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    <span class="comment">// ------ 新增部分 end ------ </span></span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 第一次执行</span></span><br><span class="line">       <span class="comment">// 或者时间间隔超出了设定的时间间隔，执行函数 fn</span></span><br><span class="line">       previous = now</span><br><span class="line">       fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn 节流执行了'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 第一次触发 scroll 执行一次 fn，每隔 1 秒后执行一次函数 fn，停止滑动 1 秒后再执行函数 fn</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterFn)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;防抖节流&quot;&gt;&lt;a href=&quot;#防抖节流&quot; class=&quot;headerlink&quot; title=&quot;防抖节流&quot;&gt;&lt;/a&gt;防抖节流&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;这两个应用场景很多，自己手写一下，可以解决服务器压力&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾佬700元装了台主流配置电脑</title>
    <link href="http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/"/>
    <id>http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/</id>
    <published>2020-01-13T08:58:09.874Z</published>
    <updated>2020-01-15T03:23:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="700元垃圾佬主机大升级"><a href="#700元垃圾佬主机大升级" class="headerlink" title="700元垃圾佬主机大升级"></a>700元垃圾佬主机大升级</h1><blockquote><p>事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。</p></blockquote><a id="more"></a><!-- build time:Sun Mar 07 2021 11:18:34 GMT+0800 (GMT+08:00) --><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>京东双十二买的酷兽 当时199 <strong>16G 2666MHz</strong> 的内存，用了个199 -15 的全品类券 ，白菜价<strong>184</strong>到手，单面2G*8颗粒组成16G容量，镁光颗粒。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/RAM2.jpg" alt="RAM2"><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/QK@@34LQC(W%7B)I@%7B%7DUIVT2.jpg" alt="img"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>最终选定一代锐龙，R5-1400 四核-八线程 基础频率3.2GHz。便宜就完事，全新带散热器淘宝只要350左右，其实9月就到这价格了，已经没有降价空间了。为了追求更便宜，买了咸鱼二手，cpu这种东西用不坏的，所以二手也稳。这块cpu也能稳定超频。唯一缺陷就是没有核心显卡，还得另外配，没显卡还是建议速龙3000G(APU).</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113114601686.png" alt="image-20200113114601686"></p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>映泰tb350-etc，全新矿板，可装六张显卡，支持AM4处理器，7相供电，很稳定，矿难清库存还剩点，230入手。唯一的缺点就是，不支持MVME接口，只能装sata固态。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120344918.png" alt="image-20200113120344918"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120905439.png" alt="image-20200113120905439"></p><h3 id="硅脂"><a href="#硅脂" class="headerlink" title="硅脂"></a>硅脂</h3><p>淘宝特价版，5元红包，1.9元入手 ，看过一个测试硅脂的话，涂X形状就行，刮刀就往一边刮。<img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122109279.png" alt="image-20200113122109279"></p><hr><h3 id="总价"><a href="#总价" class="headerlink" title="总价"></a>总价</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122402817.png" alt="image-20200113122402817"></p><h3 id="不要钱系列"><a href="#不要钱系列" class="headerlink" title="不要钱系列"></a>不要钱系列</h3><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>表哥有个闲置显卡，七彩虹GTX650，送给我了。玩玩普通网游还是无压力的。费米之后的开普勒架构很大程度上改善了高功耗、高发热问题。这里感谢翔哥。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113123036484.png" alt="image-20200113123036484"></p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>朗科480G固态，老爹闲置的固态。速度不快，但是够用，读写速度加上十秒开机。爽歪歪。</p><h4 id="机箱，机械硬盘，电源"><a href="#机箱，机械硬盘，电源" class="headerlink" title="机箱，机械硬盘，电源"></a>机箱，机械硬盘，电源</h4><p>全是祖传的</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163203557.png" alt="image-20200113163203557"></p><hr><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h3><ul><li>*<em>I tell you *</em>里面下载win10 企业版</li><li>一个大于8G U盘 ，格式化后 用 UltraISO 把系统搞到U盘</li><li>在BIOS里，设置U盘优先启动</li><li>Win 10激活 傻瓜式破解 链接: <a href="https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA</a> 提取码: 3fff （仅用于个人学习，商业用途概不负责）</li></ul><h3 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h3><p>下载的是win10企业版比较纯净。纯净到什么都没有。。。计算器，win商店都没有</p><p>win商店下载，进入商店之后edge浏览器等软件下载</p><p>链接: <a href="https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw</a> 提取码: tia9</p><p>解压：<strong>bandzip</strong></p><p>杀毒：<strong>火绒</strong>，关闭垃圾软件广告弹窗</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kbtool.cn/" target="_blank" rel="noopener">EX-DIY工具箱 卡硬工具箱 （原：卡吧工具箱）</a>，一个集合型工具，汇总了几大常用检测软件。</p><h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p>基础的超频很简单，直接在bios里面，调频率就行了。一般超个10%很稳定的，再往上超就需要调节电压了。新手建议不加电压以免烧坏。就一步一步一点点加，加到黑屏的话直接扣下主板电池，主板就会恢复出厂设置。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163312898.png" alt="image-20200113163312898"></p><h4 id="cpu超频"><a href="#cpu超频" class="headerlink" title="cpu超频"></a>cpu超频</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161954488.png" alt="image-20200113161954488"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161924106.png" alt="image-20200113161924106"></p><p>轻松超到3.7GHz，家里用就不继续超了，功耗会增加</p><h4 id="内存超频"><a href="#内存超频" class="headerlink" title="内存超频"></a>内存超频</h4><p>轻松超到2933MHz，等有钱了配个双通道32G 内存。再往上走，得调降低搬运时序了。</p><h4 id="显卡超频"><a href="#显卡超频" class="headerlink" title="显卡超频"></a>显卡超频</h4><p>NVIDIA Inspector是一款N卡专用的检测/超频软件，不但像GPU-Z一样可以检测显卡的各种信息，还能对显卡的频率、风扇转速甚至电压进行调节，十分实用。核心频率超100MHz和显存频率超200MHz，最后面的电压也不建议调，容易烧。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/L4CL2D%7D%5BJ_B5VSZ%7D%60%5BLDS45.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装机，重点是过程和玩，淘宝垃圾的过程，装机的过程。挺好玩的。总的来说这次700元装出3000元的逼了。</p><hr><h3 id="番外篇：晒好价外设"><a href="#番外篇：晒好价外设" class="headerlink" title="番外篇：晒好价外设"></a>番外篇：晒好价外设</h3><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>酷冷至尊 k370 红轴，此款键盘的特点是 cherry原厂红轴，全键无冲，BPT键帽不易打油，有卫星轴，很重底层有钢板，预留灯位，想想一个红轴的单价都是2块，算算光轴的钱就超200了，199内还要啥自行车。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113164616416.png" alt="image-20200113164616416"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113165124122.png" alt="image-20200113165124122"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;a href=&quot;#700元垃圾佬主机大升级&quot; class=&quot;headerlink&quot; title=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;/a&gt;700元垃圾佬主机大升级&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
