<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  <subtitle>佳宸学习和分享笔记的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-21T01:07:38.687Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴佳宸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯的十轮前端面试总结</title>
    <link href="http://yoursite.com/2020/04/21/%E8%85%BE%E8%AE%AF%E5%8D%81%E8%BD%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/21/%E8%85%BE%E8%AE%AF%E5%8D%81%E8%BD%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-21T00:43:46.715Z</published>
    <updated>2020-04-21T01:07:38.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="腾讯的十轮前端面试总结"><a href="#腾讯的十轮前端面试总结" class="headerlink" title="腾讯的十轮前端面试总结"></a>腾讯的十轮前端面试总结</h1><blockquote><p>应聘的岗位是前端开发，面试流程持续一个多月，挂来挂去，加起来面了十轮，腾讯的好处就是，面试评价和简历还行就有其他部门捞起的机会，感谢</p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:05 GMT+0800 (GMT+08:00) --><p><strong>总的来说一般 初试考察前端知识覆盖的广度，复试根据项目或者知识点，考察对知识的理解程度、深度。</strong></p><hr><p>轮数太多，有重复题，写起来比较乱，就按知识点划分来说题目把，时间长脑子也记不住了。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li>html语义化</li><li>input的type属性（说的越全越好）</li><li>canvas</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><blockquote><p>推荐书籍《CSS揭秘》《CSS世界》。API的话直接查MDN还快些，权威指南啥的就没必要买了</p><ul><li>盒模型</li><li>rem 和 em区别，rem的缺陷</li><li>css三有哪些新特新（说的越全越好）</li><li>css实现三角形</li><li>选择器权重</li><li>css动画</li><li>css有哪些定位</li><li>绝对定位，相对定位，fixed定位…</li><li>水平垂直居中（越多越好）</li><li>预处理器 less,sass,styus 啥的</li><li>css的性能优化</li><li>重绘回流</li><li>媒体查询，响应式布局方案</li><li>栅格化布局</li><li>flex布局，（grid布局，实践得比较少，好多忘了，面ctve的时候说了，自己打脸😂）</li><li>行内元素，块级元素，行内块元素区别</li></ul></blockquote><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><blockquote><p>推荐书籍：《JavaScript 高级程序设计》经典必读，重点前8章，有点年代了。《JS忍者秘籍》寒假看的，爱不释手。《JavaScript设计模式》腾讯alloyteam团队出的，没看完，疫情这么久，后悔没带回家。《你不知道的 JavaScript》都说好，但是我觉得翻译得有点生涩，可能是我水平不够把。《深入理解 ES6》高程原作者写的，《ES6 标准入门》阮一峰写的，API的话直接查MDN还快些，犀牛书就不必要买了，买了当字典用。</p></blockquote><ul><li>代码规范</li><li>事件流、事件委托、阻止事件冒泡</li><li>es6新特性（会多少说多少，越多越详细越好）</li><li>var,let,const赋值的区别，const原理</li><li>块级作用域</li><li>forEach，for in, for of, map，等遍历方法的区别，各自哪些适用</li><li>es6对比以前的优势</li><li>promise实现（最好要会手写）</li><li>async await 原理</li><li>怎么解决异步回调</li><li>set map</li><li>map WeakMap区别</li><li>common.js amd cmd</li><li>common.js和ES6中模块引入的区别</li><li>基本数据类型与引用数据类型，堆、栈区别联系</li><li>null,undefine区别</li><li>对引用类型深层对象的一个比较（考察递归）</li><li>怎么判断数组类型 instansof判断数组的缺陷（直接说它的实现原理）typeof判断数组的缺陷</li><li>闭包，概念，原理，缺点，实践</li><li>作用域，作用域链</li><li>原型，原型链（理解其中的关系）</li><li>继承，各种方式的原理，寄生组合继承（要会手写实现，考察对原型的理解）</li><li>this的理解，怎么指向，隐士绑定，显示绑定，new…</li><li>call,bind,apply原理实现（理解原理然后要会手敲函数实现）</li><li>构造函数方法 new的实现</li><li>setTimeout,requestAnimationFrame</li><li>JS执行机制</li><li>异步宏任务，微任务（要清晰知道浏览器的事件流）异步代码的执行顺序，事件循环</li><li>哪些宏任务，哪些是微任务具体</li><li>深克隆，钱克隆区别</li><li>手写实现深克隆（碰引用类型递归或者树的遍历）</li><li>== 和===的区别</li><li>+、== 类型转换规则，(toPrimitive过程)，引用类型转数字，转字符串规则</li><li>||和&amp;&amp; （条件判断和逻辑判断有区别，当时数美科技题）</li><li>DOM文档对象模型</li><li>BOM浏览器对象模型，有哪些属性方法（用的少，容易忘）</li><li>ajax原理，手写实现</li><li>fetch原理，与ajax区别，优点</li><li>TypeScripte相对于JavaScript的优势</li><li>垃圾回收机制</li><li>防抖节流 (要会手写，以及合在一起，这个没考我，但是有在项目优化中说)</li></ul><h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><blockquote><p>官网文档的API全都要熟知，整个原理实现要会,推荐小册《剖析 Vue.js 内部运行机制》染陌大哥写的。源码看过最好，不强求。《vue技术内幕》前面写得更详细，逐行解析，后面的看《VUE技术揭秘》黄奕老师写的，有配套视频</p></blockquote><ul><li>生命周期</li><li>mounted 和 create具体什么时候用这个钩子，区别，</li><li>用了keep-alive的activate和deactivated</li><li>mvvm设计模式，mvc设计模式理解，区别</li><li>vuex原理，state,mutations,getters,action</li><li>vue-router路由原理，history,hash</li><li>compile模板编译流程，怎么转为的render函数</li><li>响应式原理（基于defineProperty这个方法实现）</li><li>vue3的proxy相对于defineProperty有哪些优化</li><li>依赖收集，动态更新过程</li><li>v-model 原理</li><li>Virtual DOM优势,异步更新流程</li><li>数据更新的优化diff算法patch过程,patchVnode，updateChildren 啥的，熟知流程</li><li>v-if和v-show区别</li><li>组件间的传值，通信（说的越多越好）</li><li>computed和watch区别</li><li>为啥v-for要加：key，为什么不推荐用index做为key</li><li>vue中遇到哪些难点，坑</li><li>element组件遇到过哪些bug</li><li>vue和小程序区别</li><li>观察者模式，发布订阅模式</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><blockquote><p>网络这块，只看过《图解HTTP》,还有上课学的</p><ul><li>OSI7层模型，会分别说有哪些协议在哪层</li><li>从浏览器输入网址到渲染完成的过程</li><li>DNS域名协议，查询过程，原理</li><li>http和https区别</li><li>http2新特新(越详细越好)</li><li>长连接keep-alive，原理，优势</li><li>多路复用</li><li>头部压缩</li><li>tls/ssl加密过程，详细讲清楚</li><li>中间人攻击</li><li>jwt</li><li>cookie session</li><li>sso单点登录、浏览器鉴权、多个站点共享登陆</li><li>缓存，强缓存（Expires、cache-control）协商缓存（Last-Modified 和 If-Modified-Since、Etag 和 If-None-Match，ctve就是被这个问倒了，后面看了一堆文章）</li><li>设置cookie</li><li>浏览器同源策略</li><li>跨域（方法越多越好），自己怎么实现解决</li><li>cors的配置项</li><li>TCP三次握手，四次挥手</li><li>为什么要三次握手，中间断了会怎样</li><li>TCP UDP区别</li><li>各种状态码 (要详细单个讲)<br>1××开头 - 信息提示<br>2××开头 - 请求成功<br>3××开头 - 请求被重定向<br>4××开头 - 请求错误<br>5××开头 - 服务器错误</li><li>200除了返回成功是这个，还有吗（协商缓存啥的）</li><li>详细说一下 304 缓存啥的 etag，If-Modified-Since 浏览器缓存机制</li><li>get post区别，何时使用</li><li>小程序的登陆流程，鉴权</li></ul></blockquote><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><ul><li>各种攻击（主要是预防的方案）</li><li>XSS概念，具体哪些攻击分类（存储型，反射型，DOM 型 ），解决方案</li><li>SCRF概念，怎么避免，解决方案</li><li>同源检测，Token，双Cookie验证</li><li>除了XSS,SCRF还有哪些攻击</li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><blockquote><p>只照着文档配置过，平常一直用的脚手架</p><ul><li>webpack打包原理</li><li>除了webpack，还用过哪些打包软件</li><li>plugin 和 loader 原理区别</li><li>有没有设计过通用 脚手架</li><li>babel转换es5原理</li></ul></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><blockquote><p>主要自己实践，理论空说没用</p><ul><li>图片懒加载</li><li>SSR</li><li>浏览器缓存</li><li>压缩</li><li>cdn原理</li><li>CNAME</li><li>监控埋点</li><li>分包加载</li><li>防抖节流</li></ul></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote><p>推荐刷 leetcode探索里基础算法，《剑指offer》，不一定要刷难题，但是常见题简单题一定要多手写几遍。写出来的时间复杂度高，面试官一样DISS，学习最优解。手写的各种JSapi，二叉树，链表，数组，是重点。之前有些烦各种api记不住，刷题刷多了，数组字符串那些方法就自然记住了</p><ul><li>各种排序（主要是快速排序和归并排序）区别，时间复杂度</li><li>最大最小堆</li><li>找一堆数中最大的几个，时间复杂度要优，数据量巨大</li><li>递归，迭代思维</li><li>正则</li><li>数组拍平</li><li>数组去重</li><li>深拷贝</li><li>JS怎么实现二叉树</li><li>二叉树前中后遍历，广度深度（递归，迭代）</li><li>删除一个深层对象中的空值</li><li>寻找质数</li><li>栈和队列的区别</li><li>柯里化</li></ul></blockquote><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ul><li>遇到的难点（重点说明解决过程）</li><li>业务中性能优化</li><li>用Vue遇到过难以解决的问题</li></ul><h3 id="git版本控制"><a href="#git版本控制" class="headerlink" title="git版本控制"></a>git版本控制</h3><ul><li>git原理</li><li>公司使用git流程</li><li>git规范</li></ul><hr><h5 id="好多细节记不起来了，就不写单个的了"><a href="#好多细节记不起来了，就不写单个的了" class="headerlink" title="好多细节记不起来了，就不写单个的了"></a>好多细节记不起来了，就不写单个的了</h5><h2 id="应用宝商业化"><a href="#应用宝商业化" class="headerlink" title="应用宝商业化"></a>应用宝商业化</h2><p>初试一面（过）<br>复试二面（过）<br>复试三面（过）<br>GM四面（挂）</p><blockquote><p>自我感觉还行，但就是挂了，大老板看不上我？还是有更合适人选成了备胎？总的来说就是自己能力不突出，不够优秀。挂你是本分，给过是情分</p></blockquote><h2 id="腾讯云CDN"><a href="#腾讯云CDN" class="headerlink" title="腾讯云CDN"></a>腾讯云CDN</h2><h3 id="初试一面（过）"><a href="#初试一面（过）" class="headerlink" title="初试一面（过）"></a>初试一面（过）</h3><ul><li>说一下前面挂了，自己哪些知识不足</li><li>我说了性能优化，node方面，埋点。。。</li><li>二分查找时间复杂度</li><li>归并排序，快速排序</li><li><em>打电话打了一半，上牛客手写代码*</em></li><li>深拷贝</li><li>字符串中连续重复字符（正则写出来了，match方法忘了，就只能换个思路用循环）</li><li>把一个深对象中空属性删掉 （递归，删除对象属性 delete方法忘了，只能创一个新的空对象，赋值）</li></ul><h3 id="复试二面（挂）"><a href="#复试二面（挂）" class="headerlink" title="复试二面（挂）"></a>复试二面（挂）</h3><blockquote><p>我说了node不太了解，大半年没碰了，简历也没写，就一个大半年前的项目有用一点点。但是一直在问的服务端的问题，为什么要这样虐待我🙃</p></blockquote><p>先是问问人生，实习时间，嘘寒问暖，然后开始正式面试，从我的项目博客入手</p><ul><li>node的evenloop</li><li>io流</li><li>文件读取。</li><li>说下node的模块，会多少说多少。各个模块干什么的？</li><li>说然后抓住网络模块，要我说一下原生建立连接过程。</li><li>说下common.js原理。</li><li>为什么服务器用竞争对手阿里云不用腾讯云的？不想来是吗？我们这边hc比较紧。</li><li>说一下这个项目的数据库架构。</li><li>为什么要选择mongodb，为什么不用mysql</li><li>你后端怎么部署的，</li><li>说下这个项目整个框架的解析，接口啊，数据库啊这些东西。说着说着，我就劲量转到项目前端的vue，他就打停了</li><li>你这个项目用koa是吧？</li><li>为什么不用一个express用koa？说一下他们的区别。</li><li>我说了个洋葱圈中间件。深挖说下洋葱圈模型原理。😥</li><li>如果用户量激增等情况，node瘫痪你怎么解决</li><li>mongo宕机怎么解决？</li><li>nginx怎么配置的？配置细节</li></ul><p>最后再手写两个算法</p><ul><li>深拷贝 （前面对我不会的问题连环轰炸，导致整个人头发蒙，一面才面过的，思路却老是断）</li><li>寻找质数（直接问的我博客写过的，但是博客记录的是最优解，我面试记不起来，写的时间复杂度（n²），搬起石头砸自己的脚😭）</li></ul><h2 id="QQ信息流"><a href="#QQ信息流" class="headerlink" title="QQ信息流"></a>QQ信息流</h2><h4 id="初试一面-（？）"><a href="#初试一面-（？）" class="headerlink" title="初试一面 （？）"></a>初试一面 （？）</h4><p>一面是IEG的人，不知道是挂了，还是转岗，还是交叉面试</p><h4 id="复试二面-（过）"><a href="#复试二面-（过）" class="headerlink" title="复试二面 （过）"></a>复试二面 （过）</h4><h3 id="面委会三面-（过）-两个人一起面面我"><a href="#面委会三面-（过）-两个人一起面面我" class="headerlink" title="面委会三面 （过） 两个人一起面面我"></a>面委会三面 （过） 两个人一起面面我</h3><ul><li>自我介绍</li><li>Js看过哪些书</li><li>问学校专业课学了哪些前端相关的</li><li>我项目中的时钟倒计时圆形进度条实现</li><li>setTimeout与requestAnimationFrame 区别</li><li>动画延迟，性能</li><li>内存泄漏，怎么解决</li><li>重绘回流，具体哪些熟悉导致重绘，哪些属性回流</li><li>CSS动画，具体实现</li><li>Js动画和Css动画区别</li><li>canvas动画</li><li>canvas与html的关系区别</li><li>MVVM设计模式思维</li><li>vue与原生JS区别</li><li>小程序与VUE区别</li><li>代码规范</li><li>对未来三年自己的一个技术规划（不要说工程化啥的成熟的技术，说一写探索的技术）</li><li>说一个你觉得优秀的产品</li><li>用户量很大，他担心我的代码质量（从实习期的代码规范checklist，说到自己有坚持做的算法逻辑，巴拉说了一堆，消除他的担心）</li></ul><h3 id="HR四面"><a href="#HR四面" class="headerlink" title="HR四面"></a>HR四面</h3><ul><li>自我介绍（给hr做介绍的话，学习经历努力过程，等非技术相关的，偶尔带两个技术名词，不要一个劲说技术细节）</li><li>说说你的社区商城的项目驱动</li><li>说说你的实习过程中的收获</li><li>说说你的工作室</li><li>说说你遇到的最困难的一个地方（不要只说困难，一硬要说解决的过程，如何克服的）</li><li>来腾讯的目的（把自己说感动，就能感动HR）</li><li>实习时间（要往久里说，越久越稳）</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>面试必问题：自我介绍，可以先用心写个草稿，面试就不会说的没思路逻辑了</li><li>精通一个细分领域才能有深度，学的浅的东西，自己简历就不要写了，面试被问，直接说：“不会，但是以后会学”，以免自己挖坑</li><li>积累源于平时，一些简单的算法思维，长时间刷才有的深刻，尤其是面试手写，不能查资料，有紧张减少一半思路，那就要滚瓜烂熟了</li><li>一步一个脚印，凭实力说话，不要不懂装懂，虚心学习就是了</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;腾讯的十轮前端面试总结&quot;&gt;&lt;a href=&quot;#腾讯的十轮前端面试总结&quot; class=&quot;headerlink&quot; title=&quot;腾讯的十轮前端面试总结&quot;&gt;&lt;/a&gt;腾讯的十轮前端面试总结&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;应聘的岗位是前端开发，面试流程持续一个多月，挂来挂去，加起来面了十轮，腾讯的好处就是，面试评价和简历还行就有其他部门捞起的机会，感谢&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>canvas学习笔记</title>
    <link href="http://yoursite.com/2020/04/04/canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/04/canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-04T01:20:09.560Z</published>
    <updated>2020-04-04T01:24:38.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><h3 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h3><h4 id="绘制弧-曲线"><a href="#绘制弧-曲线" class="headerlink" title="绘制弧/曲线"></a>绘制弧/曲线</h4><p><code>arc()</code> 方法创建弧/曲线（用于创建圆或部分圆）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arc(x,y,r,sAngle,eAngle,counterclockwise);</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><ul><li>x：圆心的 x 坐标</li><li>y：圆心的 y 坐标</li><li>r：圆的半径</li><li>sAngle：起始角，以弧度计（弧的圆形的三点钟位置是 0 度）</li><li>eAngle：结束角，以弧度计</li><li>counterclockwise：可选。规定应该逆时针还是顺时针绘图。false 为顺时针，true 为逆时针</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/11/21/15fdf0929fbe015f?imageslim" alt="图片来自 w3cschool"></p><h4 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h4><p><code>drawImage()</code> 向画布上绘制图像、画布或视频</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);</span><br></pre></td></tr></table></figure><ul><li><code>img</code>：规定要使用的图像、画布或视频</li><li><code>sx</code>：可选。开始剪切的 x 坐标位置</li><li><code>sy</code>：可选。开始剪切的 y 坐标位置</li><li><code>swidth</code>：可选。被剪切图像的宽度</li><li><code>sheight</code>：可选。被剪切图像的高度</li><li><code>x</code>：在画布上放置图像的 x 坐标位置</li><li><code>y</code>：在画布上放置图像的 y 坐标位置</li><li><code>width</code>：可选。要使用的图像的宽度（伸展或缩小图像）</li><li><code>height</code>：可选。要使用的图像的高度（伸展或缩小图像）</li></ul><h4 id="基础方法练习"><a href="#基础方法练习" class="headerlink" title="基础方法练习"></a>基础方法练习</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/canvas/image-20200330144638329.png" alt="image-20200330144638329"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        .canvas &#123;</span></span><br><span class="line"><span class="regexp">            background: #000;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="draw"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;canvas class="canvas"&gt;&lt;/</span>canvas&gt;</span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    let canvas = document.querySelectorAll("canvas");</span></span><br><span class="line"><span class="regexp">    console.log(canvas)</span></span><br><span class="line"><span class="regexp">    let context0 = canvas[0].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context1 = canvas[1].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context2 = canvas[2].getContext("2d");</span></span><br><span class="line"><span class="regexp">    let context3 = canvas[3].getContext("2d");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 画布长宽 默认宽300 高150</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ var cx = canvas.width = 400;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ var cy = canvas.height = 400;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画一个圆里面填满</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context0.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 坐标（100，75），半径，起始角3点钟方向，转Math.PI(180)度 ，false逆时针 ,true顺时针</span></span><br><span class="line"><span class="regexp">    context0.arc(100, 75, 50, 0, Math.PI * 2, false);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 填充颜色</span></span><br><span class="line"><span class="regexp">    context0.fillStyle = 'rgb(255,255,255)';</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 设置阴影模糊级别</span></span><br><span class="line"><span class="regexp">    context0.shadowBlur = 50;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 阴影颜色</span></span><br><span class="line"><span class="regexp">    context0.shadowColor = 'red';</span></span><br><span class="line"><span class="regexp">    context0.fill();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画一个<span class="number">1</span>/<span class="number">4</span>圆，连线闭合</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context1.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 坐标（100，75），半径，起始角3点钟方向，顺时针到 Math.PI(180)度结束这个位置 ，画线 false逆时针 ,true顺时针</span></span><br><span class="line"><span class="regexp">    context1.arc(100, 75, 50, 0, Math.PI* 1.5, true);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 形成闭合路径</span></span><br><span class="line"><span class="regexp">    context1.closePath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 描边 </span></span><br><span class="line"><span class="regexp">    context1.strokeStyle="white";</span></span><br><span class="line"><span class="regexp">    context1.stroke();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画几条连续线</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context2.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 把路径移动到画布中的指定点，不创建线条</span></span><br><span class="line"><span class="regexp">    context2.moveTo(50,50);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 添加一个新点，然后在画布中创建从该点到最后指定点的线条</span></span><br><span class="line"><span class="regexp">    context2.lineTo(100,100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 不用moveTo 连续用lineTo也可</span></span><br><span class="line"><span class="regexp">    context2.lineTo(200, 100);</span></span><br><span class="line"><span class="regexp">    context2.lineTo(100,50);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 线条宽度</span></span><br><span class="line"><span class="regexp">    context2.lineWidth = 10;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 起始和终点线圆角</span></span><br><span class="line"><span class="regexp">    context2.lineCap = 'round'</span></span><br><span class="line"><span class="regexp">    context2.strokeStyle = '#fff';</span></span><br><span class="line"><span class="regexp">    context2.stroke();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span>*</span><br><span class="line">    * 画矩形</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    context3.beginPath();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 设置渐变 （开始x, 开始y, 结束x， 结束y）</span></span><br><span class="line"><span class="regexp">    let grd = context3.createLinearGradient(20,10,100,100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ grd.addColorStop(0,'pink');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ grd.addColorStop(1,'white');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 初始位置0， 结束位置1</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0,'rgb(255, 0, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.2,'rgb(255, 165, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.3,'rgb(255, 255, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.5,'rgb(0, 255, 0)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.7,'rgb(0, 127, 255)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(0.9,'rgb(0, 0, 255)');</span></span><br><span class="line"><span class="regexp">    grd.addColorStop(1,'rgb(139, 0, 255)');</span></span><br><span class="line"><span class="regexp">    context3.fillStyle = grd;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 实心矩形 参数：左上的角位置(x, y, 宽， 高)</span></span><br><span class="line"><span class="regexp">    context3.fillRect(20, 10, 100, 100);</span></span><br><span class="line"><span class="regexp">    context3.strokeStyle = '#fff';</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 空心矩形</span></span><br><span class="line"><span class="regexp">    context3.strokeRect(130, 10, 100, 100);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 旋转轴心在 画布的 左上角</span></span><br><span class="line"><span class="regexp">    context3.rotate(5*Math.PI/</span><span class="number">180</span>);</span><br><span class="line">    context3.strokeRect(<span class="number">130</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 线条的长宽 和坐标的位置都被放大了</span></span><br><span class="line">    context3.scale(<span class="number">1.2</span>,<span class="number">1.2</span>);</span><br><span class="line">    context3.strokeRect(<span class="number">130</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><hr><p>好看渐变色网站 <a href="https://uigradients.com/#MangoPulp" target="_blank" rel="noopener">uigradients</a>用来做背景</p><h3 id="canvas随机粒子移动-鼠标移动效果"><a href="#canvas随机粒子移动-鼠标移动效果" class="headerlink" title="canvas随机粒子移动+鼠标移动效果"></a>canvas随机粒子移动+鼠标移动效果</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/canvas/particle.gif" alt="particle"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html, body &#123;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">            overflow: hidden;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">            height: 100%;</span></span><br><span class="line"><span class="regexp">            cursor: none;</span></span><br><span class="line"><span class="regexp">            background: black;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;canvas id="canvas"&gt;&lt;/</span>canvas&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>),</span><br><span class="line">        content = ctx.getContext(<span class="string">'2d'</span>),</span><br><span class="line">        round = [],</span><br><span class="line">        WIDTH = <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">        HEIGHT = <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">        <span class="comment">// 粒子个数</span></span><br><span class="line">        initRoundPopulation = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">let</span>  round_arr = [],</span><br><span class="line">        para = &#123;</span><br><span class="line">            num: <span class="number">100</span>,</span><br><span class="line">            color: <span class="literal">false</span>,    <span class="comment">//  颜色  如果是false 则是随机渐变颜色</span></span><br><span class="line">            r: <span class="number">0.9</span>,</span><br><span class="line">            o: <span class="number">0.09</span>,         <span class="comment">//  判断圆消失的条件，数值越大，消失的越快</span></span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        color,</span><br><span class="line">        color2</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 满屏</span></span><br><span class="line">    ctx.width = WIDTH;</span><br><span class="line">    ctx.height = HEIGHT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断参数中是否设置了 color，如果设置了 color，就使用该值、</span></span><br><span class="line">    <span class="comment">// 如果参数中的 color 为 false，那么就使用随机的颜色</span></span><br><span class="line">    <span class="keyword">if</span> (para.color) &#123;</span><br><span class="line">        color2 = para.color;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="built_in">Math</span>.random() * <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        mouseX = event.clientX;</span><br><span class="line">        mouseY = event.clientY;</span><br><span class="line"></span><br><span class="line">        round_arr.push(&#123;</span><br><span class="line">            mouseX: mouseX,</span><br><span class="line">            mouseY: mouseY,</span><br><span class="line">            r: para.r,</span><br><span class="line">            o: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 随机圆的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Round_item</span>(<span class="params">index, x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="comment">// 1-3的随机半径</span></span><br><span class="line">        <span class="keyword">this</span>.r = <span class="built_in">Math</span>.random() * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 随机透明度 0.05-0.55</span></span><br><span class="line">        <span class="keyword">var</span> alpha = (<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>) / <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"rgba(255,255,255,"</span> + alpha + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Round_item.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        content.shadowBlur = <span class="keyword">this</span>.r * <span class="number">2</span>;</span><br><span class="line">        content.beginPath();</span><br><span class="line">        content.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">        content.closePath();</span><br><span class="line">        content.fill();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.clearRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> round) &#123;</span><br><span class="line">            round[i].move();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        requestAnimationFrame(animate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动粒子的y坐标，向上运动</span></span><br><span class="line">    Round_item.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y -= <span class="number">0.15</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.y &lt;= <span class="number">-10</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.y = HEIGHT + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; initRoundPopulation; i++) &#123;</span><br><span class="line">            round[i] = <span class="keyword">new</span> Round_item(i, <span class="built_in">Math</span>.random() * WIDTH, <span class="built_in">Math</span>.random() * HEIGHT);</span><br><span class="line">            round[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">        animate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;canvas&quot;&gt;&lt;a href=&quot;#canvas&quot; class=&quot;headerlink&quot; title=&quot;canvas&quot;&gt;&lt;/a&gt;canvas&lt;/h1&gt;&lt;h3 id=&quot;基础方法&quot;&gt;&lt;a href=&quot;#基础方法&quot; class=&quot;headerlink&quot; title=&quot;基础方法&quot;&gt;&lt;/a&gt;基础方法&lt;/h3&gt;&lt;h4 id=&quot;绘制弧-曲线&quot;&gt;&lt;a href=&quot;#绘制弧-曲线&quot; class=&quot;headerlink&quot; title=&quot;绘制弧/曲线&quot;&gt;&lt;/a&gt;绘制弧/曲线&lt;/h4&gt;&lt;p&gt;&lt;code&gt;arc()&lt;/code&gt; 方法创建弧/曲线（用于创建圆或部分圆）。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;context.arc(x,y,r,sAngle,eAngle,counterclockwise);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>设计问题，数学 leetcode</title>
    <link href="http://yoursite.com/2020/03/27/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-leetcode/"/>
    <id>http://yoursite.com/2020/03/27/%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-leetcode/</id>
    <published>2020-03-27T04:25:56.090Z</published>
    <updated>2020-03-27T04:24:20.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="随机数组"><a href="#随机数组" class="headerlink" title="随机数组"></a>随机数组</h3><h4 id="Shuffle-an-Array"><a href="#Shuffle-an-Array" class="headerlink" title="Shuffle an Array"></a>Shuffle an Array</h4><p>打乱一个没有重复元素的数组。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 以数字集合 1, 2 和 3 初始化数组。</span><br><span class="line">int[] nums = &#123;1,2,3&#125;;</span><br><span class="line">Solution solution = new Solution(nums);</span><br><span class="line"></span><br><span class="line">// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。</span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line">// 重设数组到它的初始状态[1,2,3]。</span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line">// 随机返回数组[1,2,3]打乱后的结果。</span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Solution = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the array to its original configuration and return it.</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Solution.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nums</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a random shuffling of the array.</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Solution.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 并不是真正随机,sort小于10个是插入排序，大于是快速排序</span></span><br><span class="line">    <span class="comment">// nums.sort(()=&gt;Math.random() - 0.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展运算符 深拷贝 ，直接赋值是赋引用地址，会把原数组改变</span></span><br><span class="line">    <span class="keyword">let</span> arr = [...this.nums]</span><br><span class="line">    <span class="keyword">let</span> len = <span class="keyword">this</span>.nums.length</span><br><span class="line">    <span class="keyword">let</span> j ,x</span><br><span class="line">    <span class="comment">// 取得随机位置，与当前位置交换</span></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len--))</span><br><span class="line">        <span class="comment">// [arr[i], arr[random]] = [arr[random], arr[i]]  </span></span><br><span class="line">        <span class="comment">// 结构赋值leetcode用不了有点奇怪</span></span><br><span class="line">        t = arr[len]</span><br><span class="line">        arr[len] = arr[j]</span><br><span class="line">        arr[j] = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new Solution(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.reset()</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.shuffle()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a>Fizz Buzz</h3><p>写一个程序，输出从 1 到 <em>n</em> 数字的字符串表示。</p><ol><li><p>如果 <em>n</em> 是3的倍数，输出“Fizz”；</p></li><li><p>如果 <em>n</em> 是5的倍数，输出“Buzz”；</p></li><li><p>如果 <em>n</em> 同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><p>解：除余数，然后字符串拼接，如果不是就直接加数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fizzBuzz = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="string">''</span></span><br><span class="line">        x += i % <span class="number">3</span> ? <span class="string">''</span> : <span class="string">'Fizz'</span></span><br><span class="line">        x += i % <span class="number">5</span> ? <span class="string">''</span> : <span class="string">'Buzz'</span></span><br><span class="line">        <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">            x += i</span><br><span class="line">        &#125;</span><br><span class="line">        str.push(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h3><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p>解：厄拉多塞筛法，把当前循环数的倍数全都标记，没有标记的就是质数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr[i]) &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 从两倍开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i * <span class="number">2</span>; j &lt; n; j += i) &#123;</span><br><span class="line">                arr[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3的幂"><a href="#3的幂" class="headerlink" title="3的幂"></a>3的幂</h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><p>解：可以使用3进制转换</p><ul><li>n = 1 时 ==&gt; 转3进制数为 1</li><li>n = 3 时 ==&gt; 转3进制数为 10</li><li>n = 9 时 ==&gt; 转3进制数为 100</li><li>n = 27 时 ==&gt; 转3进制数为 1000</li></ul><p>得出结论，3的幂次方的3进制都是1开头的，后面都是0</p><p>进制转换：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toString" target="_blank" rel="noopener">Number.prototype.toString()</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfThree = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配1开头的 0有0个或以上 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^10*$/</span>.test(n.toString(<span class="number">3</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>解：先把罗马对应的数值存map，然后与后一个比较，如果小于后一个就是减，大于就是加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> romaMap = &#123;</span><br><span class="line">        <span class="string">"I"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"V"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"X"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">"L"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">"C"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">"D"</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">"M"</span>: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        romaMap[s[i]] &lt; romaMap[s[i+<span class="number">1</span>]] ? sum -= romaMap[s[i]] : sum += romaMap[s[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;随机数组&quot;&gt;&lt;a href=&quot;#随机数组&quot; class=&quot;headerlink&quot; title=&quot;随机数组&quot;&gt;&lt;/a&gt;随机数组&lt;/h3&gt;&lt;h4 id=&quot;Shuffle-an-Array&quot;&gt;&lt;a href=&quot;#Shuffle-an-Array&quot; class=&quot;headerlink&quot; title=&quot;Shuffle an Array&quot;&gt;&lt;/a&gt;Shuffle an Array&lt;/h4&gt;&lt;p&gt;打乱一个没有重复元素的数组。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 以数字集合 1, 2 和 3 初始化数组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int[] nums = &amp;#123;1,2,3&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Solution solution = new Solution(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.shuffle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 重设数组到它的初始状态[1,2,3]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.reset();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 随机返回数组[1,2,3]打乱后的结果。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;solution.shuffle();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划leetcode</title>
    <link href="http://yoursite.com/2020/03/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-16T02:19:31.912Z</published>
    <updated>2020-03-16T02:19:39.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过递推，得到爬楼梯是个斐波那契数列</span></span><br><span class="line"><span class="comment">// 所以使用迭代</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fibo = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fibo [i] = fibo[i<span class="number">-1</span>] + fibo[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibo[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最大利润差</span></span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 最小价格</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minPrice&gt;prices[i]) &#123;</span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前价格-最小价格 比较最大利润差</span></span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, prices[i]-minPrice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="comment">// 如果之前加的和大于0 则把当前值加进来</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就把之前的丢弃，把当前值赋进来</span></span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把最大的比出来，也可以防止后面数是负数</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p>解：这种题最好拿纸比划比划，光脑子想，头有点裂开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 前一个最大值</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 当前最大值 </span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur</span><br><span class="line">        <span class="comment">// 当前最大值 和 前一个最大值+遍历值做比较</span></span><br><span class="line">        cur = <span class="built_in">Math</span>.max(cur, pre+item)</span><br><span class="line">        pre = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。&lt;/p&gt;&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS中的正则</title>
    <link href="http://yoursite.com/2020/03/01/%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2020/03/01/%E6%AD%A3%E5%88%99/</id>
    <published>2020-03-01T09:31:21.211Z</published>
    <updated>2020-03-16T04:11:11.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>RegExp.prototype.exec</td><td>一个在字符串中执行查找匹配的RegExp方法，它返回一个<strong>数组</strong>（未匹配到则返回 null）。</td></tr><tr><td>RegExp.prototype.test</td><td>一个在字符串中测试是否匹配的RegExp方法，它<strong>返回 true 或 false</strong>。</td></tr><tr><td>String.prototype.match</td><td>一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td>String.prototype.matchAll</td><td>一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td>String.prototype.search</td><td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td>String.prototype.replace</td><td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td>String.prototype.split</td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><h3 id="符号表格"><a href="#符号表格" class="headerlink" title="符号表格"></a>符号表格</h3><table><thead><tr><th>特殊字符</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>换行符</td><td>\n</td><td><strong>n</strong>ew line</td></tr><tr><td>换页符</td><td>\f</td><td><strong>f</strong>orm feed</td></tr><tr><td>回车符</td><td>\r</td><td><strong>r</strong>eturn</td></tr><tr><td>空白符</td><td>\s</td><td><strong>s</strong>pace</td></tr><tr><td>非空白符</td><td>\S</td><td></td></tr><tr><td>制表符</td><td>\t</td><td><strong>t</strong>ab</td></tr><tr><td>垂直制表符</td><td>\v</td><td><strong>v</strong>ertical tab</td></tr><tr><td>单词边界</td><td>\b</td><td><strong>b</strong>oundary</td></tr><tr><td>非单词边界</td><td>\B</td><td></td></tr><tr><td>回退符</td><td>[\b]</td><td><strong>b</strong>ackspace,之所以使用[]符号是避免和\b重复</td></tr><tr><td>除了换行符之外的任何字符</td><td>.</td><td>句号,除了句子结束符</td></tr><tr><td>单个数字, [0-9]</td><td>\d</td><td><strong>d</strong>igit</td></tr><tr><td>除了[0-9]</td><td>\D</td><td><strong>not</strong> <strong>d</strong>igit</td></tr><tr><td>包括下划线在内的单个字符，[A-Za-z0-9_]</td><td>\w</td><td><strong>w</strong>ord</td></tr><tr><td>非单字字符</td><td>\W</td><td><strong>not</strong> <strong>w</strong>ord</td></tr><tr><td>0 或1个字符，惰性匹配</td><td>?</td><td>有无？</td></tr><tr><td>大于0个字符</td><td>*</td><td></td></tr><tr><td>大于1个字符</td><td>+</td><td>+1</td></tr><tr><td>分组</td><td>()</td><td></td></tr><tr><td>匹配区间集合</td><td>[ ]</td><td>[0-9] , [a-z]</td></tr><tr><td>匹配重复次数</td><td>{ }</td><td></td></tr></tbody></table><blockquote><ul><li>{x}: x次</li></ul><ul><li>{min, max}： 介于min次到max次之间</li><li>{min, }: 至少min次</li><li>{0, max}： 至多max次</li></ul></blockquote><table><thead><tr><th>边界和标志</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>字符串开头</td><td>^</td><td></td></tr><tr><td>字符串结尾</td><td>$</td><td></td></tr><tr><td>多行模式</td><td>m标志</td><td><strong>m</strong>ultiple of lines</td></tr><tr><td>忽略大小写</td><td>i标志</td><td><strong>i</strong>gnore case, case-<strong>i</strong>nsensitive</td></tr><tr><td>全局模式</td><td>g标志</td><td><strong>g</strong>lobal</td></tr></tbody></table><h3 id="p-和-p-的理解"><a href="#p-和-p-的理解" class="headerlink" title="(?=p)和(?!p)的理解"></a><strong>(?=p)和(?!p)的理解</strong></h3><p><code>(?=p)</code>，其中<code>p</code>是一个子模式，即<code>p</code>前面的<strong>位置</strong>。</p><p>比如<code>(?=l)</code>，表示’l’字符前面的位置，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配l前面的位置</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">'#'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); </span><br><span class="line"><span class="comment">// =&gt; "he#l#lo"</span></span><br></pre></td></tr></table></figure><p>而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?!l)/g</span>, <span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); </span><br><span class="line"><span class="comment">// =&gt; "#h#ell#o#"</span></span><br></pre></td></tr></table></figure><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意里面的<code>\1</code>，表示的引用之前小括号的那个分组<code>(-|\/|\.)</code>。</p><p><code>\2</code>和<code>\3</code>即分别指代第二个和第三个分组。</p><p><strong>括号嵌套</strong>以左括号为准</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><p>更复杂的正则 参考推荐老姚写的正则迷你书：<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5965943ff265da6c30653879#heading-5</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;RegExp.prototype.exec&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的RegExp方法，它返回一个&lt;strong&gt;数组&lt;/strong&gt;（未匹配到则返回 null）。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RegExp.prototype.test&lt;/td&gt;&lt;td&gt;一个在字符串中测试是否匹配的RegExp方法，它&lt;strong&gt;返回 true 或 false&lt;/strong&gt;。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.match&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.matchAll&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.search&lt;/td&gt;&lt;td&gt;一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.replace&lt;/td&gt;&lt;td&gt;一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String.prototype.split&lt;/td&gt;&lt;td&gt;一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 &lt;code&gt;String&lt;/code&gt; 方法。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网络基础 复习</title>
    <link href="http://yoursite.com/2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%20180414/"/>
    <id>http://yoursite.com/2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%20180414/</id>
    <published>2020-02-28T02:01:32.889Z</published>
    <updated>2020-02-28T02:01:32.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 协议是<strong>面向无连接</strong>的，正式传递数据之前<strong>不需要先连接</strong>起双方（不可靠性）。不会对数据报文进行任何拆分和拼接操作（高效）。</p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:05 GMT+0800 (GMT+08:00) --><p>UDP支持一对多，多对多，多对一的方式。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 建立连接断开连接都需要先需要进行握手。</p><h4 id="建立连接3次握手"><a href="#建立连接3次握手" class="headerlink" title="建立连接3次握手"></a>建立连接3次握手</h4><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1631bf1e79b3cd42" alt="img"></p><h4 id="断开连接四次握手"><a href="#断开连接四次握手" class="headerlink" title="断开连接四次握手"></a>断开连接四次握手</h4><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5C1631fb807f2c6c1b" alt="img"></p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get post 区别"></a>get post 区别</h3><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点，因为Get 请求都包含在 URL 里（当然你想写到 <code>body</code> 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。</li><li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li></ul><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p><strong>2XX 成功</strong></p><ul><li><p>！！200 OK，表示从客户端发来的请求在服务器端被正确处理</p></li><li><p>204 No content，表示请求成功，但响应报文不含实体的主体部分（请求成功但是没有资源返回）</p></li><li><p>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</p></li><li><p>206 Partial Content，进行范围请求</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efb76d2b65f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li></ul><p><strong>3XX 重定向</strong></p><ul><li><p>！！<strong>301 moved permanently，永久性重定向</strong>，表示资源已被分配了新的 URL</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efa6a4ba749?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！<strong>302 found，临时性重定向</strong>，表示资源临时被分配了新的 URL</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efba78b2b7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>303 see other，表示资源存在着另一个 URL，应使用 <strong>GET</strong> 方法获取资源</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efbc1b5cfce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！<strong>304 not modified</strong>，表示服务器允许访问资源，但因发生请求未满足条件的情况（304 虽 然被划分在 3XX 类别中，但是和重定向没有关系。）</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaa07f726e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>307 temporary redirect，临时重定向，和302含义类似，尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。</p><p>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况</p></li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><p>！！400 bad request，请求<strong>报文存在语法错误</strong></p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaa064bdb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！401 unauthorized，表示发送的请求需要有通过 <strong>HTTP 认证</strong>的认证信息</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efacc2e6a4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>！！403 forbidden，表示对请求资源的访问<strong>被服务器拒绝</strong></p></li><li><p>！！404 not found，表示在服务器上<strong>没有找到</strong>请求的<strong>资源</strong></p></li><li><p>405 Method Not Allowed， 客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法（GET 和 HEAD 方法，服务器应该总是允许客户端进行访问）</p><blockquote><p>客户端可以通过 OPTIONS 方法来查看服务器允许的访问方法, 如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><p>！！500 internal sever error，表示服务器端在执行请求时发生了错误</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efae2420839?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p></li><li><p>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</p></li><li><p>502 Bad Gateway，表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。（通常不是客户端能够修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复）</p></li><li><p>！！503 service unavailable，表明服务器暂时处于<strong>超负载或正在停机维护</strong>，无法处理请求</p></li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2017/12/6/16029efaf01b284a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片摘取自HTTP图解"></p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><p><strong>对称加密</strong>：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p><strong>非对称加密</strong>：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>流程：首先<strong>服务端</strong>将<strong>公钥公布</strong>出去，那么客户端也就知道公钥了。接下来<strong>客户端</strong>创建一个<strong>秘钥</strong>，然后<strong>通过公钥加密</strong>并发送给<strong>服务端</strong>，<strong>服务端接收</strong>到密文以后通过<strong>私钥解密出正确的秘钥</strong>，这时候两端就都知道秘钥是什么了。</p><h3 id="ssl握手过程"><a href="#ssl握手过程" class="headerlink" title="ssl握手过程"></a>ssl握手过程</h3><ol><li>首先，<strong>客户端</strong> 访问 <strong>服务端</strong> 。这时候<strong>客户端 会生成一个随机数</strong>1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务端。</li><li><strong>服务器</strong> 收到这些信息后，然后确认一下双方的加密算法，然后服务端也生成一个随机数 2 ，并<strong>将随机数 2 和 CA 颁发给自己的证书一同返回</strong>给客户端 A 。</li><li><strong>客户端</strong> 得到 CA 证书后，会去校验该 CA 证书的有效性，校验通过后，客户端生成一个随机数 3 ，然后<strong>用证书中的公钥加密随机数 3</strong> 并传输给服务端 。</li><li><strong>服务端</strong> 得到加密后的<strong>随机数 3</strong>，然后利用<strong>私钥进行解密</strong>，得到真正的随机数3。</li><li>最后，客户端 和 服务端 都有随机数1、随机数2、随机数3，然后双方利用这<strong>三个随机数生成一个对话密钥</strong>。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。</li><li>客户端 通知 服务端 ，指明后面的通讯用对话密钥来完成，同时通知 服务端 握手过程结束。</li><li>服务端 通知 客户端 ，指明后面的通讯用对话密钥来完成，同时通知客户端 握手过程结束。</li><li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 和服务端 开始使用相同的对话密钥进行数据通讯。</li></ol><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><p>在 HTTP/2 中引入了<strong>多路复用</strong>的技术（就是在<strong>一个 TCP</strong> 连接中可以存在<strong>多条流</strong>，对端可以通过<strong>帧中的标识</strong>知道属于哪个请求）。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，可以避免 HTTP 旧版本中的队头阻塞问题，更容易实现全速传输。</p><blockquote><p><strong>帧</strong>代表着<strong>最小的数据单位</strong>，每个帧会标识出该帧属于哪个流，<strong>流</strong>也就是<strong>多个帧组成</strong>的数据流。</p></blockquote><p>在之前的 HTTP 版本中，我们是通过<strong>文本</strong>的方式传输数据。在 HTTP/2 中所有传输的数据都会被分割，并采用<strong>二进制格式编码</strong>。</p><p>在 HTTP /2 中，使用了 HPACK <strong>压缩</strong>格式对传输的 header 进行编码，减少了 <strong>header</strong> 的大小。并在两端维护了<strong>索引表</strong>，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的<strong>键名</strong>，对端收到数据后就可以通过<strong>键名找到对应的值</strong>。</p><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了，导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能</p><p><strong>多路复用</strong></p><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p><p>并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p><p><strong>纠错机制</strong></p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</p><p>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</p><p><strong>0-RTT</strong></p><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p><h3 id="输入-URL-到页面渲染的整个流程"><a href="#输入-URL-到页面渲染的整个流程" class="headerlink" title="输入 URL 到页面渲染的整个流程"></a>输入 URL 到页面渲染的整个流程</h3><h4 id="dns查询"><a href="#dns查询" class="headerlink" title="dns查询"></a>dns查询</h4><ol><li>操作系统会首先在<strong>本地缓存</strong>中查询 IP</li><li>没有的话会去<strong>系统配置</strong>的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 <strong>DNS 根服务器查询</strong>，这一步查询会找出负责 <code>com</code> 这个一级域名的服务器</li><li>然后去该服务器查询 <code>google</code> 这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 <code>www</code> 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ol><p>接下来是 TCP 握手，应用层会下发数据给传输层，这里 <strong>TCP 协议</strong>会指明两端的<strong>端口</strong>号，然后下发给网络层。<strong>网络层</strong>中的 <strong>IP 协议</strong>会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。</p><p>TLS 的握手情况以及两种加密方式：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p><p>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上。这时假设服务端会响应一个 HTML 文件。</p><p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</p><p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。</p><p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p><p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; title=&quot;网络基础&quot;&gt;&lt;/a&gt;网络基础&lt;/h1&gt;&lt;h3 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h3&gt;&lt;p&gt;UDP 协议是&lt;strong&gt;面向无连接&lt;/strong&gt;的，正式传递数据之前&lt;strong&gt;不需要先连接&lt;/strong&gt;起双方（不可靠性）。不会对数据报文进行任何拆分和拼接操作（高效）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode树 算法基础</title>
    <link href="http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-27T05:02:30.073Z</published>
    <updated>2020-02-29T04:21:21.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode树-算法基础"><a href="#leetcode树-算法基础" class="headerlink" title="leetcode树 算法基础"></a>leetcode树 算法基础</h1><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>解：</strong>递归遍历左右子树，每层+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left)</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>解答：</strong>之前理解错了，不是当前节点满足就行，子节点的所有祖先节点都要满足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, pre = null, next = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 先序遍历 以及哪些上下限进行了比较</span></span><br><span class="line">  <span class="comment">// sole.log(root &amp;&amp; root.val, pre &amp;&amp; pre.val, next &amp;&amp; next.val);</span></span><br><span class="line">  <span class="keyword">if</span> (pre &amp;&amp; pre.val &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (next &amp;&amp; next.val &lt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 逻辑判断 递归 如果左边true就是遍历倒底了 则返回右边</span></span><br><span class="line">  <span class="comment">// ！关键递归 如果是左子节点把当前节点作为下限 右子节点把当前节点作为上限 </span></span><br><span class="line">  <span class="keyword">return</span> isValidBST(root.left, pre, root) &amp;&amp; isValidBST(root.right, root, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>解答：还是递归，左右镜像判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空树直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMirror</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两子都为空，返回真</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 有一边为空，则不对称</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> || right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 条件判断 左边的子左边与右边的子右边相等 </span></span><br><span class="line">    <span class="keyword">return</span> left.val === right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解答： 打印root树仔细查看它的结构，迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="comment">// 每层的子节点数</span></span><br><span class="line">        <span class="keyword">let</span> level = queue.length</span><br><span class="line">        <span class="keyword">let</span> current = []</span><br><span class="line">        <span class="keyword">while</span>(level--) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            current.push(node.val)</span><br><span class="line">            <span class="keyword">if</span> (node.left) queue.push(node.left)</span><br><span class="line">            <span class="keyword">if</span> (node.right) queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>解答：要明确两个点，1.二叉搜索树左子树小右子树大，高度要平衡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> middleL = nums.length &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment">// 每次取到中间数</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(nums[middleL])</span><br><span class="line">    <span class="comment">// 递归，左边左树，右边右数</span></span><br><span class="line">    node.left = sortedArrayToBST(nums.slice(<span class="number">0</span>, middleL))</span><br><span class="line">    node.right = sortedArrayToBST(nums.slice(middleL + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>希望能步入学习正轨，看同届前端群的好几位大哥进腾讯阿里提前批就上岸了。自己不能越差越远啊</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode树-算法基础&quot;&gt;&lt;a href=&quot;#leetcode树-算法基础&quot; class=&quot;headerlink&quot; title=&quot;leetcode树 算法基础&quot;&gt;&lt;/a&gt;leetcode树 算法基础&lt;/h1&gt;&lt;h3 id=&quot;二叉树的最大深度&quot;&gt;&lt;a href=&quot;#二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度&quot;&gt;&lt;/a&gt;二叉树的最大深度&lt;/h3&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基础排序算法JS实现</title>
    <link href="http://yoursite.com/2020/02/23/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/"/>
    <id>http://yoursite.com/2020/02/23/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/</id>
    <published>2020-02-23T10:12:38.689Z</published>
    <updated>2020-02-23T11:16:14.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法JS实现"><a href="#基础排序算法JS实现" class="headerlink" title="基础排序算法JS实现"></a>基础排序算法JS实现</h1><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1</p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>先定义一个交换位置函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr 传入数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; a 要交换的数组下标index</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; b index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[a]</span><br><span class="line">  arr[a] = arr[b]</span><br><span class="line">  arr[b] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与有序的数组进行比较，<strong>比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="comment">// 从第二个开始，把第一个设为初有序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="comment">// 取出当前遍历数组的数</span></span><br><span class="line">    <span class="keyword">let</span> tNum = arr.splice(i, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 从有序数组末尾开始比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">// 比最小的小，直接插入队头</span></span><br><span class="line">      <span class="keyword">if</span>(tNum &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        arr.unshift(tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到个合适的位置插入</span></span><br><span class="line">      <span class="keyword">if</span> (tNum &gt; arr[j]) &#123;</span><br><span class="line">        arr.splice(j+<span class="number">1</span>, <span class="number">0</span>, tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到数组中最大的元素，与数组未排序最后一位元素交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有一个数时就不要排序了 -1趟</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">        max = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把最大的放到最后面</span></span><br><span class="line">    swap(arr, max, arr.length<span class="number">-1</span>-i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>选择一个中间节点，小的放左边，大的放右边，不断递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取数组中间下标值</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.splice(arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = [],</span><br><span class="line">    right = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] &lt; middle ? left.push(arr[i]) : right.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quick(left).concat(middle,quick(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分而治之加递归，先把数组递归二分，然后比较合并</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="merge-sort-example.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="comment">// 如果数组长度小于二直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取到中间值 同等于 Math.floor(arr.length/2)</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.length &gt;&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 切出左右两边 （start,end断掉下标前一位)</span></span><br><span class="line">    left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle)</span><br><span class="line">  <span class="comment">// 递归拆分，然后比较，合并比较，这里理解难点，可以动手画一画程序流程</span></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="comment">// 两边数组头项 比较大小</span></span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">// 如果左边小，就把左边数组头项取出，推入新结果</span></span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果左边有右边没有情况下直接推入</span></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift())</span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><a href="https://www.bilibili.com/video/av47196993?from=search&seid=3195181450169677356" target="_blank" rel="noopener">堆排序视频讲解C语言实现</a></p><p>用数组可以表示一个完全二叉树，左子节点<code>2i+1</code>，右子节点<code>2i+2</code></p><blockquote><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从最后一个含有子节点的父节点开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i, arr.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 堆完成后，每次把对顶最大的数放到末尾</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    <span class="comment">// 交换之后，再规范堆的位置</span></span><br><span class="line">    heapify(arr, <span class="number">0</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arr 数组(堆)</span></span><br><span class="line"><span class="comment"> * i 数组(堆)下标</span></span><br><span class="line"><span class="comment"> * length 数组(堆)长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 完全二叉树,堆函数顺序化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span> (<span class="params">arr, i, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = arr[i]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">    parent = arr[i]</span><br><span class="line">    <span class="comment">// 找到两子节点中较大的一个，再与父节点比较</span></span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent &lt; arr[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点大于子节点:交换；否则跳出</span></span><br><span class="line">      swap(arr, i, j)</span><br><span class="line">      <span class="comment">// 交换后，parent 的值下标变为交换的子节点</span></span><br><span class="line">      i = j</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在家这么久效率有些低，这篇排序还做了这么久，之前数据结构课程也都复习过，疫情快快过去把，想去图书馆里了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法JS实现&quot;&gt;&lt;a href=&quot;#基础排序算法JS实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法JS实现&quot;&gt;&lt;/a&gt;基础排序算法JS实现&lt;/h1&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-02-15T11:20:10.147Z</published>
    <updated>2020-02-23T10:11:58.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &lt;&lt; 1 // -&gt; 20</span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &gt;&gt; 1 // -&gt; 5</span><br></pre></td></tr></table></figure><p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 <code>a / (2 ^ b)</code></p><h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p><strong>按位与</strong></p><p>每一位都为 1，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 &amp; 7 // -&gt; 0</span><br><span class="line">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>按位或</strong></p><p>其中一位为 1，结果就是 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 | 7 // -&gt; 15</span><br><span class="line">// 1000 | 0111 -&gt; 1111 -&gt; 15</span><br></pre></td></tr></table></figure><p><strong>按位异或</strong></p><p>每一位都不同，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8 ^ 7 // -&gt; 15</span><br><span class="line">8 ^ 8 // -&gt; 0</span><br><span class="line">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span><br><span class="line">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><h3 id="两个数不使用四则运算得出和"><a href="#两个数不使用四则运算得出和" class="headerlink" title="两个数不使用四则运算得出和"></a>两个数不使用四则运算得出和</h3><p>通过迭代的方式模拟加法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">    <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;h3 id=&quot;左移-lt-lt&quot;&gt;&lt;a href=&quot;#左移-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移 &amp;lt;&amp;lt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10 &amp;lt;&amp;lt; 1 // -&amp;gt; 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;左移就是将二进制全部往左移动，&lt;code&gt;10&lt;/code&gt; 在二进制中表示为 &lt;code&gt;1010&lt;/code&gt; ，左移一位后变成 &lt;code&gt;10100&lt;/code&gt; ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 &lt;code&gt;a * (2 ^ b)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS的类型转换</title>
    <link href="http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-02-09T10:23:15.266Z</published>
    <updated>2020-02-10T07:44:53.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h1><p>除去 Object 和 Symbol，有如下几种原始类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li></ul><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>在 JavaScript 进行<strong>对比</strong>或者<strong>各种运算</strong>的时候会把对象转换成这些类型，从而进行后续的操作</p><h3 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h3><ol><li><p><strong>对象</strong>转为<strong>布尔</strong>都为 true</p></li><li><p><strong>对象</strong>转为<strong>字符串</strong>，先<code>toString()</code>方法，如果<strong>未</strong>返回原始类型，再<code>valueOf()</code>方法，再不行就报错</p></li><li><p><strong>对象</strong>转为<strong>数字</strong>，先<code>valueOf()</code>方法，如果<strong>未</strong>返回原始类型，再<code>toString()</code>方法，再不行就报错，反过来的</p></li></ol><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><h4 id="运算规则"><a href="#运算规则" class="headerlink" title="==运算规则"></a>==运算规则</h4><ul><li><p>如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较。</p></li><li><p>如果一个值是<strong>对象</strong>，另一个值是<strong>数字或字符串</strong>，则将<strong>对象转换为原始值</strong>再进行比较。对象通过toString()方法或valueOf()方法转换为原始值。JavaScript语言核心的内置类首<strong>先尝试使用valueOf()，在尝试使用toString()</strong>，除了日期类，日期类只使用toString()方法，那些不是JavaScript语言核心中的对象则通过各自实现中定义的方法转换为原始值。</p></li></ul><h4 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h4><ul><li>toString</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d44d25a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>valueOf</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d85b808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>转为boolean类型</li></ul><p>所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true</p><h3 id="运算符类型转化"><a href="#运算符类型转化" class="headerlink" title="+运算符类型转化"></a>+运算符类型转化</h3><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d0924e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! + [] + [] + ![]</span><br></pre></td></tr></table></figure><ol><li><p>先运算一元运算符， <code>+[]</code>转为Number类型 ，返回0，<code>![]</code>转为Boolean类型 ，!true 返回false.<code>!0+[]+false</code></p></li><li><p><code>true+[]+false</code></p></li><li><p><code>true+&quot;&quot;+false</code>返回<code>&quot;truefalse&quot;</code></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS的类型转换&quot;&gt;&lt;a href=&quot;#JS的类型转换&quot; class=&quot;headerlink&quot; title=&quot;JS的类型转换&quot;&gt;&lt;/a&gt;JS的类型转换&lt;/h1&gt;&lt;p&gt;除去 Object 和 Symbol，有如下几种原始类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Number&lt;/li&gt;&lt;li&gt;String&lt;/li&gt;&lt;li&gt;Boolean&lt;/li&gt;&lt;li&gt;Undefined&lt;/li&gt;&lt;li&gt;Null&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器跨域问题</title>
    <link href="http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-08T03:46:27.582Z</published>
    <updated>2020-02-08T14:10:46.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h1><blockquote><p>处于安全考虑 如果<strong>协议、域名或者端口</strong>有一个不同就是跨域，Ajax 请求会失败。</p></blockquote><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><blockquote><p>利用<code>&lt;script&gt;</code>标签<strong>没有 跨域限制</strong>，<strong>指向</strong>一个需要<strong>访问的地址</strong>并提供一个<strong>回调</strong>函数来<strong>接收数据</strong>。只限于 <code>get</code> 请求。</p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>实现jsonp封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="comment">// 约定一个callback字段名，来传递函数名，前端通过该函数来拿到数据</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><blockquote><p>它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。</p></blockquote><p>在服务端增加一些<strong>头部属性</strong>就行，客户端浏览器会自动添加origin字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入http库</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="comment">// 字段</span></span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">      <span class="comment">// 允许请求的地址</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">      <span class="comment">// 请求方法</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET, POST, PUT'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    response.end(<span class="string">'request success!!!'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浏览器跨域问题&quot;&gt;&lt;a href=&quot;#浏览器跨域问题&quot; class=&quot;headerlink&quot; title=&quot;浏览器跨域问题&quot;&gt;&lt;/a&gt;浏览器跨域问题&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;处于安全考虑 如果&lt;strong&gt;协议、域名或者端口&lt;/strong&gt;有一个不同就是跨域，Ajax 请求会失败。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;jsonp&quot;&gt;&lt;a href=&quot;#jsonp&quot; class=&quot;headerlink&quot; title=&quot;jsonp&quot;&gt;&lt;/a&gt;jsonp&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;利用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;strong&gt;没有 跨域限制&lt;/strong&gt;，&lt;strong&gt;指向&lt;/strong&gt;一个需要&lt;strong&gt;访问的地址&lt;/strong&gt;并提供一个&lt;strong&gt;回调&lt;/strong&gt;函数来&lt;strong&gt;接收数据&lt;/strong&gt;。只限于 &lt;code&gt;get&lt;/code&gt; 请求。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>new 和 instanceof</title>
    <link href="http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/"/>
    <id>http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/</id>
    <published>2020-02-06T07:06:57.491Z</published>
    <updated>2020-02-06T12:25:35.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-和-instanceof"><a href="#new-和-instanceof" class="headerlink" title="new 和 instanceof"></a>new 和 instanceof</h1><h3 id="new模拟实现"><a href="#new模拟实现" class="headerlink" title="new模拟实现"></a>new模拟实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 取第一个参数构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 把把新对象的原型链 链到 构造函数的原型对象</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定this 实现继承 ， obj可以访问到构造函数的属性</span></span><br><span class="line">  Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 到链的顶端 null 还没找到，就说明没有继承关系 </span></span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 右边的原型对象 等于左边的_PROTO_ 就说明是继承关系</span></span><br><span class="line">    <span class="keyword">if</span> (right.prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 原型链深入</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;new-和-instanceof&quot;&gt;&lt;a href=&quot;#new-和-instanceof&quot; class=&quot;headerlink&quot; title=&quot;new 和 instanceof&quot;&gt;&lt;/a&gt;new 和 instanceof&lt;/h1&gt;&lt;h3 id=&quot;new模拟实现&quot;&gt;&lt;a href=&quot;#new模拟实现&quot; class=&quot;headerlink&quot; title=&quot;new模拟实现&quot;&gt;&lt;/a&gt;new模拟实现&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myNew&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 创建一个空对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 取第一个参数构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; Con = [].shift.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 把把新对象的原型链 链到 构造函数的原型对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  obj.__proto__ = Con.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 绑定this 实现继承 ， obj可以访问到构造函数的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Con.apply(obj, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小程序云开发学习入门</title>
    <link href="http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-04T07:07:48.754Z</published>
    <updated>2020-02-06T12:43:28.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序云开发学习"><a href="#小程序云开发学习" class="headerlink" title="小程序云开发学习"></a>小程序云开发学习</h1><blockquote><p>朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己</p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><h3 id="开始创建"><a href="#开始创建" class="headerlink" title="开始创建"></a>开始创建</h3><p>使用小程序开发者工具，创建新项目，点击云开发</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202214400410.png" alt="image-20200202214400410"></p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>右击创建login函数</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202215513556.png" alt="image-20200202215513556"></p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>点击上传图片，在云开发控制台，可以看到</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202220032800.png" alt="image-20200202220032800"></p><h3 id="前端操作数据库"><a href="#前端操作数据库" class="headerlink" title="前端操作数据库"></a>前端操作数据库</h3><p>先在云开发里创建一个集合，然后找到databaseGuide文件，取消onAdd函数的注释，</p><p>点击左侧新增记录，就会有显示，<strong>注意数据库名称要跟函数对的上</strong></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221042328.png" alt="image-20200202221042328"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221321531.png" alt="image-20200202221321531"></p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>最后还是没有参加此次黑客马拉松，第一云开发才刚刚有做了解，并没有相关经验，并且在群里组队失败。没有队友。自己一个人两天肯定无法完成任务，所以放弃了。😵</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小程序云开发学习&quot;&gt;&lt;a href=&quot;#小程序云开发学习&quot; class=&quot;headerlink&quot; title=&quot;小程序云开发学习&quot;&gt;&lt;/a&gt;小程序云开发学习&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现call,apply,bind函数</title>
    <link href="http://yoursite.com/2020/01/23/%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/"/>
    <id>http://yoursite.com/2020/01/23/%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/</id>
    <published>2020-01-23T08:55:50.382Z</published>
    <updated>2020-01-30T04:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现call-apply-bind函数"><a href="#实现call-apply-bind函数" class="headerlink" title="实现call,apply,bind函数"></a>实现call,apply,bind函数</h1><ul><li>如果第一个参数为null ，则指向window</li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><h3 id="复习this指向"><a href="#复习this指向" class="headerlink" title="复习this指向"></a>复习this指向</h3><p><strong>this永远指向最后一个调用这个方法的对象</strong></p><p>回顾<strong>隐式绑定</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'Jason'</span>,</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Jason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure><p>记住这个用法，他们用这个实现</p><h3 id="实现call-apply"><a href="#实现call-apply" class="headerlink" title="实现call,apply"></a>实现call,apply</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (context) this指向的对象 (...args) 扩展运算 传入参数， (args)就是apply </span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变this指向如果不传的话默认上下文为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  args = args ? args : []</span><br><span class="line">  <span class="comment">// 定义一个唯一值</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">  <span class="comment">// 把这个函数的this 写到call 对象的一个属性里</span></span><br><span class="line">  context[key] = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 通过“对象.方法（参数）”，可以把this指向对象</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">  <span class="comment">// 删除对象添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> context[key]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h3><p>bind返回一个绑定好的函数，不会立即执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">    args = args ? args : []</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是new的就返回new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> fn(...args, ...newFnArgs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个apply方法</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, [...args,...newFnArgs])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现call-apply-bind函数&quot;&gt;&lt;a href=&quot;#实现call-apply-bind函数&quot; class=&quot;headerlink&quot; title=&quot;实现call,apply,bind函数&quot;&gt;&lt;/a&gt;实现call,apply,bind函数&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;如果第一个参数为null ，则指向window&lt;/li&gt;&lt;li&gt;改变了 &lt;code&gt;this&lt;/code&gt; 指向，让新的对象可以执行该函数，并能接受参数&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现promise A+</title>
    <link href="http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/"/>
    <id>http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/</id>
    <published>2020-01-20T03:56:40.251Z</published>
    <updated>2020-01-20T04:05:06.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现promise-A"><a href="#实现promise-A" class="headerlink" title="实现promise A+"></a>实现promise A+</h1><blockquote><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">promiseA+规范</a>，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释</p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise的三个状态，pending =&gt; resolved or =&gt; reject, 不可逆</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个fn执行器,在try中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止this变向</span></span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 设开始状态为pending</span></span><br><span class="line">  that.state = PENDING</span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 reject 中传入参数的值</span></span><br><span class="line">  that.value = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 保存then中的回调</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  <span class="comment">// 失败的回调</span></span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入的值是否为 Promise 类型</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证异步执行顺序</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 改pending状态为 resolve</span></span><br><span class="line">        that.state = RESOLVED</span><br><span class="line">        <span class="comment">// 将传入的值赋值给 value</span></span><br><span class="line">        that.value = value</span><br><span class="line">        <span class="comment">// 遍历回调执行数组</span></span><br><span class="line">        that.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同resolve</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        that.state = REJECTED</span><br><span class="line">        that.value = value</span><br><span class="line">        that.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  <span class="comment">// 解决没有传值的问题，当参数不是函数类型时，需要创建一个函数赋值给对应的参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 返回一个新的 promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 往回调数组中 push 函数</span></span><br><span class="line">      that.resolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行函数中可能 报错 ，try catch 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      that.rejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//因为穿透值的缘故，在默认的跑出一个error后，不能再用下一个的reject来接受，只能通过try，catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          <span class="comment">//递归 判断他们是否为promise对象</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    <span class="comment">// onRejected(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是null ，是 对象 或 函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="comment">// called用于判断是否已经调用过函数</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> x.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数 x 作为this指向</span></span><br><span class="line">        x.then.call(</span><br><span class="line">          x,</span><br><span class="line">          success =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果调用过 就直接返回了</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 递归调用 .then 中是否还有子 promise</span></span><br><span class="line">            resolutionProcedure(promise2, success, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 错误直接返回</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象或函数将 x 传入resolve</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现promise-A&quot;&gt;&lt;a href=&quot;#实现promise-A&quot; class=&quot;headerlink&quot; title=&quot;实现promise A+&quot;&gt;&lt;/a&gt;实现promise A+&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;promiseA+规范&lt;/a&gt;，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数组方法整理</title>
    <link href="http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-01-18T04:00:08.392Z</published>
    <updated>2020-01-19T08:15:41.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组方法整理"><a href="#数组方法整理" class="headerlink" title="数组方法整理"></a>数组方法整理</h1><blockquote><p>要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下</p></blockquote><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><blockquote><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">mdn</a></p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p><strong>不会返回执行结果</strong>，返回的是<code>undefined</code>，也就是说，<code>forEach()</code><strong>会修改原来的数组</strong>，中途<strong>不能</strong>用常规操作<strong>跳出循环</strong>，不支持<strong>链式</strong>操作，forEach之前可以链式</p><p>当数组中元素是<strong>值</strong>类型，forEach<strong>不会改变</strong>数组；当是<strong>引用</strong>类型，则<strong>可以改变</strong>数组</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote><p><code>map()</code> 方法创建一个<strong>新数组</strong>，其结果是该数组中的每个元素都调用一个提供的函数后<strong>返回的结果</strong>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">mdn</a></p></blockquote><p><code>map()</code>方法会得到一个<strong>新的数组</strong>并返回。速度更快，必须要有return。</p><hr><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote><p><code>filter()</code> 方法创建一个<strong>新数组</strong>，其包含<strong>通过</strong>所提供函数实现的<strong>测试</strong>的所有元素。</p></blockquote><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><blockquote><p><code>sort()</code> 方法用<a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">原地算法</a>对数组的元素进行排序，并返回数组。默认按Unicode升序</p></blockquote><p><strong>它直接改变原始数组</strong></p><p>要比较数字而非字符串，比较函数可以简单的以 <strong>a 减 b</strong>，如下的函数将会将数组<strong>升序</strong>排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]; </span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><blockquote><p><code>some()</code> 方法测试数组中是不是至少有<strong>1个元素通过</strong>了被提供的函数测试。它返回的是一个Boolean类型的值。</p></blockquote><p>只要有一个满足即返回true，之后的不再执行</p><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><blockquote><p><code>every()</code> 方法测试一个数组内的所有元素是否<strong>都</strong>能通过某个指定函数的测试。它返回一个布尔值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'cecilia'</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;</span><br><span class="line">].every(<span class="function"><span class="params">item</span> =&gt;</span> item.age &gt; <span class="number">19</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><blockquote><p><code>find()</code> 方法返回数组中<strong>满足提供的测试函数</strong>的<strong>第一个</strong>元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p></blockquote><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的<strong>第一个</strong>元素的<strong>索引</strong>。否则返回-1。</p><hr><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><blockquote><p>对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p></blockquote><ul><li>accumulator 累计器</li><li>currentValue 当前值</li><li>currentIndex 当前索引(可选)</li><li>array 数组（可选）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr );</span><br></pre></td></tr></table></figure><p>如果你打算提供一个初始值作为<code>reduce()</code>方法的第二个参数，以下是运行过程及结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue; &#125;, 10 );</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><code>callback</code></th><th align="left"><code>accumulator</code></th><th align="left"><code>currentValue</code></th><th align="left"><code>currentIndex</code></th><th align="left"><code>array</code></th><th align="left">return value</th></tr></thead><tbody><tr><td align="left">first call</td><td align="left"><code>10</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>10</code></td></tr><tr><td align="left">second call</td><td align="left"><code>10</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>11</code></td></tr><tr><td align="left">third call</td><td align="left"><code>11</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>13</code></td></tr><tr><td align="left">fourth call</td><td align="left"><code>13</code></td><td align="left"><code>3</code></td><td align="left"><code>3</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>16</code></td></tr><tr><td align="left">fifth call</td><td align="left"><code>16</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>20</code></td></tr></tbody></table><p>这种情况下<code>reduce()</code>返回的值是<code>20</code>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组方法整理&quot;&gt;&lt;a href=&quot;#数组方法整理&quot; class=&quot;headerlink&quot; title=&quot;数组方法整理&quot;&gt;&lt;/a&gt;数组方法整理&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;forEach&quot;&gt;&lt;a href=&quot;#forEach&quot; class=&quot;headerlink&quot; title=&quot;forEach()&quot;&gt;&lt;/a&gt;forEach()&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;forEach()&lt;/code&gt; 方法对数组的每个元素执行一次提供的函数。&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mdn&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何实现JS继承</title>
    <link href="http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/</id>
    <published>2020-01-16T08:45:25.951Z</published>
    <updated>2020-01-17T00:39:27.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现JS继承"><a href="#如何实现JS继承" class="headerlink" title="如何实现JS继承"></a>如何实现JS继承</h1><blockquote><p>JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。</p></blockquote><p>es6之前是不支持接口直接继承的，所以就需要手动实现继承</p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>通过这个图先熟悉一下JS内部，constructor和prototype和实例的关系</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200115231115613.png" alt="image-20200115231115613"></p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure><p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p><p>问题二: 在创建子类型(例如创建Child的实例)时,不能向父类型(例如Parent)的构造函数中传递参数.</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题一：父类中定义的方法,对子类型而言也是不可见的</p><p>问题二：方法都在构造函数中定义, 因此函数复用也就不可用了</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用<strong>原型链</strong>实现对原型<strong>属性和方法</strong>的继承,通过借用<strong>构造函数</strong>来实现对<strong>实例属性</strong>的继承.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>缺点：调用了两次父类构造函数, 造成了不必要的消耗</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p><strong><code>Object.create()</code></strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.creat(Parent.prototype)</span><br><span class="line"><span class="comment">// 将子原型对象的构造函数指回来</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>如果你希望能继承到多个对象，则可以使用混入的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="ES6-class继承"><a href="#ES6-class继承" class="headerlink" title="ES6 class继承"></a>ES6 class继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  extends 表明继承自哪个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何实现JS继承&quot;&gt;&lt;a href=&quot;#如何实现JS继承&quot; class=&quot;headerlink&quot; title=&quot;如何实现JS继承&quot;&gt;&lt;/a&gt;如何实现JS继承&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;es6之前是不支持接口直接继承的，所以就需要手动实现继承&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖节流手写</title>
    <link href="http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-01-15T13:26:06.434Z</published>
    <updated>2020-03-05T09:15:31.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><blockquote><p>这两个应用场景很多，自己手写一下，可以解决服务器压力</p></blockquote><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</strong></p><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>场景：用户输入停止一段时间过后再去获取数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"debounce"</span>&gt;</span>防抖按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>)</span></span><br><span class="line"><span class="actionscript">      myDebounce.addEventListener(<span class="string">'click'</span>, debounce(sayDebounce, <span class="number">1000</span>))</span></span><br><span class="line">    </span><br><span class="line">      /**</span><br><span class="line">       * 防抖功能函数</span><br><span class="line">       * fn 要防抖的功能函数</span><br><span class="line">       * delay 延迟多久，毫秒</span><br><span class="line">       **/</span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> <span class="params">(fn, delay, immediate)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包，创建一个标记用来存放定时器的返回值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeout = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 触发事件回调时执行这个 teturn function</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 每次当用户点击/输入的时候，把前一个定时器清除</span></span></span><br><span class="line">          if(timeout) clearTimeout(timeout)</span><br><span class="line">           </span><br><span class="line"><span class="actionscript">          <span class="comment">// immediate true 首次触发执行</span></span></span><br><span class="line">          if(immediate) &#123;</span><br><span class="line"><span class="actionscript">              immediate = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">              fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line"><span class="actionscript">          <span class="comment">// 创建一个新的 setTimeout，</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 这样就能保证点击按钮后的间隔内,如果用户还点击了的话，就不会执行 fn 函数</span></span></span><br><span class="line"><span class="javascript">          timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 以防需要防抖的事件this指向被改变 绑定一下this指向</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 需要防抖的事件 形参 用argument 绑进来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 定时器结束后传入 fn函数 </span></span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要防抖的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'防抖成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>减少一段时间内触发的频率。</strong></p><ul><li>方法一：设置flag 执行前flag flase 在定时器内节流时间执行后 设回 true</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"throttle"</span>&gt;</span>点击节流<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">'throttle'</span>)</span></span><br><span class="line"><span class="actionscript">      myThrottle.addEventListener(<span class="string">'click'</span>, throttle(sayThrottle, <span class="number">1000</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 节流函数体</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> <span class="params">(fn, delay)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包保存一个标记</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// flag为false 说明还在节流时间中 退出函数</span></span></span><br><span class="line">          if (!flag) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span></span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 将 flag 设置为 false，防止执行之前再被执行</span></span></span><br><span class="line"><span class="actionscript">          flag = <span class="literal">false</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="javascript">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span></span></span><br><span class="line"><span class="actionscript">            flag = <span class="literal">true</span></span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要节流的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'节流成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方法二：时间戳来判断是否已到执行时间。与上次函数执行的时间比较，大于节流时间就放行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用闭包保存，上一次执行 fn 的时间 </span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">        <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            previous = now</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖加节流"><a href="#防抖加节流" class="headerlink" title="防抖加节流"></a>防抖加节流</h3><p>节流里面包防抖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要节流处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// previous 是上一次执行 fn 的时间</span></span><br><span class="line">  <span class="comment">// timer 是定时器</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ 新增部分 start ------ </span></span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &lt; wait) &#123;</span><br><span class="line">     <span class="comment">// 如果小于，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       <span class="comment">// 定时器时间结束后执行函数 fn </span></span><br><span class="line">       <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          previous = now</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    <span class="comment">// ------ 新增部分 end ------ </span></span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 第一次执行</span></span><br><span class="line">       <span class="comment">// 或者时间间隔超出了设定的时间间隔，执行函数 fn</span></span><br><span class="line">       previous = now</span><br><span class="line">       fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn 节流执行了'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 第一次触发 scroll 执行一次 fn，每隔 1 秒后执行一次函数 fn，停止滑动 1 秒后再执行函数 fn</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterFn)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;防抖节流&quot;&gt;&lt;a href=&quot;#防抖节流&quot; class=&quot;headerlink&quot; title=&quot;防抖节流&quot;&gt;&lt;/a&gt;防抖节流&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;这两个应用场景很多，自己手写一下，可以解决服务器压力&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾佬700元装了台主流配置电脑</title>
    <link href="http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/"/>
    <id>http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/</id>
    <published>2020-01-13T08:58:09.874Z</published>
    <updated>2020-01-15T03:23:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="700元垃圾佬主机大升级"><a href="#700元垃圾佬主机大升级" class="headerlink" title="700元垃圾佬主机大升级"></a>700元垃圾佬主机大升级</h1><blockquote><p>事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。</p></blockquote><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>京东双十二买的酷兽 当时199 <strong>16G 2666MHz</strong> 的内存，用了个199 -15 的全品类券 ，白菜价<strong>184</strong>到手，单面2G*8颗粒组成16G容量，镁光颗粒。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/RAM2.jpg" alt="RAM2"><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/QK@@34LQC(W%7B)I@%7B%7DUIVT2.jpg" alt="img"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>最终选定一代锐龙，R5-1400 四核-八线程 基础频率3.2GHz。便宜就完事，全新带散热器淘宝只要350左右，其实9月就到这价格了，已经没有降价空间了。为了追求更便宜，买了咸鱼二手，cpu这种东西用不坏的，所以二手也稳。这块cpu也能稳定超频。唯一缺陷就是没有核心显卡，还得另外配，没显卡还是建议速龙3000G(APU).</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113114601686.png" alt="image-20200113114601686"></p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>映泰tb350-etc，全新矿板，可装六张显卡，支持AM4处理器，7相供电，很稳定，矿难清库存还剩点，230入手。唯一的缺点就是，不支持MVME接口，只能装sata固态。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120344918.png" alt="image-20200113120344918"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120905439.png" alt="image-20200113120905439"></p><h3 id="硅脂"><a href="#硅脂" class="headerlink" title="硅脂"></a>硅脂</h3><p>淘宝特价版，5元红包，1.9元入手 ，看过一个测试硅脂的话，涂X形状就行，刮刀就往一边刮。<img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122109279.png" alt="image-20200113122109279"></p><hr><h3 id="总价"><a href="#总价" class="headerlink" title="总价"></a>总价</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122402817.png" alt="image-20200113122402817"></p><h3 id="不要钱系列"><a href="#不要钱系列" class="headerlink" title="不要钱系列"></a>不要钱系列</h3><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>表哥有个闲置显卡，七彩虹GTX650，送给我了。玩玩普通网游还是无压力的。费米之后的开普勒架构很大程度上改善了高功耗、高发热问题。这里感谢翔哥。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113123036484.png" alt="image-20200113123036484"></p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>朗科480G固态，老爹闲置的固态。速度不快，但是够用，读写速度加上十秒开机。爽歪歪。</p><h4 id="机箱，机械硬盘，电源"><a href="#机箱，机械硬盘，电源" class="headerlink" title="机箱，机械硬盘，电源"></a>机箱，机械硬盘，电源</h4><p>全是祖传的</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163203557.png" alt="image-20200113163203557"></p><hr><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h3><ul><li>*<em>I tell you *</em>里面下载win10 企业版</li><li>一个大于8G U盘 ，格式化后 用 UltraISO 把系统搞到U盘</li><li>在BIOS里，设置U盘优先启动</li><li>Win 10激活 傻瓜式破解 链接: <a href="https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA</a> 提取码: 3fff （仅用于个人学习，商业用途概不负责）</li></ul><h3 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h3><p>下载的是win10企业版比较纯净。纯净到什么都没有。。。计算器，win商店都没有</p><p>win商店下载，进入商店之后edge浏览器等软件下载</p><p>链接: <a href="https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw</a> 提取码: tia9</p><p>解压：<strong>bandzip</strong></p><p>杀毒：<strong>火绒</strong>，关闭垃圾软件广告弹窗</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kbtool.cn/" target="_blank" rel="noopener">EX-DIY工具箱 卡硬工具箱 （原：卡吧工具箱）</a>，一个集合型工具，汇总了几大常用检测软件。</p><h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p>基础的超频很简单，直接在bios里面，调频率就行了。一般超个10%很稳定的，再往上超就需要调节电压了。新手建议不加电压以免烧坏。就一步一步一点点加，加到黑屏的话直接扣下主板电池，主板就会恢复出厂设置。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163312898.png" alt="image-20200113163312898"></p><h4 id="cpu超频"><a href="#cpu超频" class="headerlink" title="cpu超频"></a>cpu超频</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161954488.png" alt="image-20200113161954488"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161924106.png" alt="image-20200113161924106"></p><p>轻松超到3.7GHz，家里用就不继续超了，功耗会增加</p><h4 id="内存超频"><a href="#内存超频" class="headerlink" title="内存超频"></a>内存超频</h4><p>轻松超到2933MHz，等有钱了配个双通道32G 内存。再往上走，得调降低搬运时序了。</p><h4 id="显卡超频"><a href="#显卡超频" class="headerlink" title="显卡超频"></a>显卡超频</h4><p>NVIDIA Inspector是一款N卡专用的检测/超频软件，不但像GPU-Z一样可以检测显卡的各种信息，还能对显卡的频率、风扇转速甚至电压进行调节，十分实用。核心频率超100MHz和显存频率超200MHz，最后面的电压也不建议调，容易烧。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/L4CL2D%7D%5BJ_B5VSZ%7D%60%5BLDS45.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装机，重点是过程和玩，淘宝垃圾的过程，装机的过程。挺好玩的。总的来说这次700元装出3000元的逼了。</p><hr><h3 id="番外篇：晒好价外设"><a href="#番外篇：晒好价外设" class="headerlink" title="番外篇：晒好价外设"></a>番外篇：晒好价外设</h3><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>酷冷至尊 k370 红轴，此款键盘的特点是 cherry原厂红轴，全键无冲，BPT键帽不易打油，有卫星轴，很重底层有钢板，预留灯位，想想一个红轴的单价都是2块，算算光轴的钱就超200了，199内还要啥自行车。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113164616416.png" alt="image-20200113164616416"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113165124122.png" alt="image-20200113165124122"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;a href=&quot;#700元垃圾佬主机大升级&quot; class=&quot;headerlink&quot; title=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;/a&gt;700元垃圾佬主机大升级&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Js深浅拷贝</title>
    <link href="http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-01-11T05:08:11.772Z</published>
    <updated>2020-03-11T02:43:33.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS深浅拷贝"><a href="#JS深浅拷贝" class="headerlink" title="JS深浅拷贝"></a>JS深浅拷贝</h1><blockquote><p>要想深入的确实个值得探究的问题</p></blockquote><h4 id="首先明确两个概念"><a href="#首先明确两个概念" class="headerlink" title="首先明确两个概念"></a>首先明确两个概念</h4><ul><li><strong>基本数据类型</strong>：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。</li><li><strong>引用数据类型</strong>：Array、Object。引用数据类型在该对象在栈中存储的是<strong>引用地址</strong>，指向内存堆中真实的数据。</li></ul><a id="more"></a><!-- build time:Tue Apr 21 2020 09:08:04 GMT+0800 (GMT+08:00) --><p>所以说如果是引用类型数据的新赋值，会影响到原数据。</p><h4 id="深拷贝与浅拷贝的关系"><a href="#深拷贝与浅拷贝的关系" class="headerlink" title="深拷贝与浅拷贝的关系"></a>深拷贝与浅拷贝的关系</h4><ul><li><strong>浅拷贝</strong>：一层拷贝。修改子<strong>引用</strong>数据类型会<strong>影响原有</strong>的数据类型。</li><li><strong>深拷贝</strong>：无限层级拷贝。修改不会影响原有的数据类型。因为指针指向的堆是新开辟的。</li></ul><h3 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  a: <span class="number">1</span>, </span><br><span class="line">  b: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  d: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//(target,...source) 把obj对象赋到空对象 在给copy变量</span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); </span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">copy.a = <span class="number">3</span>;</span><br><span class="line">copy.d = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">copy.b.c = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); </span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>第一层引用类型数据是深拷贝</strong>，对于<strong>第二层及以上</strong>的引用类型数据来说，是<strong>浅拷贝</strong>。</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108123043489.png" alt="image-20200108123043489"></p><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><p>对象的浅拷贝</p><blockquote><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat 方法例子</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array3);</span><br><span class="line"><span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个数组</span></span><br><span class="line"><span class="comment">// 直接执行函数空参数，然后赋值给变量就是浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, &#123;<span class="attr">c</span>: <span class="string">'deep C'</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> copyArr = array.concat()</span><br><span class="line">copyArr[<span class="number">0</span>] = <span class="string">'change A'</span></span><br><span class="line">copyArr[<span class="number">2</span>].c = <span class="string">'change Deep C'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"><span class="comment">// array: [ 'a', 'b', &#123; c: 'change Deep C' &#125; ]  引用类型数据源被改变</span></span><br><span class="line"><span class="built_in">console</span>.log(copyArr)</span><br><span class="line"><span class="comment">// copyArr: [ 'change A', 'b', &#123; c: 'change Deep C' &#125; ]</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108210018080.png" alt="image-20200108210018080"></p><h4 id="Array-prototype-clice"><a href="#Array-prototype-clice" class="headerlink" title="Array.prototype.clice"></a>Array.prototype.clice</h4><p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以说slice传空参数就是浅拷贝</span></span><br><span class="line">animals.clice()</span><br></pre></td></tr></table></figure><h4 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h4><p>此法最简单实用ES6</p><p><code>const objCopy = {...source}</code></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>手写深拷贝，通过判断数组和对象然后 递归+浅拷贝实现</p><h4 id="解决死循环"><a href="#解决死循环" class="headerlink" title="解决死循环"></a>解决死循环</h4><p>这样子循环嵌套，就会进入死循环，使用递归拷贝不会停止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1.a = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj1));</span><br></pre></td></tr></table></figure><p>设置hash表，避免出现重复嵌套的死循环。</p><p>如果hash表中由此值时，直接退出</p><blockquote><p><strong><code>WeakMap</code></strong> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">MDN</a></p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set" target="_blank" rel="noopener">WeakMap.prototype.set()</a></p><hr><h4 id="解决symbol类型"><a href="#解决symbol类型" class="headerlink" title="解决symbol类型"></a>解决symbol类型</h4><p>1.getOwnPropertySymbols</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">    symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">            target[symKey] = cloneDeep(source[symKey], hash); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[symKey] = source[symKey];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Reflect.ownKeys()</p><p>使用这个方法比较简单，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" target="_blank" rel="noopener">MDN</a>返回一个由<strong>目标对象</strong>自身的属性<strong>键</strong>组成的<strong>数组</strong>。</p><p>可以直接返回symbol的键名</p><blockquote><p>可以通过 <code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">&gt; </span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">&gt; toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">&gt; toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">&gt; toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Object.prototype.toString().slice(8,-1)</code>截取掉前面的[object 和 ] 就可以获得数据类型了</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj !== <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">    <span class="comment">// 如果数据存在 hash表里 函数直接退出返回 hash中的数据 避免死循环</span></span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) &#123;</span><br><span class="line">        <span class="comment">// 返回key关联对象, 或者 undefined(没有key关联对象时)。</span></span><br><span class="line">        <span class="keyword">return</span> hash.get(source) </span><br><span class="line">    &#125;<span class="comment">// 查哈希表</span></span><br><span class="line"><span class="comment">// 判断是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [...obj] : &#123;...obj&#125;</span><br><span class="line">    hash.set(source, target) <span class="comment">// 哈希表设值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newObj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决递归爆栈"><a href="#解决递归爆栈" class="headerlink" title="解决递归爆栈"></a>解决递归爆栈</h3><p>简单实现， 各种边界类型还没实现，只能是对象</p><p><strong>具体思路：</strong> 定义一个树的数据结构：有<code>parent</code>父节点，<code>key</code>键名，<code>data</code>键值。循环遍历树的方式：使用栈，开始循环，从栈中取出一个节点，如果是引用类型，推入栈，如果是普通类型直接赋值。直到栈中没有数据，说明全都遍历完了，可以单步调试去看看效果。因为是递归，所以是反着来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span> &amp;&amp; data[k] !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS深浅拷贝&quot;&gt;&lt;a href=&quot;#JS深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;JS深浅拷贝&quot;&gt;&lt;/a&gt;JS深浅拷贝&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要想深入的确实个值得探究的问题&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;首先明确两个概念&quot;&gt;&lt;a href=&quot;#首先明确两个概念&quot; class=&quot;headerlink&quot; title=&quot;首先明确两个概念&quot;&gt;&lt;/a&gt;首先明确两个概念&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;：Array、Object。引用数据类型在该对象在栈中存储的是&lt;strong&gt;引用地址&lt;/strong&gt;，指向内存堆中真实的数据。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
