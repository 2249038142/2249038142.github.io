<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  <subtitle>佳宸学习和分享笔记的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-27T05:02:30.073Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴佳宸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode树 算法基础</title>
    <link href="http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/27/leetcode%E6%A0%91-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-27T05:02:30.073Z</published>
    <updated>2020-02-27T05:02:30.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode树-算法基础"><a href="#leetcode树-算法基础" class="headerlink" title="leetcode树 算法基础"></a>leetcode树 算法基础</h1><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>解：</strong>递归遍历左右子树，每层+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left)</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>解答：</strong>之前理解错了，不是当前节点满足就行，子节点的所有祖先节点都要满足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, pre = null, next = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 先序遍历 以及哪些上下限进行了比较</span></span><br><span class="line">  <span class="comment">// sole.log(root &amp;&amp; root.val, pre &amp;&amp; pre.val, next &amp;&amp; next.val);</span></span><br><span class="line">  <span class="keyword">if</span> (pre &amp;&amp; pre.val &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (next &amp;&amp; next.val &lt;= root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 逻辑判断 递归 如果左边true就是遍历倒底了 则返回右边</span></span><br><span class="line">  <span class="comment">// ！关键递归 如果是左子节点把当前节点作为下限 右子节点把当前节点作为上限 </span></span><br><span class="line">  <span class="keyword">return</span> isValidBST(root.left, pre, root) &amp;&amp; isValidBST(root.right, root, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>解答：还是递归，左右镜像判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空树直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMirror</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两子都为空，返回真</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 有一边为空，则不对称</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> || right ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 条件判断 左边的子左边与右边的子右边相等 </span></span><br><span class="line">    <span class="keyword">return</span> left.val === right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解答： 打印root树仔细查看它的结构，迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length) &#123;</span><br><span class="line">        <span class="comment">// 每层的子节点数</span></span><br><span class="line">        <span class="keyword">let</span> level = queue.length</span><br><span class="line">        <span class="keyword">let</span> current = []</span><br><span class="line">        <span class="keyword">while</span>(level--) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            current.push(node.val)</span><br><span class="line">            <span class="keyword">if</span> (node.left) queue.push(node.left)</span><br><span class="line">            <span class="keyword">if</span> (node.right) queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>解答：要明确两个点，1.二叉搜索树左子树小右子树大，高度要平衡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> middleL = nums.length &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment">// 每次取到中间数</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(nums[middleL])</span><br><span class="line">    <span class="comment">// 递归，左边左树，右边右数</span></span><br><span class="line">    node.left = sortedArrayToBST(nums.slice(<span class="number">0</span>, middleL))</span><br><span class="line">    node.right = sortedArrayToBST(nums.slice(middleL + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>希望能步入学习正轨，看同届前端群的好几位大哥进腾讯阿里提前批就上岸了。自己不能越差越远啊</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode树-算法基础&quot;&gt;&lt;a href=&quot;#leetcode树-算法基础&quot; class=&quot;headerlink&quot; title=&quot;leetcode树 算法基础&quot;&gt;&lt;/a&gt;leetcode树 算法基础&lt;/h1&gt;&lt;h3 id=&quot;二叉树的最大深度&quot;&gt;&lt;a href=&quot;#二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度&quot;&gt;&lt;/a&gt;二叉树的最大深度&lt;/h3&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基础排序算法JS实现</title>
    <link href="http://yoursite.com/2020/02/23/2020-2-15%20%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/"/>
    <id>http://yoursite.com/2020/02/23/2020-2-15%20%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%20194250/</id>
    <published>2020-02-23T10:12:38.689Z</published>
    <updated>2020-02-23T11:16:14.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法JS实现"><a href="#基础排序算法JS实现" class="headerlink" title="基础排序算法JS实现"></a>基础排序算法JS实现</h1><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1</p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>先定义一个交换位置函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr 传入数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; a 要交换的数组下标index</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; b index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[a]</span><br><span class="line">  arr[a] = arr[b]</span><br><span class="line">  arr[b] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与有序的数组进行比较，<strong>比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="comment">// 从第二个开始，把第一个设为初有序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="comment">// 取出当前遍历数组的数</span></span><br><span class="line">    <span class="keyword">let</span> tNum = arr.splice(i, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 从有序数组末尾开始比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">// 比最小的小，直接插入队头</span></span><br><span class="line">      <span class="keyword">if</span>(tNum &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        arr.unshift(tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到个合适的位置插入</span></span><br><span class="line">      <span class="keyword">if</span> (tNum &gt; arr[j]) &#123;</span><br><span class="line">        arr.splice(j+<span class="number">1</span>, <span class="number">0</span>, tNum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到数组中最大的元素，与数组未排序最后一位元素交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有一个数时就不要排序了 -1趟</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">        max = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把最大的放到最后面</span></span><br><span class="line">    swap(arr, max, arr.length<span class="number">-1</span>-i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>选择一个中间节点，小的放左边，大的放右边，不断递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取数组中间下标值</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.splice(arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = [],</span><br><span class="line">    right = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] &lt; middle ? left.push(arr[i]) : right.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quick(left).concat(middle,quick(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分而治之加递归，先把数组递归二分，然后比较合并</p><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="merge-sort-example.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="comment">// 如果数组长度小于二直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="comment">// 取到中间值 同等于 Math.floor(arr.length/2)</span></span><br><span class="line">  <span class="keyword">let</span> middle = arr.length &gt;&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 切出左右两边 （start,end断掉下标前一位)</span></span><br><span class="line">    left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle)</span><br><span class="line">  <span class="comment">// 递归拆分，然后比较，合并比较，这里理解难点，可以动手画一画程序流程</span></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="comment">// 两边数组头项 比较大小</span></span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">// 如果左边小，就把左边数组头项取出，推入新结果</span></span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果左边有右边没有情况下直接推入</span></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift())</span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><a href="https://www.bilibili.com/video/av47196993?from=search&seid=3195181450169677356" target="_blank" rel="noopener">堆排序视频讲解C语言实现</a></p><p>用数组可以表示一个完全二叉树，左子节点<code>2i+1</code>，右子节点<code>2i+2</code></p><blockquote><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从最后一个含有子节点的父节点开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span> &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i, arr.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 堆完成后，每次把对顶最大的数放到末尾</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    <span class="comment">// 交换之后，再规范堆的位置</span></span><br><span class="line">    heapify(arr, <span class="number">0</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arr 数组(堆)</span></span><br><span class="line"><span class="comment"> * i 数组(堆)下标</span></span><br><span class="line"><span class="comment"> * length 数组(堆)长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 完全二叉树,堆函数顺序化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span> (<span class="params">arr, i, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = arr[i]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">    parent = arr[i]</span><br><span class="line">    <span class="comment">// 找到两子节点中较大的一个，再与父节点比较</span></span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent &lt; arr[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点大于子节点:交换；否则跳出</span></span><br><span class="line">      swap(arr, i, j)</span><br><span class="line">      <span class="comment">// 交换后，parent 的值下标变为交换的子节点</span></span><br><span class="line">      i = j</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在家这么久效率有些低，这篇排序还做了这么久，之前数据结构课程也都复习过，疫情快快过去把，想去图书馆里了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法JS实现&quot;&gt;&lt;a href=&quot;#基础排序算法JS实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法JS实现&quot;&gt;&lt;/a&gt;基础排序算法JS实现&lt;/h1&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;前一个元素大于后一个元素就交换位置，最大的值会冒泡到最后，重复循环，每趟过后，比较的次数都要减1&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/02/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-02-15T11:20:10.147Z</published>
    <updated>2020-02-23T10:11:58.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &lt;&lt; 1 // -&gt; 20</span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &gt;&gt; 1 // -&gt; 5</span><br></pre></td></tr></table></figure><p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 <code>a / (2 ^ b)</code></p><h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p><strong>按位与</strong></p><p>每一位都为 1，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 &amp; 7 // -&gt; 0</span><br><span class="line">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>按位或</strong></p><p>其中一位为 1，结果就是 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 | 7 // -&gt; 15</span><br><span class="line">// 1000 | 0111 -&gt; 1111 -&gt; 15</span><br></pre></td></tr></table></figure><p><strong>按位异或</strong></p><p>每一位都不同，结果才为 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8 ^ 7 // -&gt; 15</span><br><span class="line">8 ^ 8 // -&gt; 0</span><br><span class="line">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span><br><span class="line">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><h3 id="两个数不使用四则运算得出和"><a href="#两个数不使用四则运算得出和" class="headerlink" title="两个数不使用四则运算得出和"></a>两个数不使用四则运算得出和</h3><p>通过迭代的方式模拟加法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">    <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;h3 id=&quot;左移-lt-lt&quot;&gt;&lt;a href=&quot;#左移-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移 &amp;lt;&amp;lt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10 &amp;lt;&amp;lt; 1 // -&amp;gt; 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;左移就是将二进制全部往左移动，&lt;code&gt;10&lt;/code&gt; 在二进制中表示为 &lt;code&gt;1010&lt;/code&gt; ，左移一位后变成 &lt;code&gt;10100&lt;/code&gt; ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 &lt;code&gt;a * (2 ^ b)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS的类型转换</title>
    <link href="http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/02/09/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-02-09T10:23:15.266Z</published>
    <updated>2020-02-10T07:44:53.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h1><p>除去 Object 和 Symbol，有如下几种原始类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li></ul><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:55 GMT+0800 (GMT+08:00) --><p>在 JavaScript 进行<strong>对比</strong>或者<strong>各种运算</strong>的时候会把对象转换成这些类型，从而进行后续的操作</p><h3 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h3><ol><li><p><strong>对象</strong>转为<strong>布尔</strong>都为 true</p></li><li><p><strong>对象</strong>转为<strong>字符串</strong>，先<code>toString()</code>方法，如果<strong>未</strong>返回原始类型，再<code>valueOf()</code>方法，再不行就报错</p></li><li><p><strong>对象</strong>转为<strong>数字</strong>，先<code>valueOf()</code>方法，如果<strong>未</strong>返回原始类型，再<code>toString()</code>方法，再不行就报错，反过来的</p></li></ol><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><h4 id="运算规则"><a href="#运算规则" class="headerlink" title="==运算规则"></a>==运算规则</h4><ul><li><p>如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较。</p></li><li><p>如果一个值是<strong>对象</strong>，另一个值是<strong>数字或字符串</strong>，则将<strong>对象转换为原始值</strong>再进行比较。对象通过toString()方法或valueOf()方法转换为原始值。JavaScript语言核心的内置类首<strong>先尝试使用valueOf()，在尝试使用toString()</strong>，除了日期类，日期类只使用toString()方法，那些不是JavaScript语言核心中的对象则通过各自实现中定义的方法转换为原始值。</p></li></ul><h4 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h4><ul><li>toString</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d44d25a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>valueOf</li></ul><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d85b808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>转为boolean类型</li></ul><p>所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true</p><h3 id="运算符类型转化"><a href="#运算符类型转化" class="headerlink" title="+运算符类型转化"></a>+运算符类型转化</h3><p><img src="/images/loading.png" data-original="https://user-gold-cdn.xitu.io/2018/8/7/165124228d0924e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! + [] + [] + ![]</span><br></pre></td></tr></table></figure><ol><li><p>先运算一元运算符， <code>+[]</code>转为Number类型 ，返回0，<code>![]</code>转为Boolean类型 ，!true 返回false.<code>!0+[]+false</code></p></li><li><p><code>true+[]+false</code></p></li><li><p><code>true+&quot;&quot;+false</code>返回<code>&quot;truefalse&quot;</code></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS的类型转换&quot;&gt;&lt;a href=&quot;#JS的类型转换&quot; class=&quot;headerlink&quot; title=&quot;JS的类型转换&quot;&gt;&lt;/a&gt;JS的类型转换&lt;/h1&gt;&lt;p&gt;除去 Object 和 Symbol，有如下几种原始类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Number&lt;/li&gt;&lt;li&gt;String&lt;/li&gt;&lt;li&gt;Boolean&lt;/li&gt;&lt;li&gt;Undefined&lt;/li&gt;&lt;li&gt;Null&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器跨域问题</title>
    <link href="http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-08T03:46:27.582Z</published>
    <updated>2020-02-08T14:10:46.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h1><blockquote><p>处于安全考虑 如果<strong>协议、域名或者端口</strong>有一个不同就是跨域，Ajax 请求会失败。</p></blockquote><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><blockquote><p>利用<code>&lt;script&gt;</code>标签<strong>没有 跨域限制</strong>，<strong>指向</strong>一个需要<strong>访问的地址</strong>并提供一个<strong>回调</strong>函数来<strong>接收数据</strong>。只限于 <code>get</code> 请求。</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>实现jsonp封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="comment">// 约定一个callback字段名，来传递函数名，前端通过该函数来拿到数据</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><blockquote><p>它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服跨域问题，它需要浏览器和服务器的同时支持。</p></blockquote><p>在服务端增加一些<strong>头部属性</strong>就行，客户端浏览器会自动添加origin字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入http库</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="comment">// 字段</span></span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">      <span class="comment">// 允许请求的地址</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">      <span class="comment">// 请求方法</span></span><br><span class="line">      <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET, POST, PUT'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    response.end(<span class="string">'request success!!!'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浏览器跨域问题&quot;&gt;&lt;a href=&quot;#浏览器跨域问题&quot; class=&quot;headerlink&quot; title=&quot;浏览器跨域问题&quot;&gt;&lt;/a&gt;浏览器跨域问题&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;处于安全考虑 如果&lt;strong&gt;协议、域名或者端口&lt;/strong&gt;有一个不同就是跨域，Ajax 请求会失败。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;jsonp&quot;&gt;&lt;a href=&quot;#jsonp&quot; class=&quot;headerlink&quot; title=&quot;jsonp&quot;&gt;&lt;/a&gt;jsonp&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;利用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;strong&gt;没有 跨域限制&lt;/strong&gt;，&lt;strong&gt;指向&lt;/strong&gt;一个需要&lt;strong&gt;访问的地址&lt;/strong&gt;并提供一个&lt;strong&gt;回调&lt;/strong&gt;函数来&lt;strong&gt;接收数据&lt;/strong&gt;。只限于 &lt;code&gt;get&lt;/code&gt; 请求。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>new 和 instanceof</title>
    <link href="http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/"/>
    <id>http://yoursite.com/2020/02/06/new-%E5%92%8C-instanceof/</id>
    <published>2020-02-06T07:06:57.491Z</published>
    <updated>2020-02-06T12:25:35.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-和-instanceof"><a href="#new-和-instanceof" class="headerlink" title="new 和 instanceof"></a>new 和 instanceof</h1><h3 id="new模拟实现"><a href="#new模拟实现" class="headerlink" title="new模拟实现"></a>new模拟实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 取第一个参数构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 把把新对象的原型链 链到 构造函数的原型对象</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定this 实现继承 ， obj可以访问到构造函数的属性</span></span><br><span class="line">  Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 到链的顶端 null 还没找到，就说明没有继承关系 </span></span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 右边的原型对象 等于左边的_PROTO_ 就说明是继承关系</span></span><br><span class="line">    <span class="keyword">if</span> (right.prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 原型链深入</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;new-和-instanceof&quot;&gt;&lt;a href=&quot;#new-和-instanceof&quot; class=&quot;headerlink&quot; title=&quot;new 和 instanceof&quot;&gt;&lt;/a&gt;new 和 instanceof&lt;/h1&gt;&lt;h3 id=&quot;new模拟实现&quot;&gt;&lt;a href=&quot;#new模拟实现&quot; class=&quot;headerlink&quot; title=&quot;new模拟实现&quot;&gt;&lt;/a&gt;new模拟实现&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myNew&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 创建一个空对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 取第一个参数构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; Con = [].shift.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 把把新对象的原型链 链到 构造函数的原型对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  obj.__proto__ = Con.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 绑定this 实现继承 ， obj可以访问到构造函数的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Con.apply(obj, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小程序云开发学习入门</title>
    <link href="http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-04T07:07:48.754Z</published>
    <updated>2020-02-06T12:43:28.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序云开发学习"><a href="#小程序云开发学习" class="headerlink" title="小程序云开发学习"></a>小程序云开发学习</h1><blockquote><p>朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><h3 id="开始创建"><a href="#开始创建" class="headerlink" title="开始创建"></a>开始创建</h3><p>使用小程序开发者工具，创建新项目，点击云开发</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202214400410.png" alt="image-20200202214400410"></p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>右击创建login函数</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202215513556.png" alt="image-20200202215513556"></p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>点击上传图片，在云开发控制台，可以看到</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202220032800.png" alt="image-20200202220032800"></p><h3 id="前端操作数据库"><a href="#前端操作数据库" class="headerlink" title="前端操作数据库"></a>前端操作数据库</h3><p>先在云开发里创建一个集合，然后找到databaseGuide文件，取消onAdd函数的注释，</p><p>点击左侧新增记录，就会有显示，<strong>注意数据库名称要跟函数对的上</strong></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221042328.png" alt="image-20200202221042328"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/cloud/image-20200202221321531.png" alt="image-20200202221321531"></p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>最后还是没有参加此次黑客马拉松，第一云开发才刚刚有做了解，并没有相关经验，并且在群里组队失败。没有队友。自己一个人两天肯定无法完成任务，所以放弃了。😵</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小程序云开发学习&quot;&gt;&lt;a href=&quot;#小程序云开发学习&quot; class=&quot;headerlink&quot; title=&quot;小程序云开发学习&quot;&gt;&lt;/a&gt;小程序云开发学习&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;朋友圈看到了迷渡大哥说当这次小程序云开发的评委。疫情这么严重，在家闲的慌，想参加一下这个黑客马拉松，刺激一下自己&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现call,apply,bind函数</title>
    <link href="http://yoursite.com/2020/01/23/2020-1-20%20%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/"/>
    <id>http://yoursite.com/2020/01/23/2020-1-20%20%E5%AE%9E%E7%8E%B0call,apply,bind%E5%87%BD%E6%95%B0%20150429/</id>
    <published>2020-01-23T08:55:50.382Z</published>
    <updated>2020-01-30T04:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现call-apply-bind函数"><a href="#实现call-apply-bind函数" class="headerlink" title="实现call,apply,bind函数"></a>实现call,apply,bind函数</h1><ul><li>如果第一个参数为null ，则指向window</li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><h3 id="复习this指向"><a href="#复习this指向" class="headerlink" title="复习this指向"></a>复习this指向</h3><p><strong>this永远指向最后一个调用这个方法的对象</strong></p><p>回顾<strong>隐式绑定</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'Jason'</span>,</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//obj</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Jason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure><p>记住这个用法，他们用这个实现</p><h3 id="实现call-apply"><a href="#实现call-apply" class="headerlink" title="实现call,apply"></a>实现call,apply</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (context) this指向的对象 (...args) 扩展运算 传入参数， (args)就是apply </span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变this指向如果不传的话默认上下文为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  args = args ? args : []</span><br><span class="line">  <span class="comment">// 定义一个唯一值</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">  <span class="comment">// 把这个函数的this 写到call 对象的一个属性里</span></span><br><span class="line">  context[key] = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 通过“对象.方法（参数）”，可以把this指向对象</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">  <span class="comment">// 删除对象添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> context[key]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h3><p>bind返回一个绑定好的函数，不会立即执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">this</span></span><br><span class="line">    args = args ? args : []</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是new的就返回new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> fn(...args, ...newFnArgs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个apply方法</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, [...args,...newFnArgs])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现call-apply-bind函数&quot;&gt;&lt;a href=&quot;#实现call-apply-bind函数&quot; class=&quot;headerlink&quot; title=&quot;实现call,apply,bind函数&quot;&gt;&lt;/a&gt;实现call,apply,bind函数&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;如果第一个参数为null ，则指向window&lt;/li&gt;&lt;li&gt;改变了 &lt;code&gt;this&lt;/code&gt; 指向，让新的对象可以执行该函数，并能接受参数&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实现promise A+</title>
    <link href="http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/"/>
    <id>http://yoursite.com/2020/01/20/%E5%AE%9E%E7%8E%B0promise%20A+/</id>
    <published>2020-01-20T03:56:40.251Z</published>
    <updated>2020-01-20T04:05:06.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现promise-A"><a href="#实现promise-A" class="headerlink" title="实现promise A+"></a>实现promise A+</h1><blockquote><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">promiseA+规范</a>，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise的三个状态，pending =&gt; resolved or =&gt; reject, 不可逆</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个fn执行器,在try中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止this变向</span></span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 设开始状态为pending</span></span><br><span class="line">  that.state = PENDING</span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 reject 中传入参数的值</span></span><br><span class="line">  that.value = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 保存then中的回调</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  <span class="comment">// 失败的回调</span></span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入的值是否为 Promise 类型</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证异步执行顺序</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 改pending状态为 resolve</span></span><br><span class="line">        that.state = RESOLVED</span><br><span class="line">        <span class="comment">// 将传入的值赋值给 value</span></span><br><span class="line">        that.value = value</span><br><span class="line">        <span class="comment">// 遍历回调执行数组</span></span><br><span class="line">        that.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同resolve</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">        that.state = REJECTED</span><br><span class="line">        that.value = value</span><br><span class="line">        that.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(that.value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  <span class="comment">// 解决没有传值的问题，当参数不是函数类型时，需要创建一个函数赋值给对应的参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 返回一个新的 promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 往回调数组中 push 函数</span></span><br><span class="line">      that.resolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行函数中可能 报错 ，try catch 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      that.rejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//因为穿透值的缘故，在默认的跑出一个error后，不能再用下一个的reject来接受，只能通过try，catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(that.value)</span><br><span class="line">          <span class="comment">//递归 判断他们是否为promise对象</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    <span class="comment">// onRejected(that.value)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> MyPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是null ，是 对象 或 函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="comment">// called用于判断是否已经调用过函数</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> x.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数 x 作为this指向</span></span><br><span class="line">        x.then.call(</span><br><span class="line">          x,</span><br><span class="line">          success =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果调用过 就直接返回了</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 递归调用 .then 中是否还有子 promise</span></span><br><span class="line">            resolutionProcedure(promise2, success, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 错误直接返回</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象或函数将 x 传入resolve</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现promise-A&quot;&gt;&lt;a href=&quot;#实现promise-A&quot; class=&quot;headerlink&quot; title=&quot;实现promise A+&quot;&gt;&lt;/a&gt;实现promise A+&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;promiseA+规范&lt;/a&gt;，研究了两天，看了几篇解析文章，跟着敲出来的，要是凭空自己写估计水平还没到，下面有我的解释&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数组方法整理</title>
    <link href="http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-01-18T04:00:08.392Z</published>
    <updated>2020-01-19T08:15:41.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组方法整理"><a href="#数组方法整理" class="headerlink" title="数组方法整理"></a>数组方法整理</h1><blockquote><p>要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下</p></blockquote><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><blockquote><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">mdn</a></p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p><strong>不会返回执行结果</strong>，返回的是<code>undefined</code>，也就是说，<code>forEach()</code><strong>会修改原来的数组</strong>，中途<strong>不能</strong>用常规操作<strong>跳出循环</strong>，不支持<strong>链式</strong>操作，forEach之前可以链式</p><p>当数组中元素是<strong>值</strong>类型，forEach<strong>不会改变</strong>数组；当是<strong>引用</strong>类型，则<strong>可以改变</strong>数组</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><blockquote><p><code>map()</code> 方法创建一个<strong>新数组</strong>，其结果是该数组中的每个元素都调用一个提供的函数后<strong>返回的结果</strong>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">mdn</a></p></blockquote><p><code>map()</code>方法会得到一个<strong>新的数组</strong>并返回。速度更快，必须要有return。</p><hr><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><blockquote><p><code>filter()</code> 方法创建一个<strong>新数组</strong>，其包含<strong>通过</strong>所提供函数实现的<strong>测试</strong>的所有元素。</p></blockquote><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><blockquote><p><code>sort()</code> 方法用<a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">原地算法</a>对数组的元素进行排序，并返回数组。默认按Unicode升序</p></blockquote><p><strong>它直接改变原始数组</strong></p><p>要比较数字而非字符串，比较函数可以简单的以 <strong>a 减 b</strong>，如下的函数将会将数组<strong>升序</strong>排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]; </span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><blockquote><p><code>some()</code> 方法测试数组中是不是至少有<strong>1个元素通过</strong>了被提供的函数测试。它返回的是一个Boolean类型的值。</p></blockquote><p>只要有一个满足即返回true，之后的不再执行</p><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><blockquote><p><code>every()</code> 方法测试一个数组内的所有元素是否<strong>都</strong>能通过某个指定函数的测试。它返回一个布尔值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'cecilia'</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;</span><br><span class="line">].every(<span class="function"><span class="params">item</span> =&gt;</span> item.age &gt; <span class="number">19</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><blockquote><p><code>find()</code> 方法返回数组中<strong>满足提供的测试函数</strong>的<strong>第一个</strong>元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>。</p></blockquote><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的<strong>第一个</strong>元素的<strong>索引</strong>。否则返回-1。</p><hr><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><blockquote><p>对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p></blockquote><ul><li>accumulator 累计器</li><li>currentValue 当前值</li><li>currentIndex 当前索引(可选)</li><li>array 数组（可选）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr );</span><br></pre></td></tr></table></figure><p>如果你打算提供一个初始值作为<code>reduce()</code>方法的第二个参数，以下是运行过程及结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue; &#125;, 10 );</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><code>callback</code></th><th align="left"><code>accumulator</code></th><th align="left"><code>currentValue</code></th><th align="left"><code>currentIndex</code></th><th align="left"><code>array</code></th><th align="left">return value</th></tr></thead><tbody><tr><td align="left">first call</td><td align="left"><code>10</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>10</code></td></tr><tr><td align="left">second call</td><td align="left"><code>10</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>11</code></td></tr><tr><td align="left">third call</td><td align="left"><code>11</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>13</code></td></tr><tr><td align="left">fourth call</td><td align="left"><code>13</code></td><td align="left"><code>3</code></td><td align="left"><code>3</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>16</code></td></tr><tr><td align="left">fifth call</td><td align="left"><code>16</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>20</code></td></tr></tbody></table><p>这种情况下<code>reduce()</code>返回的值是<code>20</code>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组方法整理&quot;&gt;&lt;a href=&quot;#数组方法整理&quot; class=&quot;headerlink&quot; title=&quot;数组方法整理&quot;&gt;&lt;/a&gt;数组方法整理&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要操作数据的时候，数组一堆方法把我搞混沌了，每次都要查一下资料，干脆整理一下&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;forEach&quot;&gt;&lt;a href=&quot;#forEach&quot; class=&quot;headerlink&quot; title=&quot;forEach()&quot;&gt;&lt;/a&gt;forEach()&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;forEach()&lt;/code&gt; 方法对数组的每个元素执行一次提供的函数。&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mdn&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何实现JS继承</title>
    <link href="http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/01/16/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JS%E7%BB%A7%E6%89%BF/</id>
    <published>2020-01-16T08:45:25.951Z</published>
    <updated>2020-01-17T00:39:27.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现JS继承"><a href="#如何实现JS继承" class="headerlink" title="如何实现JS继承"></a>如何实现JS继承</h1><blockquote><p>JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。</p></blockquote><p>es6之前是不支持接口直接继承的，所以就需要手动实现继承</p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>通过这个图先熟悉一下JS内部，constructor和prototype和实例的关系</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200115231115613.png" alt="image-20200115231115613"></p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure><p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p><p>问题二: 在创建子类型(例如创建Child的实例)时,不能向父类型(例如Parent)的构造函数中传递参数.</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题一：父类中定义的方法,对子类型而言也是不可见的</p><p>问题二：方法都在构造函数中定义, 因此函数复用也就不可用了</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用<strong>原型链</strong>实现对原型<strong>属性和方法</strong>的继承,通过借用<strong>构造函数</strong>来实现对<strong>实例属性</strong>的继承.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>缺点：调用了两次父类构造函数, 造成了不必要的消耗</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p><strong><code>Object.create()</code></strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// call只能继承属性，不能继承方法</span></span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把父的实例化对象，赋值给 child的原型对象</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.creat(Parent.prototype)</span><br><span class="line"><span class="comment">// 将子原型对象的构造函数指回来</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child)</span><br></pre></td></tr></table></figure><p>如果你希望能继承到多个对象，则可以使用混入的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="ES6-class继承"><a href="#ES6-class继承" class="headerlink" title="ES6 class继承"></a>ES6 class继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  extends 表明继承自哪个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何实现JS继承&quot;&gt;&lt;a href=&quot;#如何实现JS继承&quot; class=&quot;headerlink&quot; title=&quot;如何实现JS继承&quot;&gt;&lt;/a&gt;如何实现JS继承&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;JS是通过链式继承的，ES6的继承实际是语法糖。自己手动实现一下继承加深印象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;es6之前是不支持接口直接继承的，所以就需要手动实现继承&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖节流手写</title>
    <link href="http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/15/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-01-15T13:26:06.434Z</published>
    <updated>2020-02-06T12:30:49.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><blockquote><p>这两个应用场景很多，自己手写一下，可以解决服务器压力</p></blockquote><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</strong></p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>场景：用户输入停止一段时间过后再去获取数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"debounce"</span>&gt;</span>防抖按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myDebounce = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>)</span></span><br><span class="line"><span class="actionscript">      myDebounce.addEventListener(<span class="string">'click'</span>, debounce(sayDebounce, <span class="number">1000</span>))</span></span><br><span class="line">    </span><br><span class="line">      /**</span><br><span class="line">       * 防抖功能函数</span><br><span class="line">       * fn 要防抖的功能函数</span><br><span class="line">       * delay 延迟多久，毫秒</span><br><span class="line">       **/</span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> <span class="params">(fn, delay, immediate)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包，创建一个标记用来存放定时器的返回值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeout = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 触发事件回调时执行这个 teturn function</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 每次当用户点击/输入的时候，把前一个定时器清除</span></span></span><br><span class="line">          if(timeout) clearTimeout(timeout)</span><br><span class="line">           </span><br><span class="line"><span class="actionscript">          <span class="comment">// immediate true 首次触发执行</span></span></span><br><span class="line">          if(immediate &amp;&amp; !timer) &#123;</span><br><span class="line"><span class="javascript">              fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line"><span class="actionscript">          <span class="comment">// 创建一个新的 setTimeout，</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 这样就能保证点击按钮后的间隔内,如果用户还点击了的话，就不会执行 fn 函数</span></span></span><br><span class="line"><span class="javascript">          timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 以防需要防抖的事件this指向被改变 绑定一下this指向</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 需要防抖的事件 形参 用argument 绑进来</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 定时器结束后传入 fn函数 </span></span></span><br><span class="line"><span class="javascript">            fn.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要防抖的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayDebounce</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'防抖成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>减少一段时间内触发的频率。</strong></p><ul><li>方法一：设置flag 执行前flag flase 在定时器内节流时间执行后 设回 true</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"throttle"</span>&gt;</span>点击节流<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myThrottle = <span class="built_in">document</span>.getElementById(<span class="string">'throttle'</span>)</span></span><br><span class="line"><span class="actionscript">      myThrottle.addEventListener(<span class="string">'click'</span>, throttle(sayThrottle, <span class="number">1000</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 节流函数体</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> <span class="params">(fn, delay)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 通过闭包保存一个标记</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// flag为false 说明还在节流时间中 退出函数</span></span></span><br><span class="line">          if (!flag) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span></span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 将 flag 设置为 false，防止执行之前再被执行</span></span></span><br><span class="line"><span class="actionscript">          flag = <span class="literal">false</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="javascript">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span></span></span><br><span class="line"><span class="actionscript">            flag = <span class="literal">true</span></span></span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 需要节流的事件</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">sayThrottle</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'节流成功！'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方法二：时间戳来判断是否已到执行时间。与上次函数执行的时间比较，大于节流时间就放行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用闭包保存，上一次执行 fn 的时间 </span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">        <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            previous = now</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖加节流"><a href="#防抖加节流" class="headerlink" title="防抖加节流"></a>防抖加节流</h3><p>节流里面包防抖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要节流处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// previous 是上一次执行 fn 的时间</span></span><br><span class="line">  <span class="comment">// timer 是定时器</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ 新增部分 start ------ </span></span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &lt; wait) &#123;</span><br><span class="line">     <span class="comment">// 如果小于，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       <span class="comment">// 定时器时间结束后执行函数 fn </span></span><br><span class="line">       <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          previous = now</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    <span class="comment">// ------ 新增部分 end ------ </span></span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 第一次执行</span></span><br><span class="line">       <span class="comment">// 或者时间间隔超出了设定的时间间隔，执行函数 fn</span></span><br><span class="line">       previous = now</span><br><span class="line">       fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn 节流执行了'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 第一次触发 scroll 执行一次 fn，每隔 1 秒后执行一次函数 fn，停止滑动 1 秒后再执行函数 fn</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterFn)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;防抖节流&quot;&gt;&lt;a href=&quot;#防抖节流&quot; class=&quot;headerlink&quot; title=&quot;防抖节流&quot;&gt;&lt;/a&gt;防抖节流&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;这两个应用场景很多，自己手写一下，可以解决服务器压力&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾佬700元装了台主流配置电脑</title>
    <link href="http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/"/>
    <id>http://yoursite.com/2020/01/13/%E5%9E%83%E5%9C%BE%E4%BD%AC700%E5%85%83%E8%A3%85%E4%BA%86%E5%8F%B0%E4%B8%BB%E6%B5%81%E9%85%8D%E7%BD%AE%E7%94%B5%E8%84%91/</id>
    <published>2020-01-13T08:58:09.874Z</published>
    <updated>2020-01-15T03:23:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="700元垃圾佬主机大升级"><a href="#700元垃圾佬主机大升级" class="headerlink" title="700元垃圾佬主机大升级"></a>700元垃圾佬主机大升级</h1><blockquote><p>事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>京东双十二买的酷兽 当时199 <strong>16G 2666MHz</strong> 的内存，用了个199 -15 的全品类券 ，白菜价<strong>184</strong>到手，单面2G*8颗粒组成16G容量，镁光颗粒。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/RAM2.jpg" alt="RAM2"><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/QK@@34LQC(W%7B)I@%7B%7DUIVT2.jpg" alt="img"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>最终选定一代锐龙，R5-1400 四核-八线程 基础频率3.2GHz。便宜就完事，全新带散热器淘宝只要350左右，其实9月就到这价格了，已经没有降价空间了。为了追求更便宜，买了咸鱼二手，cpu这种东西用不坏的，所以二手也稳。这块cpu也能稳定超频。唯一缺陷就是没有核心显卡，还得另外配，没显卡还是建议速龙3000G(APU).</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113114601686.png" alt="image-20200113114601686"></p><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>映泰tb350-etc，全新矿板，可装六张显卡，支持AM4处理器，7相供电，很稳定，矿难清库存还剩点，230入手。唯一的缺点就是，不支持MVME接口，只能装sata固态。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120344918.png" alt="image-20200113120344918"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113120905439.png" alt="image-20200113120905439"></p><h3 id="硅脂"><a href="#硅脂" class="headerlink" title="硅脂"></a>硅脂</h3><p>淘宝特价版，5元红包，1.9元入手 ，看过一个测试硅脂的话，涂X形状就行，刮刀就往一边刮。<img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122109279.png" alt="image-20200113122109279"></p><hr><h3 id="总价"><a href="#总价" class="headerlink" title="总价"></a>总价</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113122402817.png" alt="image-20200113122402817"></p><h3 id="不要钱系列"><a href="#不要钱系列" class="headerlink" title="不要钱系列"></a>不要钱系列</h3><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>表哥有个闲置显卡，七彩虹GTX650，送给我了。玩玩普通网游还是无压力的。费米之后的开普勒架构很大程度上改善了高功耗、高发热问题。这里感谢翔哥。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113123036484.png" alt="image-20200113123036484"></p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>朗科480G固态，老爹闲置的固态。速度不快，但是够用，读写速度加上十秒开机。爽歪歪。</p><h4 id="机箱，机械硬盘，电源"><a href="#机箱，机械硬盘，电源" class="headerlink" title="机箱，机械硬盘，电源"></a>机箱，机械硬盘，电源</h4><p>全是祖传的</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163203557.png" alt="image-20200113163203557"></p><hr><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h3><ul><li>*<em>I tell you *</em>里面下载win10 企业版</li><li>一个大于8G U盘 ，格式化后 用 UltraISO 把系统搞到U盘</li><li>在BIOS里，设置U盘优先启动</li><li>Win 10激活 傻瓜式破解 链接: <a href="https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GxG_EnLyXRaebHruYld1YA</a> 提取码: 3fff （仅用于个人学习，商业用途概不负责）</li></ul><h3 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h3><p>下载的是win10企业版比较纯净。纯净到什么都没有。。。计算器，win商店都没有</p><p>win商店下载，进入商店之后edge浏览器等软件下载</p><p>链接: <a href="https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1fzIsGZkepya02Tb42PsPKw</a> 提取码: tia9</p><p>解压：<strong>bandzip</strong></p><p>杀毒：<strong>火绒</strong>，关闭垃圾软件广告弹窗</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kbtool.cn/" target="_blank" rel="noopener">EX-DIY工具箱 卡硬工具箱 （原：卡吧工具箱）</a>，一个集合型工具，汇总了几大常用检测软件。</p><h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p>基础的超频很简单，直接在bios里面，调频率就行了。一般超个10%很稳定的，再往上超就需要调节电压了。新手建议不加电压以免烧坏。就一步一步一点点加，加到黑屏的话直接扣下主板电池，主板就会恢复出厂设置。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113163312898.png" alt="image-20200113163312898"></p><h4 id="cpu超频"><a href="#cpu超频" class="headerlink" title="cpu超频"></a>cpu超频</h4><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161954488.png" alt="image-20200113161954488"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113161924106.png" alt="image-20200113161924106"></p><p>轻松超到3.7GHz，家里用就不继续超了，功耗会增加</p><h4 id="内存超频"><a href="#内存超频" class="headerlink" title="内存超频"></a>内存超频</h4><p>轻松超到2933MHz，等有钱了配个双通道32G 内存。再往上走，得调降低搬运时序了。</p><h4 id="显卡超频"><a href="#显卡超频" class="headerlink" title="显卡超频"></a>显卡超频</h4><p>NVIDIA Inspector是一款N卡专用的检测/超频软件，不但像GPU-Z一样可以检测显卡的各种信息，还能对显卡的频率、风扇转速甚至电压进行调节，十分实用。核心频率超100MHz和显存频率超200MHz，最后面的电压也不建议调，容易烧。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/L4CL2D%7D%5BJ_B5VSZ%7D%60%5BLDS45.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装机，重点是过程和玩，淘宝垃圾的过程，装机的过程。挺好玩的。总的来说这次700元装出3000元的逼了。</p><hr><h3 id="番外篇：晒好价外设"><a href="#番外篇：晒好价外设" class="headerlink" title="番外篇：晒好价外设"></a>番外篇：晒好价外设</h3><h4 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h4><p>酷冷至尊 k370 红轴，此款键盘的特点是 cherry原厂红轴，全键无冲，BPT键帽不易打油，有卫星轴，很重底层有钢板，预留灯位，想想一个红轴的单价都是2块，算算光轴的钱就超200了，199内还要啥自行车。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113164616416.png" alt="image-20200113164616416"></p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/PC/image-20200113165124122.png" alt="image-20200113165124122"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;a href=&quot;#700元垃圾佬主机大升级&quot; class=&quot;headerlink&quot; title=&quot;700元垃圾佬主机大升级&quot;&gt;&lt;/a&gt;700元垃圾佬主机大升级&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;事情从我买了根16G内存开始，买了内存没地方用，干脆配一台机器好罗。正好家里电脑很卡，老古董，最终组装成一般网游，影音无压力的家用台式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Js深浅拷贝</title>
    <link href="http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/01/11/Js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-01-11T05:08:11.772Z</published>
    <updated>2020-01-13T02:01:46.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS深浅拷贝"><a href="#JS深浅拷贝" class="headerlink" title="JS深浅拷贝"></a>JS深浅拷贝</h1><blockquote><p>要想深入的确实个值得探究的问题</p></blockquote><h4 id="首先明确两个概念"><a href="#首先明确两个概念" class="headerlink" title="首先明确两个概念"></a>首先明确两个概念</h4><ul><li><strong>基本数据类型</strong>：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。</li><li><strong>引用数据类型</strong>：Array、Object。引用数据类型在该对象在栈中存储的是<strong>引用地址</strong>，指向内存堆中真实的数据。</li></ul><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>所以说如果是引用类型数据的新赋值，会影响到原数据。</p><h4 id="深拷贝与浅拷贝的关系"><a href="#深拷贝与浅拷贝的关系" class="headerlink" title="深拷贝与浅拷贝的关系"></a>深拷贝与浅拷贝的关系</h4><ul><li><strong>浅拷贝</strong>：一层拷贝。修改子<strong>引用</strong>数据类型会<strong>影响原有</strong>的数据类型。</li><li><strong>深拷贝</strong>：无限层级拷贝。修改不会影响原有的数据类型。因为指针指向的堆是新开辟的。</li></ul><h3 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  a: <span class="number">1</span>, </span><br><span class="line">  b: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  d: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//(target,...source) 把obj对象赋到空对象 在给copy变量</span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); </span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">copy.a = <span class="number">3</span>;</span><br><span class="line">copy.d = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">copy.b.c = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); </span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>第一层引用类型数据是深拷贝</strong>，对于<strong>第二层及以上</strong>的引用类型数据来说，是<strong>浅拷贝</strong>。</p><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108123043489.png" alt="image-20200108123043489"></p><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><p>对象的浅拷贝</p><blockquote><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">MDN</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat 方法例子</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.concat(array2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array3);</span><br><span class="line"><span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个数组</span></span><br><span class="line"><span class="comment">// 直接执行函数空参数，然后赋值给变量就是浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, &#123;<span class="attr">c</span>: <span class="string">'deep C'</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> copyArr = array.concat()</span><br><span class="line">copyArr[<span class="number">0</span>] = <span class="string">'change A'</span></span><br><span class="line">copyArr[<span class="number">2</span>].c = <span class="string">'change Deep C'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"><span class="comment">// array: [ 'a', 'b', &#123; c: 'change Deep C' &#125; ]  引用类型数据源被改变</span></span><br><span class="line"><span class="built_in">console</span>.log(copyArr)</span><br><span class="line"><span class="comment">// copyArr: [ 'change A', 'b', &#123; c: 'change Deep C' &#125; ]</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Cimage-20200108210018080.png" alt="image-20200108210018080"></p><h4 id="Array-prototype-clice"><a href="#Array-prototype-clice" class="headerlink" title="Array.prototype.clice"></a>Array.prototype.clice</h4><p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以说slice传空参数就是浅拷贝</span></span><br><span class="line">animals.clice()</span><br></pre></td></tr></table></figure><h4 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h4><p>此法最简单实用ES6</p><p><code>const objCopy = {...source}</code></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>手写深拷贝，通过判断数组和对象然后 递归+浅拷贝实现</p><h4 id="解决死循环"><a href="#解决死循环" class="headerlink" title="解决死循环"></a>解决死循环</h4><p>这样子循环嵌套，就会进入死循环，使用递归拷贝不会停止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1.a = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj1));</span><br></pre></td></tr></table></figure><p>设置hash表，避免出现重复嵌套的死循环。</p><p>如果hash表中由此值时，直接退出</p><blockquote><p><strong><code>WeakMap</code></strong> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">MDN</a></p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set" target="_blank" rel="noopener">WeakMap.prototype.set()</a></p><hr><h4 id="解决symbol类型"><a href="#解决symbol类型" class="headerlink" title="解决symbol类型"></a>解决symbol类型</h4><p>1.getOwnPropertySymbols</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">    symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">            target[symKey] = cloneDeep(source[symKey], hash); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[symKey] = source[symKey];</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Reflect.ownKeys()</p><p>使用这个方法比较简单，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" target="_blank" rel="noopener">MDN</a>返回一个由<strong>目标对象</strong>自身的属性<strong>键</strong>组成的<strong>数组</strong>。</p><p>可以直接返回symbol的键名</p><blockquote><p>可以通过 <code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">&gt; </span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">&gt; toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">&gt; toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">&gt; toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">&gt; toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>Object.prototype.toString().slice(8,-1)</code>截取掉前面的[object 和 ] 就可以获得数据类型了</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj !== <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">    <span class="comment">// 如果数据存在 hash表里 函数直接退出返回 hash中的数据 避免死循环</span></span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) &#123;</span><br><span class="line">        <span class="comment">// 返回key关联对象, 或者 undefined(没有key关联对象时)。</span></span><br><span class="line">        <span class="keyword">return</span> hash.get(source) </span><br><span class="line">    &#125;<span class="comment">// 查哈希表</span></span><br><span class="line"><span class="comment">// 判断是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [...obj] : &#123;...obj&#125;</span><br><span class="line">    hash.set(source, target) <span class="comment">// 哈希表设值</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newObj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决递归爆栈"><a href="#解决递归爆栈" class="headerlink" title="解决递归爆栈"></a>解决递归爆栈</h3><p>简单实现， 各种边界类型还没实现，只能是对象</p><p><strong>具体思路：</strong> 定义一个树的数据结构：有<code>parent</code>父节点，<code>key</code>键名，<code>data</code>键值。循环遍历树的方式：使用栈，开始循环，从栈中取出一个节点，如果是引用类型，推入栈，如果是普通类型直接赋值。直到栈中没有数据，说明全都遍历完了，可以单步调试去看看效果。因为是递归，所以是反着来的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span> &amp;&amp; data[k] !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS深浅拷贝&quot;&gt;&lt;a href=&quot;#JS深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;JS深浅拷贝&quot;&gt;&lt;/a&gt;JS深浅拷贝&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;要想深入的确实个值得探究的问题&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;首先明确两个概念&quot;&gt;&lt;a href=&quot;#首先明确两个概念&quot; class=&quot;headerlink&quot; title=&quot;首先明确两个概念&quot;&gt;&lt;/a&gt;首先明确两个概念&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;：String、Number、Boolean、Null、Undefined、Symbol。基本数据类型是直接存储在栈中的数据。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;：Array、Object。引用数据类型在该对象在栈中存储的是&lt;strong&gt;引用地址&lt;/strong&gt;，指向内存堆中真实的数据。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数美科技笔试题</title>
    <link href="http://yoursite.com/2020/01/09/%E6%95%B0%E7%BE%8E%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/01/09/%E6%95%B0%E7%BE%8E%E7%A7%91%E6%8A%80%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2020-01-09T13:02:36.953Z</published>
    <updated>2020-01-16T08:53:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数美科技笔试题"><a href="#数美科技笔试题" class="headerlink" title="数美科技笔试题"></a>数美科技笔试题</h1><table><thead><tr><th>逻辑运算</th><th>实例</th><th>解释</th></tr></thead><tbody><tr><td>逻辑与，AND（<code>&amp;&amp;</code>）</td><td><code>expr1 &amp;&amp; expr2</code></td><td>若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr2</code>；否则，返回 <code>expr1</code>。</td></tr><tr><td>逻辑或，OR（`</td><td></td><td>`）</td></tr></tbody></table><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.val = <span class="number">1</span> <span class="comment">//全局 val 为 1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">  val: <span class="number">10</span>,</span><br><span class="line">  dbl: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.dbl() <span class="comment">// json.val 为 20 ，this指向调用对象json</span></span><br><span class="line"><span class="keyword">var</span> dbl = json.dbl</span><br><span class="line">dbl() <span class="comment">// window.val 为 2 ， 赋值传递丢失绑定对象 this指向全局</span></span><br><span class="line">json.dbl.call(<span class="built_in">window</span>) <span class="comment">// window.val 为 4 ，ceindwall使this指向 window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.val + json.val) <span class="comment">// 4 + 20 = 24</span></span><br></pre></td></tr></table></figure><hr><h3 id="JS执行顺序问题"><a href="#JS执行顺序问题" class="headerlink" title="JS执行顺序问题"></a>JS执行顺序问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Shumei'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'SM'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">JS编译过程是这样的：</span><br><span class="line">先是声明变量不赋值 <span class="keyword">var</span> name;</span><br><span class="line">然后执行自执行函数 </span><br><span class="line">再name = <span class="string">'shumei'</span></span><br><span class="line"></span><br><span class="line">所以函数执行的时候 变量只声明 但是未赋值</span><br><span class="line">输出： helloSM</span><br></pre></td></tr></table></figure><hr><h3 id="数据类型原理问题"><a href="#数据类型原理问题" class="headerlink" title="数据类型原理问题"></a>数据类型原理问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> a2 = a1</span><br><span class="line">a1[<span class="number">0</span>] = a2[<span class="number">1</span>]</span><br><span class="line">a2.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1)</span><br><span class="line"><span class="built_in">console</span>.log(a2)</span><br><span class="line"></span><br><span class="line">数组是引用数据类型，引用数据类型在该对象在栈中存储的是引用地址，指向内存堆中真实的数据。</span><br><span class="line">所以说如果是引用类型数据的新赋值，会影响到原数据。</span><br><span class="line">输出：</span><br><span class="line">[ <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">[ <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure><hr><h3 id="JS继承问题"><a href="#JS继承问题" class="headerlink" title="JS继承问题"></a>JS继承问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">if</span>(age != <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype = &#123;</span><br><span class="line">    name: <span class="string">'SM'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);  <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.constructor);  <span class="comment">// [Function: object]</span></span><br></pre></td></tr></table></figure><hr><h3 id="双等转化问题"><a href="#双等转化问题" class="headerlink" title="双等转化问题"></a>双等转化问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"false"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log([] == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false </span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h3 id="JS异步同步问题"><a href="#JS异步同步问题" class="headerlink" title="JS异步同步问题"></a>JS异步同步问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; <span class="comment">// 这里不是逗号</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  i == <span class="number">1</span> &amp;&amp; resolve(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>答案及解释：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">涉及异步同步，宏任务微任务</span><br><span class="line">先执行JS引擎线程全局宏任务 输出 <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line">然后执行 清空微任务 then 后的 输出 <span class="number">4</span> </span><br><span class="line">再执行宏任务 定时器线程执行完 然后回调到事件队列 输出 <span class="number">1</span> </span><br><span class="line">输出：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数美科技笔试题&quot;&gt;&lt;a href=&quot;#数美科技笔试题&quot; class=&quot;headerlink&quot; title=&quot;数美科技笔试题&quot;&gt;&lt;/a&gt;数美科技笔试题&lt;/h1&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;逻辑运算&lt;/th&gt;&lt;th&gt;实例&lt;/th&gt;&lt;th&gt;解释&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;逻辑与，AND（&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;）&lt;/td&gt;&lt;td&gt;&lt;code&gt;expr1 &amp;amp;&amp;amp; expr2&lt;/code&gt;&lt;/td&gt;&lt;td&gt;若 &lt;code&gt;expr1&lt;/code&gt; 可转换为 &lt;code&gt;true&lt;/code&gt;，则返回 &lt;code&gt;expr2&lt;/code&gt;；否则，返回 &lt;code&gt;expr1&lt;/code&gt;。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;逻辑或，OR（`&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;`）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavsScript错题</title>
    <link href="http://yoursite.com/2020/01/03/Javascript%E9%94%99%E9%A2%98/"/>
    <id>http://yoursite.com/2020/01/03/Javascript%E9%94%99%E9%A2%98/</id>
    <published>2020-01-03T06:40:17.822Z</published>
    <updated>2020-01-03T07:29:31.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javscript题目"><a href="#Javscript题目" class="headerlink" title="Javscript题目"></a>Javscript题目</h1><blockquote><p>错题记录，有些题目懵逼</p></blockquote><h6 id="哪个选项是不正确的"><a href="#哪个选项是不正确的" class="headerlink" title="哪个选项是不正确的?"></a>哪个选项是不正确的?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  size: <span class="string">"small"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  name: <span class="string">"Mickey"</span>,</span><br><span class="line">  small: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><ul><li>A: <code>mouse.bird.size</code></li><li>B: <code>mouse[bird.size]</code></li><li>C: <code>mouse[bird[&quot;size&quot;]]</code></li><li>D: All of them are valid</li></ul><h4 id="答案-A"><a href="#答案-A" class="headerlink" title="答案: A"></a>答案: A</h4><p>在<code>JavaScript</code>中，所有对象键都是字符串（除了<code>Symbol</code>）。尽管有时我们可能不会给定字符串类型，但它们总是被转换为字符串。</p><p><code>JavaScript</code>解释语句。当我们使用方括号表示法时，它会看到第一个左括号<code>[</code>，然后继续，直到找到右括号<code>]</code>。只有在那个时候，它才会对这个语句求值。</p><p><code>mouse [bird.size]</code>：首先它会对<code>bird.size</code>求值，得到<code>small</code>。 <code>mouse [“small”]</code>返回<code>true</code>。</p><p>但是，使用点表示法，这不会发生。 <code>mouse</code>没有名为<code>bird</code>的键，这意味着<code>mouse.bird</code>是<code>undefined</code>。然后，我们使用点符号来询问<code>size</code>：<code>mouse.bird.size</code>。由于<code>mouse.bird</code>是<code>undefined</code>，我们实际上是在询问<code>undefined.size</code>。这是无效的，并将抛出<code>Cannot read property &quot;size&quot; of undefined</code>。</p><hr><h6 id="下面代码的输出是什么"><a href="#下面代码的输出是什么" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> colorChange(newColor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(&#123; newColor = <span class="string">"green"</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">"purple"</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">"orange"</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>orange</code></li><li>B: <code>purple</code></li><li>C: <code>green</code></li><li>D: <code>TypeError</code></li></ul><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>colorChange</code>方法是静态的。静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。由于<code>freddie</code>是一个子级对象，函数不会传递，所以在<code>freddie</code>实例上不存在<code>freddie</code>方法：抛出<code>TypeError</code>。</p><hr><h6 id="下面代码的输出是什么-1"><a href="#下面代码的输出是什么-1" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">"Lydia"</span>, <span class="string">"Hallie"</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><ul><li>A: <code>TypeError</code></li><li>B: <code>SyntaxError</code></li><li>C: <code>Lydia Hallie</code></li><li>D: <code>undefined</code> <code>undefined</code></li></ul><h4 id="答案-A-1"><a href="#答案-A-1" class="headerlink" title="答案: A"></a>答案: A</h4><p>您不能像使用常规对象那样向构造函数添加属性。如果要一次向所有对象添加功能，则必须使用原型。所以在这种情况下应该这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会使<code>member.getFullName()</code>是可用的，为什么样做是对的？假设我们将此方法添加到构造函数本身。也许不是每个<code>Person</code>实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！</p><hr><h6 id="下面代码的输出是什么-2"><a href="#下面代码的输出是什么-2" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">"Lydia"</span>, <span class="string">"Hallie"</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">"Sarah"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure><ul><li>A: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>undefined</code></li><li>B: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>Person {firstName: &quot;Sarah&quot;, lastName: &quot;Smith&quot;}</code></li><li>C: <code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>{}</code></li><li>D:<code>Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;}</code> and <code>ReferenceError</code></li></ul><h4 id="答案-A-2"><a href="#答案-A-2" class="headerlink" title="答案: A"></a>答案: A</h4><p>对于<code>sarah</code>，我们没有使用<code>new</code>关键字。使用<code>new</code>时，它指的是我们创建的新空对象。但是，如果你不添加<code>new</code>它指的是全局对象！</p><p>我们指定了<code>this.firstName</code>等于<code>&#39;Sarah</code>和<code>this.lastName</code>等于<code>Smith</code>。我们实际做的是定义<code>global.firstName =&#39;Sarah&#39;</code>和<code>global.lastName =&#39;Smith</code>。 <code>sarah</code>本身的返回值是<code>undefined</code>。</p><hr><h6 id="下面代码的输出是什么-3"><a href="#下面代码的输出是什么-3" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">"Lydia"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><ul><li>A: <code>Lydia</code> <code>21</code> <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code></li><li>B: <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code> <code>Lydia</code> <code>21</code></li><li>C: <code>Lydia</code> <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;]</code> <code>21</code></li></ul><h4 id="答案-B"><a href="#答案-B" class="headerlink" title="答案: B"></a>答案: B</h4><p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。其余参数获取传递到模板字符串中的表达式的值！</p><hr><h6 id="下面代码的输出是什么-4"><a href="#下面代码的输出是什么-4" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are an adult!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are still an adult."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don't have an age I guess`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>A: <code>You are an adult!</code></li><li>B: <code>You are still an adult.</code></li><li>C: <code>Hmm.. You don&#39;t have an age I guess</code></li></ul><h4 id="答案-C"><a href="#答案-C" class="headerlink" title="答案: C"></a>答案: C</h4><p>在比较相等性，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。<code>JavaScript</code>检查对象是否具有对内存中相同位置的引用。</p><p>我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。</p><p>这就是为什么<code>{ age: 18 } === { age: 18 }</code>和 <code>{ age: 18 } == { age: 18 }</code> 返回 <code>false</code>的原因。</p><hr><h6 id="下面代码的输出是什么-5"><a href="#下面代码的输出是什么-5" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;array&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;NaN&quot;</code></li></ul><h4 id="答案-C-1"><a href="#答案-C-1" class="headerlink" title="答案: C"></a>答案: C</h4><p>扩展运算符（<code>... args</code>）返回一个带参数的数组。数组是一个对象，因此<code>typeof args</code>返回<code>object</code>。</p><hr><h6 id="下面代码的输出是什么-6"><a href="#下面代码的输出是什么-6" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">"10*10+5"</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>105</code></li><li>B: <code>&quot;105&quot;</code></li><li>C: <code>TypeError</code></li><li>D: <code>&quot;10*10+5&quot;</code></li></ul><h4 id="答案-A-3"><a href="#答案-A-3" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>eval</code>会为字符串传递的代码求值。如果它是一个表达式，就像在这种情况下一样，它会计算表达式。表达式为<code>10 * 10 + 5</code>计算得到<code>105</code>。</p><hr><h6 id="下面代码的输出是什么-7"><a href="#下面代码的输出是什么-7" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><ul><li>A: <code>8</code></li><li>B: <code>10</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>ReferenceError</code></li></ul><h4 id="答案-B-1"><a href="#答案-B-1" class="headerlink" title="答案: B"></a>答案: B</h4><p>使用<code>var</code>关键字，您可以用相同的名称<strong>声明多个变量</strong>。然后变量将保存最新的值。</p><p>您不能使用<code>let</code>或<code>const</code>来实现这一点，因为它们是块作用域的。</p><hr><h6 id="下面代码的输出是什么-8"><a href="#下面代码的输出是什么-8" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty("1");</span><br><span class="line">obj.hasOwnProperty(1);</span><br><span class="line"><span class="keyword">set</span>.has("1");</span><br><span class="line"><span class="keyword">set</span>.has(1);</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li><li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li></ul><h4 id="答案-C-2"><a href="#答案-C-2" class="headerlink" title="答案: C"></a>答案: C</h4><p><strong>所有对象键（不包括<code>Symbols</code>）都会被存储为字符串</strong>，即使你没有给定字符串类型的键。这就是为什么<code>obj.hasOwnProperty（&#39;1&#39;）</code>也返回<code>true</code>。</p><p>上面的说法不适用于<code>Set</code>。在我们的<code>Set</code>中没有<code>“1”</code>：<code>set.has（&#39;1&#39;）</code>返回<code>false</code>。它有数字类型<code>1</code>，<code>set.has（1）</code>返回<code>true</code>。</p><hr><h6 id="下面代码的输出是什么-9"><a href="#下面代码的输出是什么-9" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">"one"</span>, <span class="attr">b</span>: <span class="string">"two"</span>, <span class="attr">a</span>: <span class="string">"three"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><ul><li>A: <code>{ a: &quot;one&quot;, b: &quot;two&quot; }</code></li><li>B: <code>{ b: &quot;two&quot;, a: &quot;three&quot; }</code></li><li>C: <code>{ a: &quot;three&quot;, b: &quot;two&quot; }</code></li><li>D: <code>SyntaxError</code></li></ul><h4 id="答案-C-3"><a href="#答案-C-3" class="headerlink" title="答案: C"></a>答案: C</h4><p>如果对象有<strong>两个具有相同名称的键</strong>，则将<strong>替前面的键</strong>。它仍将处于第一个位置，但具有最后指定的值。</p><hr><h6 id="下面代码的输出是什么-10"><a href="#下面代码的输出是什么-10" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">"b"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span>;</span><br><span class="line">a[c] = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure><ul><li>A: <code>123</code></li><li>B: <code>456</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><h4 id="答案-B-2"><a href="#答案-B-2" class="headerlink" title="答案: B"></a>答案: B</h4><p>对象键自动转换为字符串。我们试图将一个对象设置为对象<code>a</code>的键，其值为<code>123</code>。</p><p>但是，当对象自动转换为字符串化时，它变成了<code>[Object object]</code>。所以我们在这里说的是<code>a[&quot;Object object&quot;] = 123</code>。然后，我们可以尝试再次做同样的事情。 <code>c</code>对象同样会发生隐式类型转换。那么，<code>a[&quot;Object object&quot;] = 456</code>。</p><p>然后，我们打印<code>a[b]</code>，它实际上是<code>a[&quot;Object object&quot;]</code>。我们将其设置为<code>456</code>，因此返回<code>456</code>。</p><hr><h6 id="下面代码的输出是什么-11"><a href="#下面代码的输出是什么-11" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;string&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><h4 id="答案-B-3"><a href="#答案-B-3" class="headerlink" title="答案: B"></a>答案: B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof 1` 返回 `&quot;number&quot;`.</span><br><span class="line">`typeof &quot;number&quot;` 返回 `&quot;string&quot;</span><br></pre></td></tr></table></figure><hr><h6 id="下面代码的输出是什么-12"><a href="#下面代码的输出是什么-12" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 2, 3, 7 x null, 11]</code></li><li>B: <code>[1, 2, 3, 11]</code></li><li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li><li>D: <code>SyntaxError</code></li></ul><h4 id="答案-C-4"><a href="#答案-C-4" class="headerlink" title="答案: C"></a>答案: C</h4><p>When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called “empty slots”. These actually have the value of <code>undefined</code>, but you will see something like:</p><p>当你为数组中的元素设置一个超过数组长度的值时，<code>JavaScript</code>会创建一个名为“空插槽”的东西。这些位置的值实际上是<code>undefined</code>，但你会看到类似的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 7 x empty, 11]</span><br></pre></td></tr></table></figure><p>这取决于你运行它的位置（每个浏览器有可能不同）。</p><hr><h6 id="下面代码的输出是什么-13"><a href="#下面代码的输出是什么-13" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>undefined</code> <code>2</code></li><li>B: <code>undefined</code> <code>undefined</code> <code>undefined</code></li><li>C: <code>1</code> <code>1</code> <code>2</code></li><li>D: <code>1</code> <code>undefined</code> <code>undefined</code></li></ul><h4 id="答案-A-4"><a href="#答案-A-4" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>catch</code>块接收参数<code>x</code>。当我们传递参数时，这与变量的<code>x</code>不同。这个变量<code>x</code>是属于<code>catch</code>作用域的。</p><p>之后，我们将这个块级作用域的变量设置为<code>1</code>，并设置变量<code>y</code>的值。现在，我们打印块级作用域的变量<code>x</code>，它等于<code>1</code>。</p><p>在<code>catch</code>块之外，<code>x</code>仍然是<code>undefined</code>，而<code>y</code>是<code>2</code>。当我们想在<code>catch</code>块之外的<code>console.log(x)</code>时，它返回<code>undefined</code>，而<code>y</code>返回<code>2</code>。</p><hr><p><code>JavaScript</code>只有原始类型和对象。</p><hr><h6 id="下面代码的输出是什么-14"><a href="#下面代码的输出是什么-14" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[0, 1, 2, 3, 1, 2]</code></li><li>B: <code>[6, 1, 2]</code></li><li>C: <code>[1, 2, 0, 1, 2, 3]</code></li><li>D: <code>[1, 2, 6]</code></li></ul><h4 id="答案-C-5"><a href="#答案-C-5" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>[1,2]</code>是我们的初始值。这是我们开始执行<code>reduce</code>函数的初始值，以及第一个<code>acc</code>的值。在第一轮中，<code>acc</code>是<code>[1,2]</code>，<code>cur</code>是<code>[0,1]</code>。我们将它们连接起来，结果是<code>[1,2,0,1]</code>。</p><p>然后，<code>acc</code>的值为<code>[1,2,0,1]</code>，<code>cur</code>的值为<code>[2,3]</code>。我们将它们连接起来，得到<code>[1,2,0,1,2,3]</code>。</p><hr><h6 id="setInterval方法的返回值什么"><a href="#setInterval方法的返回值什么" class="headerlink" title="setInterval方法的返回值什么?"></a><code>setInterval</code>方法的返回值什么?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Hi"</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>A：一个唯一的<code>id</code></li><li>B：指定的毫秒数</li><li>C：传递的函数</li><li>D：<code>undefined</code></li></ul><h4 id="答案-A-5"><a href="#答案-A-5" class="headerlink" title="答案: A"></a>答案: A</h4><p>它返回一个唯一的<code>id</code>。此<code>id</code>可用于使用<code>clearInterval()</code>函数清除该定时器。</p><hr><h6 id="What-does-this-return"><a href="#What-does-this-return" class="headerlink" title="What does this return?"></a>What does this return?</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">"Lydia"</span>];</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]</code></li><li>B: <code>[&quot;Lydia&quot;]</code></li><li>C: <code>[[], &quot;Lydia&quot;]</code></li><li>D: <code>[[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]]</code></li></ul><h4 id="答案-A-6"><a href="#答案-A-6" class="headerlink" title="答案: A"></a>答案: A</h4><p>字符串是可迭代的。扩展运算符将迭代的每个字符映射到一个元素。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Javscript题目&quot;&gt;&lt;a href=&quot;#Javscript题目&quot; class=&quot;headerlink&quot; title=&quot;Javscript题目&quot;&gt;&lt;/a&gt;Javscript题目&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;错题记录，有些题目懵逼&lt;/p&gt;&lt;/blockquote&gt;&lt;h6 id=&quot;哪个选项是不正确的&quot;&gt;&lt;a href=&quot;#哪个选项是不正确的&quot; class=&quot;headerlink&quot; title=&quot;哪个选项是不正确的?&quot;&gt;&lt;/a&gt;哪个选项是不正确的?&lt;/h6&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; bird = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size: &lt;span class=&quot;string&quot;&gt;&quot;small&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mouse = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;Mickey&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  small: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记（一）（基础部分）</title>
    <link href="http://yoursite.com/2020/01/02/2020%E9%83%BD%E6%9D%A5%E4%BA%86%EF%BC%8CTypeScript%E8%BF%98%E4%B8%8D%E5%BF%AB%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2020/01/02/2020%E9%83%BD%E6%9D%A5%E4%BA%86%EF%BC%8CTypeScript%E8%BF%98%E4%B8%8D%E5%BF%AB%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B/</id>
    <published>2020-01-02T11:43:26.514Z</published>
    <updated>2020-02-10T07:38:22.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript学习笔记（一）（基础部分）"><a href="#TypeScript学习笔记（一）（基础部分）" class="headerlink" title="TypeScript学习笔记（一）（基础部分）"></a>TypeScript学习笔记（一）（基础部分）</h1><blockquote><p>预言：为什么学习TypeScript？</p><p>2020都来了，TypeScript还不快学习一下</p><p>VUE3也使用了TS，现在三大框架都转为TypeScript，Node无力回天，Deno前景明朗，使用V8引擎解析TS。</p><p>TS遍地开花，大势所趋。2020肯定迟早都要学的，不如早点儿赶上潮流（😥其实不算早了）</p><p>它是javascript的超集，有静态类型检查，清晰函数参数，接口属性，增加了代码的可读性。</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p>入门学习推荐：</p><p><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程文档</a></p><p><a href="https://jspang.com/detailed?id=38" target="_blank" rel="noopener">技术胖ts视频教程</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>TypeScript 的命令行工具安装全局：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g typescript</span><br></pre></td></tr></table></figure><h3 id="helloWorld"><a href="#helloWorld" class="headerlink" title="helloWorld"></a>helloWorld</h3><p>创建文件hello.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello,  <span class="subst">$&#123;person&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Jason'</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user))</span><br></pre></td></tr></table></figure><p>终端输入：<code>tsc hello.ts</code></p><p>编译完后，出现文件hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello,  "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'Jason'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="boolean（布尔值）"><a href="#boolean（布尔值）" class="headerlink" title="boolean（布尔值）"></a>boolean（布尔值）</h3><p>使用 <code>boolean</code> 定义布尔值类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure><p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br></pre></td></tr></table></figure><p><code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。</p><h3 id="number（数值）"><a href="#number（数值）" class="headerlink" title="number（数值）"></a>number（数值）</h3><p>使用 <code>number</code> 定义数值类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">// 二进制</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">// 八进制</span><br><span class="line">let octalLiteral: number = 0o744;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">var octalLiteral = 484;</span><br></pre></td></tr></table></figure><p>二进制和八进制，它们会被编译为十进制数字。</p><blockquote><p>为什么<code>tsc</code>不转十六进制？</p><p>十和十六进制本身就有，二和八进制是ES6引入的，tsc默认转为ES5，<code>tsc -t ES6 hello.ts</code>转es6就不会改变</p></blockquote><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/TypeScript/image-20200101172413290.png" alt="image-20200101172413290"></p><h3 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h3><p>使用 <code>string</code> 定义字符串类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Jason'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: <span class="built_in">number</span> = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.I'll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>使用 <code>void</code> 表示没有任何返回值的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'My name is Jason'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 是所有类型的子类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错</span><br><span class="line">let num: number = undefined;</span><br></pre></td></tr></table></figure><hr><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p><code>any</code> 类型，允许被赋值为任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p><p><strong>如果申明 变量 未申明 类型 和 值，那么它会被识别为任意值类型</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something; </span><br><span class="line"><span class="comment">//等价于 let something: any;</span></span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="comment">// 等价于 let myFavoriteNumber: string = 'seven';</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 再定义数字类型就会出错 index.ts(2,1): error TS2322: Type 'number' is not assignable</span></span><br></pre></td></tr></table></figure><p><strong>如果申明 ‘变量’ 未申明 ‘类型’ 单定义 ‘值’ ，那么它会自动推测类型</strong>：</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。</p><p><strong>例子</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>TypeScript <strong>不确定</strong>一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里<strong>共有</strong>的属性或方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 length不是 string 和 number 共有属性</span></span><br></pre></td></tr></table></figure><p>联合类型变量被赋值之后，就可以使用其类型方法</p><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对类的一部分行为进行<strong>抽象</strong>以外，也常用于对「对象的<strong>形状</strong>（Shape）」进行描述</p><p><strong>例子</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="comment">// 只读属性，只能在第一次给 ‘对象’ 创建的时候 赋值</span></span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// 可选属性，该属性可以不存在</span></span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 任意属性，确定属性 和 可选属性 的类型都必须是其类型的子集</span></span><br><span class="line">    <span class="comment">//[propName: string]: string; 报错，age?: number;不是string的子集</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义变量jason，约束jason的形状必须和Person接口一致，接口首字母大写或I开头</span></span><br><span class="line"><span class="keyword">let</span> jason: Person = &#123;</span><br><span class="line">    id: <span class="number">19040108</span></span><br><span class="line">    name: <span class="string">'Jason</span></span><br><span class="line"><span class="string">    age: 20</span></span><br><span class="line"><span class="string">    //任意属性下的结果</span></span><br><span class="line"><span class="string">    gender: '</span>male<span class="string">'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">jason.id = 19040101; //报错，只读属性不能再次赋值</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>只读属性</strong>只能在第一次给 <strong>‘对象’ 创建</strong>的时候 赋值，不能在外面单独赋值</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/TypeScript/image-20200102105140825.png" alt="image-20200102105140825"></p><hr><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><h4 id="「类型-方括号」表示法"><a href="#「类型-方括号」表示法" class="headerlink" title="「类型 + 方括号」表示法"></a>「类型 + 方括号」表示法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// let fibonacci: number[] = [1, '1', 2, 3, 5]; //出现string报错</span></span><br><span class="line"><span class="comment">// fibonacci.push('8'); 报错，推入string也不行</span></span><br></pre></td></tr></table></figure><h4 id="数组泛型-表示法"><a href="#数组泛型-表示法" class="headerlink" title="数组泛型 表示法"></a>数组泛型 表示法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="接口-表示法"><a href="#接口-表示法" class="headerlink" title="接口 表示法"></a>接口 表示法</h4><p>常用来表示<strong>类数组</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    <span class="comment">// 只要索引的类型是数字时，那么值的类型必须是数字</span></span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArguments &#123;</span><br><span class="line"><span class="comment">// 约束当 索引 的类型是数字时，值的类型是任意类型</span></span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">    <span class="comment">// 约束它有length 和callee两个属性</span></span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    callee: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p><strong>函数声明</strong>的类型定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);<span class="comment">// 报错，输入了过少的参数</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 报错，输入了过多的参数</span></span><br></pre></td></tr></table></figure><p><strong>数表达式</strong>的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (x: type,...输入类型) =&gt; 输出类型 ，不要和箭头函数混淆了</span></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状:"></a>用接口定义函数的形状:</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面 = 赋值默认参数，同 es6语法</span></span><br><span class="line"><span class="comment">// 用 `?` 表示可选的参数：,可选参数 必须接在 必需参数 后面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'unkownName', lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Jason'</span>, <span class="string">'Wu'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Jason'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数，语法同es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精确表达，输入为数字的时候，输出也应该为数字</span></span><br><span class="line"><span class="comment">// 优先把精确的定义写在前面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="comment">// 输入为字符串的时候，输出也应该为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote><p>当使用 type1 | type2 这种情况，类型还不确定的时候，TS只会有其<strong>共有方法</strong>，获取单独属性方法就会报错， 手动断言指定一个值的类型。</p></blockquote><p>需要断言的变量前加上<type>即可</type></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if ((something).length) 报错，只有其共有方法</span></span><br><span class="line">    <span class="comment">// 将 `something` 断言成 `string` </span></span><br><span class="line">    <span class="comment">// 联合类型中不存在的类型不允许断言 eg：&lt;boolean&gt;something</span></span><br><span class="line">    <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;something).length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><blockquote><p>声明语句：定义了全局变量的类型，仅仅会用于编译时的检查，在编译结果中会被删除。</p><p>把声明语句放到一个单独的文件（<code>file.d.ts</code>）中，以 <code>.d.ts</code> 结尾的文件就是声明文件。</p><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。</p></blockquote><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="declare-var"><a href="#declare-var" class="headerlink" title="declare var"></a><code>declare var</code></h4><p>用来定义<strong>全局变量</strong>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="comment">// 注入全局变量jQuery ，declare 只能用来声明类型,不能用来赋值</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a><code>declare function</code></h4><p>用来定义<strong>全局函数</strong>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// 可以函数重载</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">domReadyCallback: () =&gt; <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Dom Ready!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a><code>declare class</code></h4><p>定义<strong>全局 类</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Person &#123;    </span><br><span class="line">    name: <span class="built_in">string</span>;    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);    </span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// declare里 只能用来定义类型，不能用来具体实现</span></span><br><span class="line">    <span class="comment">// sayHi() &#123; //报错</span></span><br><span class="line">    <span class="comment">//    return `My name is $&#123;this.name&#125;`;</span></span><br><span class="line">    <span class="comment">// &#125;; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Jason'</span>);</span><br></pre></td></tr></table></figure><h4 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a><code>declare enum</code></h4><p>使用 <code>declare enum</code> 定义的枚举类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Directions.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;    </span><br><span class="line">    Up,    </span><br><span class="line">    Down,    </span><br><span class="line">    Left,    </span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a><code>declare namespace</code></h4><p>用来表示全局变量是一个对象，包含很多子属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="comment">// namespace内部可以直接使用function xxx，不必declare function xxx</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">const</span> version: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">class</span> Event &#123;</span><br><span class="line">        blur(eventType: EventType): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">        CustomClick</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套命名空间，声明深层对象属性， 但是仅有一个深层属性就可以不写namespace</span></span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">object: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jQuery.version);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> jQuery.Event();</span><br><span class="line">e.blur(jQuery.EventType.CustomClick);</span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    check: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.checked = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a><code>interface</code></h3><p>在类型声明文件中，可以直接使用 <code>interface</code> 来声明一个全局的接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> AjaxSettings &#123;    </span><br><span class="line">    method?: <span class="string">'GET'</span> | <span class="string">'POST'</span>    </span><br><span class="line">    data?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="comment">// 接口和类型，最好还是放在namespace下,减少全局变量</span></span><br><span class="line">     <span class="keyword">interface</span> AjaxSettings &#123;</span><br><span class="line">        method?: <span class="string">'GET'</span> | <span class="string">'POST'</span></span><br><span class="line">        data?: <span class="built_in">any</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，在其他文件中也可以使用这个接口或类型了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">let</span> settings: AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>, </span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(<span class="string">'/api/post_something'</span>, settings);</span><br><span class="line"><span class="comment">// 在命名空间里声明的接口 加上前缀 namespaceName.interfaceName...</span></span><br><span class="line"><span class="keyword">let</span> settings: jQuery.AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h4><p>可以组合多个声明语句，它们不冲突</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br></pre></td></tr></table></figure><h3 id="npm包"><a href="#npm包" class="headerlink" title="npm包"></a>npm包</h3><p>判断声明文件是否已经存在。</p><ol><li><code>package.json</code>中有<code>types</code>字段，或有一个<code>index.d.ts</code>声明文件（推荐）。</li><li>发布到<code>@types</code>里，安装试一下有无 <code>cnpm i @types/foo --save-dev</code>作者没有发布，一般由其他人补充。</li></ol><p>如果以上两种方法都没有，就只能自己创建</p><p>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</p><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p><code>tsconfig.json</code> 内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">        <span class="attr">"paths"</span>: &#123;</span><br><span class="line">            <span class="attr">"*"</span>: [<span class="string">"types/*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a><code>export</code></h4><p>只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left, </span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个拥有子属性的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 declare声明，再一并导出</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 接口不需要 declare声明</span></span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure><p>对应的导入和使用模块应该是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName,</span><br><span class="line">    Animal,</span><br><span class="line">    Directions,</span><br><span class="line">    Options &#125;</span><br><span class="line"><span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="keyword">let</span> myName = getName();</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line"><span class="keyword">let</span> options: Options = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line">foo.bar.baz();</span><br></pre></td></tr></table></figure><h3 id="UMD-库"><a href="#UMD-库" class="headerlink" title="UMD 库"></a>UMD 库</h3><p>既可以通过 <code>&lt;script&gt;</code>标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="comment">// 使用 export as namespace xxx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo; <span class="comment">// ES6 标准</span></span><br><span class="line"><span class="comment">// export = foo; ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接扩展全局变量"><a href="#直接扩展全局变量" class="headerlink" title="直接扩展全局变量"></a>直接扩展全局变量</h3><p>扩展 <code>String</code> 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 `String` 添加属性或方法。</span></span><br><span class="line"><span class="keyword">interface</span> String &#123;</span><br><span class="line">prependHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'foo'</span>.prependHello();</span><br></pre></td></tr></table></figure><p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JQuery &#123;</span><br><span class="line">    <span class="keyword">interface</span> CustomOptions &#123;</span><br><span class="line">        bar: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> JQueryStatic &#123;</span><br><span class="line">foo(options: JQuery.CustomOptions): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">jQuery.foo(&#123;</span><br><span class="line">bar: <span class="string">''</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在-npm-包或-UMD-库中扩展全局变量"><a href="#在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="在 npm 包或 UMD 库中扩展全局变量"></a>在 npm 包或 UMD 库中扩展全局变量</h3><p>对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。如果导入npm 包或 UMD 库之后要扩展全局变量，则需要使用<code>declare global</code>在声明文件中扩展全局变量的类型。</p><h4 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a><code>declare global</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">    <span class="keyword">interface</span> String &#123;        </span><br><span class="line">        prependHello(): <span class="built_in">string</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 告诉编译器这是一个 模块 的声明文件</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="string">'bar'</span>.prependHello();</span><br></pre></td></tr></table></figure><h3 id="模块插件"><a href="#模块插件" class="headerlink" title="模块插件"></a>模块插件</h3><p>原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p><h4 id="declare-module"><a href="#declare-module" class="headerlink" title="declare module"></a><code>declare module</code></h4><p>需要在类型声明文件中<strong>先引用原有模块</strong>，再使用 <code>declare module</code> 扩展原有模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'moment' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">moment</span>.<span class="title">CalendarKey</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在一个文件中 可声明多个模块的类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'bar' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Bar &#123;</span><br><span class="line">        bar: <span class="built_in">string</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment-plugin'</span>;</span><br><span class="line">moment.foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Bar &#125; <span class="keyword">from</span> <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> B: Bar;</span><br></pre></td></tr></table></figure><h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><p>应用场景：</p><ul><li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li></ul><blockquote><p>在全局变量的声明文件中，一旦出现了 <code>import</code>, <code>export</code> 关键字。那么他就会被视为一个 npm 包或 UMD 库。写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"><span class="comment">// `///` 后面使用 xml 的格式添加了对 `jquery` 类型的依赖,就可以在声明文件中使用 `JQuery.AjaxSettings` 类型了.</span></span><br><span class="line"><span class="comment">// 三斜线指令必须放在文件的最顶端,除了注释</span></span><br><span class="line"><span class="comment">/// &lt;reference types="jquery" /&gt;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line">foo(&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li></ul><blockquote><p>由于全局变量不支持通过 <code>import</code> 导入，必须使用三斜线指令来引入</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/node-plugin/index.d.ts</span></span><br><span class="line"><span class="comment">// 由于引入的 `node` 中的类型都是全局变量的类型,通过三斜线指引入了 `node` 的类型</span></span><br><span class="line"><span class="comment">/// &lt;reference types="node" /&gt;</span></span><br><span class="line"><span class="comment">// 声明文件中使用了 `NodeJS.Process` 这个类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p: NodeJS.Process</span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'node-plugin'</span>;</span><br><span class="line"><span class="comment">// 使用到 `foo` 的时候，传入了 `node` 中的全局变量 `process`</span></span><br><span class="line">foo(global.process);</span><br></pre></td></tr></table></figure><h4 id="拆分声明文件"><a href="#拆分声明文件" class="headerlink" title="拆分声明文件"></a>拆分声明文件</h4><blockquote><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。</p></blockquote><p>比如 <code>jQuery</code> 的声明文件就是这样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"><span class="comment">// types 用于声明对另一个 '库' 的依赖</span></span><br><span class="line"><span class="comment">/// &lt;reference types="sizzle" /&gt;</span></span><br><span class="line"><span class="comment">// path 用于声明对另一个 '文件' 的依赖</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQueryStatic.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQuery.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="misc.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="legacy.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure><h3 id="自动生成声明文件"><a href="#自动生成声明文件" class="headerlink" title="自动生成声明文件"></a>自动生成声明文件</h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，命令行添加 <code>--declaration</code>(<code>-d</code>) 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p><p>或者在 <code>tsconfig.json</code> 中添加 <code>declaration: true</code> 选项。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="comment">// `outDir` 选项，将 ts 文件的编译结果输出到 `lib` 目录下</span></span><br><span class="line">        <span class="attr">"outDir"</span>: <span class="string">"lib"</span>,</span><br><span class="line">        <span class="comment">// 将会由 ts 文件自动生成 `.d.ts` 声明文件</span></span><br><span class="line">        <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布声明文件"><a href="#发布声明文件" class="headerlink" title="发布声明文件"></a>发布声明文件</h3><ol><li><p>将声明文件和源码放在一起 (自己写的库)</p><p>需要满足以下条件之一，才能被正确的识别：</p><ul><li><p>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"lib/index.js"</span>,</span><br><span class="line">    "types": "foo.d.ts",...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件</p></li><li><p>如果根目录下没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件，是否存在对应同名不同后缀的 <code>.d.ts</code> 文件</p></li></ul></li><li><p>将声明文件发布到 <code>@types</code> 下（原作者不愿意合并 pull request 时，补充别人的仓库）</p><ul><li>给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。通过测试，稍后就会被自动发布到 <code>@types</code> 下。</li><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package" target="_blank" rel="noopener">DefinitelyTyped 文档</a></li></ul></li></ol><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="ECMAScript-的内置对象"><a href="#ECMAScript-的内置对象" class="headerlink" title="ECMAScript 的内置对象"></a>ECMAScript 的内置对象</h3><p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p><p>可以在 TypeScript 中将变量定义为这些类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure><h3 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h3><p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p><p>TypeScript 中会经常用到这些类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h3><p>TypeScript 核心库的定义中不包含 Node.js 部分，需要引入第三方声明文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>基础部分学完了，总的来说TS可以规范变量，对象，函数类型。声明文件那部分学的不太明白，可能还做过大型库，项目，水平没上来，再多看一些文章加深理解吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TypeScript学习笔记（一）（基础部分）&quot;&gt;&lt;a href=&quot;#TypeScript学习笔记（一）（基础部分）&quot; class=&quot;headerlink&quot; title=&quot;TypeScript学习笔记（一）（基础部分）&quot;&gt;&lt;/a&gt;TypeScript学习笔记（一）（基础部分）&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;预言：为什么学习TypeScript？&lt;/p&gt;&lt;p&gt;2020都来了，TypeScript还不快学习一下&lt;/p&gt;&lt;p&gt;VUE3也使用了TS，现在三大框架都转为TypeScript，Node无力回天，Deno前景明朗，使用V8引擎解析TS。&lt;/p&gt;&lt;p&gt;TS遍地开花，大势所趋。2020肯定迟早都要学的，不如早点儿赶上潮流（😥其实不算早了）&lt;/p&gt;&lt;p&gt;它是javascript的超集，有静态类型检查，清晰函数参数，接口属性，增加了代码的可读性。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="http://yoursite.com/2020/01/01/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/01/2019%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-02T12:47:29.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年总结"><a href="#2019年总结" class="headerlink" title="2019年总结"></a>2019年总结</h1><blockquote><p>2019-2020是我奋发前进的一年，有了整体职业方向，前端工程师的路上有坎坷有迷茫。</p></blockquote><p>这一年 因为整天在工作室敲代码，没有陪女朋友，又加上直男言论，无数次分手。万般无奈，因为我知道，我一个二流学校出身的人，我不拼命武装本事，毕业就是失业。</p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:55 GMT+0800 (GMT+08:00) --><p>看到工作室学长春招进了头条我就更加了。仿佛一束光，我觉得我也能行。智力比不过，比勤奋嘛。</p><h3 id="这一年的流水账"><a href="#这一年的流水账" class="headerlink" title="这一年的流水账"></a>这一年的流水账</h3><h4 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h4><p><strong>原生js</strong>写淘宝，学了大几个月的js却不知道怎么用，变量提升啊，轮播图啊，真是开啃荒地一般艰难，完全坚持不下去，想过放弃。</p><h4 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h4><p>开学边学<strong>小程序</strong>边学了<strong>es6</strong>,因为小程序大赛时间紧迫，简单学习，直接就开撸了。写出来的代码不怎么样。但还是费劲心思把基本的功能实现了。最后功亏一篑，没有得奖。</p><h4 id="期末到-暑假"><a href="#期末到-暑假" class="headerlink" title="期末到 暑假"></a>期末到 暑假</h4><p><strong>学习了node</strong> ，整个后台学的比较浅，也是这个时候开始了写博客。对自己所学有所复盘，也可以分享知识。是对自己所学的一个证明吧。</p><h4 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h4><p>下学期学习了<strong>vue</strong>，建好了第一个Vue的脚手架，在云服务器上成功<strong>部署</strong>项目。商城项目前前后后写了快两个月。整体感觉就是从知识模糊到融会贯通。</p><h4 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h4><p>学到一定程度了，想投一个简历试一试，又不敢的心情。一边疯狂查漏补缺，然后投了人生第一个，面试三轮成功。整个流程下来那几天难以入睡。<br>‌<br><strong>深信服的实习工资，给家里买了台松下洗碗机，希望妈妈能解放双手，幸福生活。</strong></p><h4 id="明年计划"><a href="#明年计划" class="headerlink" title="明年计划"></a>明年计划</h4><h4 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h4><p>新的一年，继续健身计划，做好<strong>力量训练</strong>。实习没有运动，感觉肌肉要消失😭</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>需要多一点读书的时间，少刷一点儿手机动态。给自己留一点<strong>独处</strong>的时间<strong>，静下心来，冥想，内省</strong>。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>前端学习从零起步到现在，已经把整个前端基础体系过了一遍，接下来还要做好深度和广度。</p><ul><li><p><strong>深度方面:</strong></p><ul><li>继续学习vue源码：我觉得这是最难啃的一部分，从理解原理，vuex，router等组件入手；</li><li>webpack原理，前端工程优化；</li><li>基础算法：还没有做完😥。</li></ul></li><li><p><strong>广度方面 ：</strong></p><ul><li>typescript正在学；</li><li>学习react感觉大公司都在用，不过还是得先把vue给搞透；</li><li>fluter下半年再说吧，现在还不太成熟。</li></ul></li></ul><h3 id="这是个持久战。"><a href="#这是个持久战。" class="headerlink" title="这是个持久战。"></a>这是个持久战。</h3><p>说实话，一路上瞧不起我的人很多，有段时间很无助，我记得高中成绩差，有些人就是鄙视你，找成绩优秀的问问题也不会鸟我。健身刚入门的时候120斤，就有人质疑，“看你健身谈得头头是道，也没有肌肉啊”。</p><p>正是因为总总质疑，各种人的瞧不起，让我不服气，让我奋起直追，要有男儿骨气。老子就是要进大厂，过得体面；就是要浑身肌肉，充满力量。</p><p>还记得王小波说的话：“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。。。我觉得自己会永远生猛下去，什么也锤不了我。”</p><h4 id="重要的是坚持"><a href="#重要的是坚持" class="headerlink" title="重要的是坚持"></a>重要的是坚持</h4><p><strong>默默积累沉淀，输出，希望在2021年进入理想的公司😇</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2019年总结&quot;&gt;&lt;a href=&quot;#2019年总结&quot; class=&quot;headerlink&quot; title=&quot;2019年总结&quot;&gt;&lt;/a&gt;2019年总结&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;2019-2020是我奋发前进的一年，有了整体职业方向，前端工程师的路上有坎坷有迷茫。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这一年 因为整天在工作室敲代码，没有陪女朋友，又加上直男言论，无数次分手。万般无奈，因为我知道，我一个二流学校出身的人，我不拼命武装本事，毕业就是失业。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>socket实现点对点，群通讯</title>
    <link href="http://yoursite.com/2019/12/28/socket%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%8C%E7%BE%A4%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2019/12/28/socket%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%8C%E7%BE%A4%E9%80%9A%E8%AE%AF/</id>
    <published>2019-12-28T03:25:21.071Z</published>
    <updated>2020-01-02T12:39:13.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现socket点对点，群-通讯"><a href="#实现socket点对点，群-通讯" class="headerlink" title="实现socket点对点，群 通讯"></a>实现socket点对点，群 通讯</h1><blockquote><p>Java语言不太熟悉，根据老师的思路，实现了 node websocket的简单通讯，前台用的vue。</p></blockquote><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/eg1.png" alt="eg1"></p><h3 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h3><p>当客户端要和服务端建立 WebSocket 连接时，在客户端和服务器的握手过程中，客户端首先会向服务端发送一个 HTTP 请求，包含一个 Upgrade 请求头来告知服务端客户端想要建立一个 WebSocket 连接。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request head:</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade  // 告诉它要升级协议</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Sec-WebSocket-Extensions</span>: permessage-deflate; client_max_window_bits</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: EYW+TeBXX1QDdU5T5/XQ6g==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13  // 协议版本</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket  // 升级到websocket协议</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="简单聊天项目架构"><a href="#简单聊天项目架构" class="headerlink" title="简单聊天项目架构"></a>简单聊天项目架构</h3><p><img src="/images/loading.png" data-original="E:%5CBlog%5Cpicture%5Csocket%E7%AE%80%E5%8D%95%E9%80%9A%E8%AE%AF.png" alt="socket简单通讯"></p><h3 id="用户登陆"><a href="#用户登陆" class="headerlink" title="用户登陆"></a>用户登陆</h3><blockquote><p>由于时间有限，只做了输入用户名登陆</p></blockquote><ol><li>用户输入用户名，客户端生成uid，然后用socket发送给服务端</li></ol><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/LOGIN.png" alt="LOGIN"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听连接成功</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接服务器成功'</span>)</span><br><span class="line">    vm.$message(&#123; <span class="attr">type</span>: <span class="string">'success'</span>, <span class="attr">message</span>: <span class="string">'连接服务器成功'</span> &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!vm.uid) &#123;</span><br><span class="line">        <span class="comment">// moment 为 日期库，通过前缀+时间生成唯一值</span></span><br><span class="line">        vm.uid = <span class="string">'web_tim'</span> + moment().valueOf()</span><br><span class="line">        <span class="comment">// 存在浏览器</span></span><br><span class="line">        localStorage.setItem(</span><br><span class="line">            <span class="string">'WEB_IM_USER'</span>,</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uid: vm.uid,</span><br><span class="line">                nickname: vm.nickname</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向服务端发送1</span></span><br><span class="line">    vm.sendMessage(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务端监听。</li></ol><blockquote><p>时间有限，先使用最简单的swich，cash判断客户端发过来的请求，</p><p>暂时使用<strong>数组和对象</strong>保存<strong>数据</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">conn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听客户端发来的消息</span></span><br><span class="line">    conn.on(<span class="string">'text'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        obj = <span class="built_in">JSON</span>.parse(obj)</span><br><span class="line">        conns[<span class="string">''</span> + obj.uid + <span class="string">''</span>] = conn</span><br><span class="line">        <span class="keyword">switch</span> (obj.type) &#123;</span><br><span class="line">                <span class="comment">// 创建连接</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isUser = users.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.uid === obj.uid</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果没有此用户直接向数组里推，数组里存对象</span></span><br><span class="line"><span class="keyword">if</span> (!isUser) &#123;</span><br><span class="line">    users.push(&#123;</span><br><span class="line">        nickname: obj.nickname,</span><br><span class="line">        uid: obj.uid,</span><br><span class="line">        status: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  如果有此用户，状态status: 1，为在线 ，status: 0 下线</span></span><br><span class="line">    users.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.uid === obj.uid) &#123;</span><br><span class="line">            item.status = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 广播</span></span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'加入聊天室'</span>,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h5 id="广播函数"><a href="#广播函数" class="headerlink" title="广播函数"></a>广播函数</h5><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/broadCast.png" alt="broadCast"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boardCast</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 点对点桥接</span></span><br><span class="line">    <span class="keyword">if</span> (obj.bridge &amp;&amp; obj.bridge.length) &#123;</span><br><span class="line">        obj.bridge.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            conns[item].sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 群聊</span></span><br><span class="line">    <span class="keyword">if</span> (obj.groupId) &#123;</span><br><span class="line">        group = groups.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> item.id === obj.groupId</span><br><span class="line">        &#125;)[<span class="number">0</span>]</span><br><span class="line">        group.users.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            conns[item.uid].sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.connections.forEach(<span class="function">(<span class="params">conn, index</span>) =&gt;</span> &#123;</span><br><span class="line">        conn.sendText(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="左侧用户列表与群列表的显示"><a href="#左侧用户列表与群列表的显示" class="headerlink" title="左侧用户列表与群列表的显示"></a>左侧用户列表与群列表的显示</h3><ul><li><strong>用户列表</strong>：简单处理，直接遍历users数组里的用户。有个特殊的，<strong>在线和离线</strong></li></ul><p>动态绑定class属性<code>:class=&quot;{ offline: !item.status }&quot;</code>status上文说过，登陆1，离线0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="selector-class">.offline</span></span><br><span class="line">        <span class="selector-tag">color</span> <span class="selector-id">#ccc</span></span><br></pre></td></tr></table></figure><p>给离线的设个灰度颜色。</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/userList.png" alt="userList"></p><ul><li><strong>群列表</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 群数据格式 </span></span><br><span class="line">[&#123;</span><br><span class="line">    <span class="comment">// 群id，通过monent()时间判断</span></span><br><span class="line">    id: moment().valueOf(),</span><br><span class="line">    <span class="comment">// 客户端传过来的群名称</span></span><br><span class="line">    name: obj.groupName,</span><br><span class="line">    <span class="comment">// 群用户可添加多个数组对象</span></span><br><span class="line">    users: [</span><br><span class="line">        &#123;</span><br><span class="line">            uid: obj.uid,</span><br><span class="line">            nickname: obj.nickname</span><br><span class="line">        &#125;,...</span><br><span class="line">    ]</span><br><span class="line">&#125;,...]</span><br></pre></td></tr></table></figure><ol><li><strong>新建群</strong></li></ol><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/newGroup.png" alt="addGroup"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">createGroup () &#123;</span><br><span class="line">    <span class="comment">// 去除前后空格符</span></span><br><span class="line">    <span class="keyword">this</span>.groupName = <span class="keyword">this</span>.groupName.trim()</span><br><span class="line">    <span class="comment">// 确保名称输入</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.groupName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">'请输入群名称'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用socket连接向服务端发送数据</span></span><br><span class="line">    <span class="keyword">this</span>.socket.send(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            uid: <span class="keyword">this</span>.uid,</span><br><span class="line">            type: <span class="number">10</span>,</span><br><span class="line">            nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">            groupName: <span class="keyword">this</span>.groupName,</span><br><span class="line">            bridge: []</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端接受创建群信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建群</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="comment">// 推入群数组</span></span><br><span class="line">groups.push(&#123;</span><br><span class="line">    <span class="comment">// 群id，通过monent()时间判断</span></span><br><span class="line">    id: moment().valueOf(),</span><br><span class="line">    <span class="comment">// 客户端传过来的群名称</span></span><br><span class="line">    name: obj.groupName,</span><br><span class="line">    users: [</span><br><span class="line">        &#123;</span><br><span class="line">            uid: obj.uid,</span><br><span class="line">            nickname: obj.nickname</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'创建了群'</span> + obj.groupName,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>加入群</strong></li></ol><p>客户端</p><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/addGroup2.png" alt="addGroup2"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addGroup (item) &#123;</span><br><span class="line">    <span class="comment">// 通过socket向服务端发送信息</span></span><br><span class="line">    <span class="keyword">this</span>.socket.send(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            uid: <span class="keyword">this</span>.uid,</span><br><span class="line">            type: <span class="number">20</span>,</span><br><span class="line">            nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">            groupId: item.id,</span><br><span class="line">            groupName: item.name,</span><br><span class="line">            bridge: []</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'success'</span>, <span class="attr">message</span>: <span class="string">`成功加入<span class="subst">$&#123;item.name&#125;</span>群`</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入群</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line"><span class="comment">// 找到要加入的群</span></span><br><span class="line"><span class="keyword">let</span> group = groups.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.id === obj.groupId</span><br><span class="line">&#125;)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 推入群，用户组 数据对象</span></span><br><span class="line">group.users.push(&#123;</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname</span><br><span class="line">&#125;)</span><br><span class="line">boardCast(&#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    msg: obj.nickname + <span class="string">'加入了群'</span> + obj.groupName,</span><br><span class="line">    users: users,</span><br><span class="line">    groups: groups,</span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    bridge: obj.bridge</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><h4 id="点对点通讯"><a href="#点对点通讯" class="headerlink" title="点对点通讯"></a>点对点通讯</h4><ul><li>设置一个桥数组，有通讯的两者uid<code>this.bridge = [this.uid, item.uid]</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">triggerPersonal (item) &#123;</span><br><span class="line">    <span class="comment">// 不能和自己聊</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.uid === item.uid) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空群id 与群聊互斥</span></span><br><span class="line">    <span class="keyword">this</span>.groupId = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 桥接两用户uid</span></span><br><span class="line">    <span class="keyword">this</span>.bridge = [<span class="keyword">this</span>.uid, item.uid]</span><br><span class="line">    <span class="comment">// 顶部显示与谁聊天信息</span></span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">`和<span class="subst">$&#123;item.nickname&#125;</span>聊天`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="群通讯"><a href="#群通讯" class="headerlink" title="群通讯"></a>群通讯</h4><ul><li>只要点击接受群id就可以了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">triggerGroup (item) &#123;</span><br><span class="line">    <span class="comment">// 获取群内用户组 判断有无此用户id</span></span><br><span class="line">    <span class="keyword">let</span> issome = item.users.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.uid === <span class="keyword">this</span>.uid</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!issome) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">`您还不是<span class="subst">$&#123;item.name&#125;</span>群成员`</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空桥接数组，与单聊互斥</span></span><br><span class="line">    <span class="keyword">this</span>.bridge = []</span><br><span class="line">    <span class="keyword">this</span>.groupId = item.id</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">`和<span class="subst">$&#123;item.name&#125;</span>群成员聊天`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">send () &#123;</span><br><span class="line">    <span class="comment">// 消除前后空格</span></span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="keyword">this</span>.msg.trim()</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.msg) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点击左侧的用户对象或群才有bridge和群id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.bridge.length &amp;&amp; !<span class="keyword">this</span>.groupId) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$message(&#123; <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">message</span>: <span class="string">'请选择发送人或者群'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.sendMessage(<span class="number">100</span>, <span class="keyword">this</span>.msg)</span><br><span class="line">&#125;,</span><br><span class="line">    sendMessage (type, msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket.send(</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uid: <span class="keyword">this</span>.uid,</span><br><span class="line">                type: type,</span><br><span class="line">                nickname: <span class="keyword">this</span>.nickname,</span><br><span class="line">                msg: msg,</span><br><span class="line">                bridge: <span class="keyword">this</span>.bridge,</span><br><span class="line">                groupId: <span class="keyword">this</span>.groupId</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 每次发送后清空消息栏</span></span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务端广播</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boardCast(&#123;</span><br><span class="line">    <span class="comment">// 2为用户消息，左右侧 。1为系统消息，灰色居中</span></span><br><span class="line">    type: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 日期</span></span><br><span class="line">    date: moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    msg: obj.msg,</span><br><span class="line">    <span class="comment">// 用户id</span></span><br><span class="line">    uid: obj.uid,</span><br><span class="line">    nickname: obj.nickname,</span><br><span class="line">    <span class="comment">// 桥接对对象</span></span><br><span class="line">    bridge: obj.bridge,</span><br><span class="line">    <span class="comment">// 或者群聊id</span></span><br><span class="line">    groupId: obj.groupId,</span><br><span class="line">    <span class="comment">// 消息 已读/未读</span></span><br><span class="line">    status: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="未读消息的闪烁"><a href="#未读消息的闪烁" class="headerlink" title="未读消息的闪烁"></a>未读消息的闪烁</h3><p><img src="/images/loading.png" data-original="https://gitee.com/JasonWu7/picture/raw/master/socket/noReadMessage.png" alt="noReadMessage"></p><p><strong>联系人，群聊Tab</strong>的<strong>闪烁</strong>,如果有一个消息未读，就显示闪烁v-on:class属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usersUnRead () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageList.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 状态 status: 1为未读</span></span><br><span class="line">        <span class="keyword">return</span> item.bridge.length &amp;&amp; item.status === <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="selector-class">.unread</span></span><br><span class="line"><span class="selector-tag">animation</span> <span class="selector-tag">fColorAni</span> 0<span class="selector-class">.3s</span> <span class="selector-tag">infinite</span></span><br><span class="line">@<span class="keyword">keyframes</span> fColorAni</span><br><span class="line">  <span class="number">0%</span></span><br><span class="line">    color $green</span><br><span class="line">  <span class="number">50%</span></span><br><span class="line">    color #<span class="number">46</span>b0ff</span><br><span class="line">  <span class="number">100%</span></span><br><span class="line">    color #<span class="number">333</span></span><br></pre></td></tr></table></figure><p><strong>未读数量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">currentUserList () &#123;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span></span><br><span class="line">    vm.users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">        user.unread = <span class="keyword">this</span>.messageList.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                item.bridge.length &amp;&amp; item.uid === user.uid &amp;&amp; item.status === <span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        &#125;).length</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vm.users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tips-num"</span> <span class="attr">v-if</span>=<span class="string">"item.unread"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.unread&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有未读数量就将他展示出来</p><hr><h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><p>通过此类qq聊天项目，对 WebSocket 有了一定认识，其实它并不神秘。当创建 WebSocket 实例的时候，会发一个 HTTP 请求，请求报文中有个特殊的字段 Upgrade ，然后这个连接会由 HTTP 协议转换为 WebSocket 协议，这样客户端和服务端建立了全双工通信，通过 WebSocket 的 send 方法和 onmessage 事件就可以通过这条通信连接交换信息。</p><p>时间有限，希望寒假能把这个项目完善</p><ol><li><p>登陆，注册 加盐加密</p></li><li><p>用户，群组，关系，聊天信息，数据库建立</p></li></ol><hr><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><a href="https://github.com/2249038142/socket--" target="_blank" rel="noopener">项目地址</a></h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现socket点对点，群-通讯&quot;&gt;&lt;a href=&quot;#实现socket点对点，群-通讯&quot; class=&quot;headerlink&quot; title=&quot;实现socket点对点，群 通讯&quot;&gt;&lt;/a&gt;实现socket点对点，群 通讯&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Java语言不太熟悉，根据老师的思路，实现了 node websocket的简单通讯，前台用的vue。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>call,aplly和bind的内部是如何实现的？</title>
    <link href="http://yoursite.com/2019/12/25/call,aplly%E5%92%8Cbind%E7%9A%84%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/12/25/call,aplly%E5%92%8Cbind%E7%9A%84%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/</id>
    <published>2019-12-25T01:32:06.678Z</published>
    <updated>2019-12-25T01:32:06.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-aplly和bind的内部是如何实现的？"><a href="#call-aplly和bind的内部是如何实现的？" class="headerlink" title="call,aplly和bind的内部是如何实现的？"></a>call,aplly和bind的内部是如何实现的？</h1><blockquote><p>看的掘金上的，哪天还得手写一下加深理解</p></blockquote><p>call 和 apply 的功能相同，区别在于传参的方式不一样:</p><a id="more"></a><!-- build time:Thu Feb 27 2020 13:03:56 GMT+0800 (GMT+08:00) --><ul><li>fn.call(obj, arg1, arg2, …),调用一个函数, 具有一个指定的this值和分别地提供的参数(参数的列表)。</li><li>fn.apply(obj, [argsArray]),调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供的参数。</li></ul><blockquote><p>call核心:</p></blockquote><ul><li>将函数设为传入参数的属性</li><li>指定this到函数并传入给定参数执行函数</li><li>如果不传入参数或者参数为null，默认指向为 window / global</li><li>删除参数上的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */</span></span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">//this指向的是当前的函数(Function的实例)</span></span><br><span class="line">    <span class="keyword">let</span> rest = [...arguments].slice(<span class="number">1</span>);<span class="comment">//获取除了this指向对象以外的参数, 空数组slice后返回的仍然是空数组</span></span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...rest); <span class="comment">//隐式绑定,当前函数的this指向了context.</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'programmer'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.call(<span class="literal">null</span>, <span class="string">'teacher'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs teacher 25; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure><blockquote><p>apply:</p></blockquote><p>apply的实现和call很类似，但是需要注意他们的参数是不一样的，apply的第二个参数是数组或类数组.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(rest === <span class="literal">undefined</span> || rest === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">        result = context.fn(rest);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> rest === <span class="string">'object'</span>) &#123;</span><br><span class="line">        result = context.fn(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.apply(foo, [<span class="string">'programmer'</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.apply(<span class="literal">null</span>, [<span class="string">'teacher'</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs programmer 20; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure><blockquote><p>bind</p></blockquote><p>bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"not a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    Fn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [...args, ...arguments]; <span class="comment">//bind传递的参数和函数调用时传递的参数拼接</span></span><br><span class="line">        context = <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原型链</span></span><br><span class="line">    bound.prototype = <span class="keyword">new</span> Fn();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age, job, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name , age, job, gender);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Yve = &#123;<span class="attr">name</span> : <span class="string">'Yvette'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> result = person.bind(Yve, <span class="number">22</span>, <span class="string">'enginner'</span>)(<span class="string">'female'</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call-aplly和bind的内部是如何实现的？&quot;&gt;&lt;a href=&quot;#call-aplly和bind的内部是如何实现的？&quot; class=&quot;headerlink&quot; title=&quot;call,aplly和bind的内部是如何实现的？&quot;&gt;&lt;/a&gt;call,aplly和bind的内部是如何实现的？&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;看的掘金上的，哪天还得手写一下加深理解&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;call 和 apply 的功能相同，区别在于传参的方式不一样:&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
